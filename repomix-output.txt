This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.repomix/bundles.json
Bindings.xml
BossDetector.lua
Config.lua
Libs/vanilla/Ace3/.docmeta
Libs/vanilla/Ace3/.gitignore
Libs/vanilla/Ace3/.gitmodules
Libs/vanilla/Ace3/.pkgmeta
Libs/vanilla/Ace3/Ace3.lua
Libs/vanilla/Ace3/Ace3.toc
Libs/vanilla/Ace3/AceAddon-3.0/AceAddon-3.0.lua
Libs/vanilla/Ace3/AceAddon-3.0/AceAddon-3.0.xml
Libs/vanilla/Ace3/AceBucket-3.0/AceBucket-3.0.lua
Libs/vanilla/Ace3/AceBucket-3.0/AceBucket-3.0.xml
Libs/vanilla/Ace3/AceComm-3.0/AceComm-3.0.lua
Libs/vanilla/Ace3/AceComm-3.0/AceComm-3.0.xml
Libs/vanilla/Ace3/AceComm-3.0/ChatThrottleLib.lua
Libs/vanilla/Ace3/AceConfig-3.0/AceConfig-3.0.lua
Libs/vanilla/Ace3/AceConfig-3.0/AceConfig-3.0.xml
Libs/vanilla/Ace3/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.lua
Libs/vanilla/Ace3/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.xml
Libs/vanilla/Ace3/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.lua
Libs/vanilla/Ace3/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.xml
Libs/vanilla/Ace3/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.lua
Libs/vanilla/Ace3/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.xml
Libs/vanilla/Ace3/AceConsole-3.0/AceConsole-3.0.lua
Libs/vanilla/Ace3/AceConsole-3.0/AceConsole-3.0.xml
Libs/vanilla/Ace3/AceCore-3.0/AceCore-3.0.lua
Libs/vanilla/Ace3/AceCore-3.0/AceCore-3.0.xml
Libs/vanilla/Ace3/AceCursor-3.0/AceCursor-3.0.lua
Libs/vanilla/Ace3/AceCursor-3.0/AceCursor-3.0.xml
Libs/vanilla/Ace3/AceDB-3.0/AceDB-3.0.lua
Libs/vanilla/Ace3/AceDB-3.0/AceDB-3.0.xml
Libs/vanilla/Ace3/AceDBOptions-3.0/AceDBOptions-3.0.lua
Libs/vanilla/Ace3/AceDBOptions-3.0/AceDBOptions-3.0.xml
Libs/vanilla/Ace3/AceEvent-3.0/AceEvent-3.0.lua
Libs/vanilla/Ace3/AceEvent-3.0/AceEvent-3.0.xml
Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/BackgroundWidget.lua
Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/BorderWidget.lua
Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/FontWidget.lua
Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/prototypes.lua
Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/SoundWidget.lua
Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/StatusbarWidget.lua
Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/widget.xml
Libs/vanilla/Ace3/AceGUI-3.0/AceGUI-3.0.lua
Libs/vanilla/Ace3/AceGUI-3.0/AceGUI-3.0.xml
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-BlizOptionsGroup.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-DropDownGroup.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-Frame.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-InlineGroup.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-ScrollFrame.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-SimpleGroup.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-TabGroup.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-TreeGroup.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-Window.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-Button.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-CheckBox.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-ColorPicker.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-DropDown-Items.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-DropDown.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-EditBox.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-Heading.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-Icon.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-InteractiveLabel.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-Keybinding.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-Label.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-MultiLineEditBox.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-Slider.lua
Libs/vanilla/Ace3/AceGUI-3.0/widgets/widgets.xml
Libs/vanilla/Ace3/AceHook-3.0/AceHook-3.0.lua
Libs/vanilla/Ace3/AceHook-3.0/AceHook-3.0.xml
Libs/vanilla/Ace3/AceLocale-3.0/AceLocale-3.0.lua
Libs/vanilla/Ace3/AceLocale-3.0/AceLocale-3.0.xml
Libs/vanilla/Ace3/AceLocale-3.1/AceLocale-3.1.lua
Libs/vanilla/Ace3/AceLocale-3.1/AceLocale-3.1.xml
Libs/vanilla/Ace3/AceSerializer-3.0/AceSerializer-3.0.lua
Libs/vanilla/Ace3/AceSerializer-3.0/AceSerializer-3.0.xml
Libs/vanilla/Ace3/AceTab-3.0/AceTab-3.0.lua
Libs/vanilla/Ace3/AceTab-3.0/AceTab-3.0.xml
Libs/vanilla/Ace3/AceTimer-3.0/AceTimer-3.0.lua
Libs/vanilla/Ace3/AceTimer-3.0/AceTimer-3.0.xml
Libs/vanilla/Ace3/Bindings.xml
Libs/vanilla/Ace3/changelog.txt
Libs/vanilla/Ace3/LICENSE.txt
Libs/vanilla/Ace3/README.md
Libs/vanilla/CallbackHandler-1.0/CallbackHandler-1.0.lua
Libs/vanilla/CallbackHandler-1.0/CallbackHandler-1.0.xml
Libs/vanilla/JSON.lua
Libs/vanilla/LibDataBroker-1.1/LibDataBroker-1.1.lua
Libs/vanilla/LibDBIcon-1.0/LibDBIcon-1.0.lua
Libs/vanilla/LibDeflate/examples/example.lua
Libs/vanilla/LibDeflate/lib.xml
Libs/vanilla/LibDeflate/LibDeflate.lua
Libs/vanilla/LibDeflate/LibDeflate.toc
Libs/vanilla/LibDeflate/tests/LibCompress/LibCompress.lua
Libs/vanilla/LibDeflate/tests/Test.lua
Libs/vanilla/Libs.xml
Libs/vanilla/LibStub/LibStub.lua
phrases.lua
RaidCaller.code-workspace
RaidCaller.lua
RaidCaller.toc
UI.lua

================================================================
Files
================================================================

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: Bindings.xml
================
<Bindings>
    <Binding name="RC_TOGGLE" header="RAIDCALLER" category="ADDONS">
        RaidCaller.UI:Toggle()
    </Binding>
    <Binding name="RC_SAY_1" category="ADDONS">
        RaidCaller.addon:SayPhrase(1)
    </Binding>
    <Binding name="RC_SAY_2" category="ADDONS">
        RaidCaller.addon:SayPhrase(2)
    </Binding>
    <Binding name="RC_SAY_3" category="ADDONS">
        RaidCaller.addon:SayPhrase(3)
    </Binding>
    <Binding name="RC_SAY_4" category="ADDONS">
        RaidCaller.addon:SayPhrase(4)
    </Binding>
    <Binding name="RC_SAY_5" category="ADDONS">
        RaidCaller.addon:SayPhrase(5)
    </Binding>
</Bindings>

================
File: BossDetector.lua
================
-- BossDetector.lua
-- Handles detection of the current zone and boss.

RaidCaller = RaidCaller or {}

local BossDetectorModule = {}
RaidCaller.BossDetectorModule = BossDetectorModule

function BossDetectorModule:new(addon)
    local detector = {}
    detector.addon = addon
    detector.currentZone = nil
    detector.currentBoss = nil -- This is only used for Automatic mode

    -- Update the current zone text (for automatic mode)
    function detector:UpdateZone()
        if not self.addon.Config:IsAutomaticMode() then return end
        self.currentZone = GetZoneText()
        self.currentBoss = nil -- Reset boss when zone changes
        self.addon.UI:Update()
    end

    -- Set the current boss from BigWigs (for automatic mode)
    function detector:SetBoss(bossName)
        if not self.addon.Config:IsAutomaticMode() then return end
        self.currentBoss = bossName
        self.addon:Print("Encounter Detected (Auto Mode): " .. tostring(bossName or "None"))
        self.addon.UI:Update()
    end
    
    -- Returns the currently active raid and boss based on the addon's mode
    function detector:GetCurrentRaidAndBoss()
        if self.addon.Config:IsAutomaticMode() then
            -- In auto mode, we use the detected zone and boss
            return self.currentZone, self.currentBoss
        else
            -- In manual mode, we use the values saved in our config
            return self.addon.Config:GetManualRaid(), self.addon.Config:GetManualBoss()
        end
    end

    return detector
end

================
File: Config.lua
================
-- Config.lua
-- Manages addon settings and data persistence using AceDB-3.0

RaidCaller = RaidCaller or {}

local ConfigModule = {}
RaidCaller.ConfigModule = ConfigModule

function ConfigModule:new(db)
    local config = {}
    config.db = db

    -- Set the mode (auto/manual)
    function config:SetAutomaticMode(isAutomatic)
        self.db.profile.isAutomatic = isAutomatic
    end

    -- Get the current mode
    function config:IsAutomaticMode()
        return self.db.profile.isAutomatic
    end

    -- Set the manually selected raid
    function config:SetManualRaid(raid)
        self.db.profile.manualRaid = raid
    end

    -- Get the manually selected raid
    function config:GetManualRaid()
        return self.db.profile.manualRaid
    end

    -- Set the manually selected boss
    function config:SetManualBoss(boss)
        self.db.profile.manualBoss = boss
    end

    -- Get the manually selected boss
    function config:GetManualBoss()
        return self.db.profile.manualBoss
    end

    return config
end

================
File: Libs/vanilla/Ace3/.docmeta
================
-
  type: luadoc
  input-files: 
    - "Ace*/Ace*.lua"
    - "AceConfig-3.0/AceConfig*/AceConfig*.lua"
  output-directory: API

================
File: Libs/vanilla/Ace3/.gitignore
================
# Compiled Lua sources
luac.out

# luarocks build files
*.src.rock
*.zip
*.tar.gz

# Object files
*.o
*.os
*.ko
*.obj
*.elf

# Precompiled Headers
*.gch
*.pch

# Libraries
*.lib
*.a
*.la
*.lo
*.def
*.exp

# Shared objects (inc. Windows DLLs)
*.dll
*.so
*.so.*
*.dylib

# Executables
*.exe
*.out
*.app
*.i*86
*.x86_64
*.hex

================
File: Libs/vanilla/Ace3/.gitmodules
================
[submodule "LibStub"]
	path = LibStub
	url = https://github.com/laytya/LibStub
[submodule "CallbackHandler-1.0"]
	path = CallbackHandler-1.0
	url = https://github.com/laytya/CallbackHandler-1.0

================
File: Libs/vanilla/Ace3/.pkgmeta
================
package-as: Ace3

ignore:
 - tests

================
File: Libs/vanilla/Ace3/Ace3.lua
================
-- This file is only there in standalone Ace3 and provides handy dev tool stuff I guess
-- for now only /rl to reload your UI :)
-- note the complete overkill use of AceAddon and console, ain't it cool?

-- GLOBALS: next, loadstring, ReloadUI, geterrorhandler
-- GLOBALS: BINDING_HEADER_ACE3, BINDING_NAME_RELOADUI, Ace3, LibStub

-- BINDINGs labels
BINDING_HEADER_ACE3 = "Ace3"
BINDING_NAME_RELOADUI = "ReloadUI"
--

local gui = LibStub("AceGUI-3.0")
local reg = LibStub("AceConfigRegistry-3.0")
local dialog = LibStub("AceConfigDialog-3.0")
local AceCore = LibStub("AceCore-3.0")

Ace3 = LibStub("AceAddon-3.0"):NewAddon("Ace3", "AceConsole-3.0")
local Ace3 = Ace3

local strfind = string.find
local strtrim = AceCore.strtrim

local selectedgroup
local frame
local select
local status = {}
local configs = {}

local function frameOnClose()
	gui:Release(frame)
	frame = nil
end

local function RefreshConfigs()
	for name in reg:IterateOptionsTables() do
		configs[name] = name
	end
end

local function ConfigSelected(widget, event, _, value)
	selectedgroup = value
	dialog:Open(value, widget)
end

local old_CloseSpecialWindows

-- GLOBALS: CloseSpecialWindows, next
function Ace3:Open()
	if not old_CloseSpecialWindows then
		old_CloseSpecialWindows = CloseSpecialWindows
		CloseSpecialWindows = function()
			local found = old_CloseSpecialWindows()
			if frame then
				frame:Hide()
				return true
			end
			return found
		end
	end
	RefreshConfigs()
	if next(configs) == nil then
		self:Print("No Configs are Registered")
		return
	end

	if not frame then
		frame = gui:Create("Frame")
		frame:ReleaseChildren()
		frame:SetTitle("Ace3 Options")
		frame:SetLayout("FILL")
		frame:SetCallback("OnClose", frameOnClose)

		select = gui:Create("DropdownGroup")
		select:SetGroupList(configs)
		select:SetCallback("OnGroupSelected", ConfigSelected)
		frame:AddChild(select)
	end
	if not selectedgroup then
		selectedgroup = next(configs)
	end
	select:SetGroup(selectedgroup)
	frame:Show()
end

local function RefreshOnUpdate(this)
	select:SetGroup(selectedgroup)
	this:SetScript("OnUpdate", nil)
end

function Ace3:ConfigTableChanged(event, appName)
	if selectedgroup == appName and frame then
		frame.frame:SetScript("OnUpdate", RefreshOnUpdate)
	end
end

reg.RegisterCallback(Ace3, "ConfigTableChange", "ConfigTableChanged")

function Ace3:PrintCmd(input)
	local _,_,input = strfind(strtrim(input), "^(.-);*$")
	local func, err = loadstring("LibStub(\"AceConsole-3.0\"):Print(" .. input .. ")")
	if not func then
		LibStub("AceConsole-3.0"):Print("Error: " .. err)
	else
		func()
	end
end

function Ace3:OnInitialize()
	self:RegisterChatCommand("ace3", function() self:Open() end)
	self:RegisterChatCommand("rl", function() ReloadUI() end)
	self:RegisterChatCommand("print", "PrintCmd")
end

================
File: Libs/vanilla/Ace3/Ace3.toc
================
## Interface: 11200

## Title: Lib: Ace3
## Notes: AddOn development framework
## Author: Ace3 Development Team
## X-Website: http://www.wowace.com
## X-Category: Library
## X-License: Limited BSD

LibStub\LibStub.lua
CallbackHandler-1.0\CallbackHandler-1.0.xml

AceCore-3.0\AceCore-3.0.xml
AceAddon-3.0\AceAddon-3.0.xml
AceEvent-3.0\AceEvent-3.0.xml
AceTimer-3.0\AceTimer-3.0.xml
AceBucket-3.0\AceBucket-3.0.xml
AceHook-3.0\AceHook-3.0.xml
AceDB-3.0\AceDB-3.0.xml
AceDBOptions-3.0\AceDBOptions-3.0.xml
AceLocale-3.0\AceLocale-3.0.xml
AceLocale-3.1\AceLocale-3.1.xml
AceConsole-3.0\AceConsole-3.0.xml
AceCursor-3.0\AceCursor-3.0.xml
AceGUI-3.0\AceGUI-3.0.xml
AceGUI-3.0\widgets\widgets.xml
AceConfig-3.0\AceConfig-3.0.xml
AceComm-3.0\AceComm-3.0.xml
AceTab-3.0\AceTab-3.0.xml
AceSerializer-3.0\AceSerializer-3.0.xml

Ace3.lua

================
File: Libs/vanilla/Ace3/AceAddon-3.0/AceAddon-3.0.lua
================
--- **AceAddon-3.0** provides a template for creating addon objects.
-- It'll provide you with a set of callback functions that allow you to simplify the loading
-- process of your addon.\\
-- Callbacks provided are:\\
-- * **OnInitialize**, which is called directly after the addon is fully loaded.
-- * **OnEnable** which gets called during the PLAYER_LOGIN event, when most of the data provided by the game is already present.
-- * **OnDisable**, which is only called when your addon is manually being disabled.
-- @usage
-- -- A small (but complete) addon, that doesn't do anything,
-- -- but shows usage of the callbacks.
-- local MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon")
--
-- function MyAddon:OnInitialize()
--   -- do init tasks here, like loading the Saved Variables,
--   -- or setting up slash commands.
-- end
--
-- function MyAddon:OnEnable()
--   -- Do more initialization here, that really enables the use of your addon.
--   -- Register Events, Hook functions, Create Frames, Get information from
--   -- the game that wasn't available in OnInitialize
-- end
--
-- function MyAddon:OnDisable()
--   -- Unhook, Unregister Events, Hide frames that you created.
--   -- You would probably only use an OnDisable if you want to
--   -- build a "standby" mode, or be able to toggle modules on/off.
-- end
-- @class file
-- @name AceAddon-3.0.lua
-- @release $Id: AceAddon-3.0.lua 1084 2013-04-27 20:14:11Z nevcairiel $

local MAJOR, MINOR = "AceAddon-3.0", 12
local AceAddon, oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceAddon then return end -- No Upgrade needed.

local AceCore = LibStub("AceCore-3.0")
local new, del = AceCore.new, AceCore.del
local wipe, truncate = AceCore.wipe, AceCore.truncate

AceAddon.frame = AceAddon.frame or CreateFrame("Frame", "AceAddon30Frame") -- Our very own frame
AceAddon.addons = AceAddon.addons or {} -- addons in general
AceAddon.statuses = AceAddon.statuses or {} -- statuses of addon.
AceAddon.initializequeue = AceAddon.initializequeue or {} -- addons that are new and not initialized
AceAddon.enablequeue = AceAddon.enablequeue or {} -- addons that are initialized and waiting to be enabled
AceAddon.embeds = AceAddon.embeds or setmetatable({}, {__index = function(tbl, key) tbl[key] = {} return tbl[key] end }) -- contains a list of libraries embedded in an addon

-- Lua APIs
local tinsert, tconcat, tremove, tgetn = table.insert, table.concat, table.remove, table.getn
local strfmt, tostring = string.format, tostring
local pairs, next, type, unpack = pairs, next, type, unpack
local loadstring, assert, error = loadstring, assert, error
local setmetatable, getmetatable, rawset, rawget = setmetatable, getmetatable, rawset, rawget

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: LibStub, IsLoggedIn, geterrorhandler

--[[
	 xpcall safecall implementation
]]
local safecall = AceCore.safecall

-- local functions that will be implemented further down
local Enable, Disable, EnableModule, DisableModule, Embed, NewModule, GetModule, GetName, SetDefaultModuleState, SetDefaultModuleLibraries, SetEnabledState, SetDefaultModulePrototype

-- used in the addon metatable
local function addontostring( self ) return self.name end

-- Check if the addon is queued for initialization
local function queuedForInitialization(addon)
	for i = 1, tgetn(AceAddon.initializequeue) do
		if AceAddon.initializequeue[i] == addon then
			return true
		end
	end
	return false
end

--- Create a new AceAddon-3.0 addon.
-- Any libraries you specified will be embeded, and the addon will be scheduled for
-- its OnInitialize and OnEnable callbacks.
-- The final addon object, with all libraries embeded, will be returned.
-- @paramsig [object ,]name[, lib, ...]
-- @param object Table to use as a base for the addon (optional)
-- @param name Name of the addon object to create
-- @param lib List of libraries to embed into the addon
-- @usage
-- -- Create a simple addon object
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceEvent-3.0")
--
-- -- Create a Addon object based on the table of a frame
-- local MyFrame = CreateFrame("Frame")
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon(MyFrame, "MyAddon", "AceEvent-3.0")
function AceAddon:NewAddon(objectorname,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)

	local object,name
	if type(objectorname)=="table" then
		object=objectorname
		name=a0
	else
		name=objectorname
	end
	if type(name)~="string" then
		error(strfmt("Usage: NewAddon([object,] name, [lib, lib, lib, ...]): 'name' - string expected got '%s'.", type(name)), 2)
	end
	if self.addons[name] then
		error(strfmt("Usage: NewAddon([object,] name, [lib, lib, lib, ...]): 'name' - Addon '%s' already exists.", name), 2)
	end

	local args = new()
	args[1] = a1
	args[2] = a2
	args[3] = a3
	args[4] = a4
	args[5] = a5
	args[6] = a6
	args[7] = a7
	args[8] = a8
	args[9] = a9
	args[10] = a10

	object = object or {}
	object.name = name

	local addonmeta = {}
	local oldmeta = getmetatable(object)
	if oldmeta then
		for k, v in pairs(oldmeta) do addonmeta[k] = v end
	end
	addonmeta.__tostring = addontostring

	setmetatable( object, addonmeta )
	self.addons[name] = object
	object.modules = {}
	object.orderedModules = {}
	object.defaultModuleLibraries = {}
	Embed( object ) -- embed NewModule, GetModule methods
	if type(objectorname)=="table" then
		self:EmbedLibraries(object,nil,args)
	elseif a0 then
		self:EmbedLibraries(object,a0,args)
	end
	del(args)

	-- add to queue of addons to be initialized upon ADDON_LOADED
	tinsert(self.initializequeue, object)
	return object
end

--- Get the addon object by its name from the internal AceAddon registry.
-- Throws an error if the addon object cannot be found (except if silent is set).
-- @param name unique name of the addon object
-- @param silent if true, the addon is optional, silently return nil if its not found
-- @usage
-- -- Get the Addon
-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
function AceAddon:GetAddon(name, silent)
	if not silent and not self.addons[name] then
		error(strfmt("Usage: GetAddon(name): 'name' - Cannot find an AceAddon '%s'.", tostring(name)), 2)
	end
	return self.addons[name]
end

-- - Embed a list of libraries into the specified addon.
-- This function will try to embed all of the listed libraries into the addon
-- and error if a single one fails.
--
-- **Note:** This function is for internal use by :NewAddon/:NewModule
-- @paramsig addon, [lib, ...]
-- @param addon addon object to embed the libs in
-- @param lib List of libraries to embed into the addon
function AceAddon:EmbedLibraries(addon,a1,arg)
	if a1 then self:EmbedLibrary(addon, a1, false, 4) end
	-- 10 is the max number of variable arguments in the function NewAddon and NewModule
	for i=1,10 do
		if not arg[i] then return end
		self:EmbedLibrary(addon, arg[i], false, 4)
	end
end

-- - Embed a library into the addon object.
-- This function will check if the specified library is registered with LibStub
-- and if it has a :Embed function to call. It'll error if any of those conditions
-- fails.
--
-- **Note:** This function is for internal use by :EmbedLibraries
-- @paramsig addon, libname[, silent[, offset]]
-- @param addon addon object to embed the library in
-- @param libname name of the library to embed
-- @param silent marks an embed to fail silently if the library doesn't exist (optional)
-- @param offset will push the error messages back to said offset, defaults to 2 (optional)
function AceAddon:EmbedLibrary(addon, libname, silent, offset)
	local lib = LibStub:GetLibrary(libname, true)
	if not lib and not silent then
		error(strfmt("Usage: EmbedLibrary(addon, libname, silent, offset): 'libname' - Cannot find a library instance of %q.", tostring(libname)), offset or 2)
	elseif lib and type(lib.Embed) == "function" then
		lib:Embed(addon)
		tinsert(self.embeds[addon], libname)
		return true
	elseif lib then
		error(strfmt("Usage: EmbedLibrary(addon, libname, silent, offset): 'libname' - Library '%s' is not Embed capable", libname), offset or 2)
	end
end

--- Return the specified module from an addon object.
-- Throws an error if the addon object cannot be found (except if silent is set)
-- @name //addon//:GetModule
-- @paramsig name[, silent]
-- @param name unique name of the module
-- @param silent if true, the module is optional, silently return nil if its not found (optional)
-- @usage
-- -- Get the Addon
-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
-- -- Get the Module
-- MyModule = MyAddon:GetModule("MyModule")
function GetModule(self, name, silent)
	if not self.modules[name] and not silent then
		error(strfmt("Usage: GetModule(name, silent): 'name' - Cannot find module '%s'.", tostring(name)), 2)
	end
	return self.modules[name]
end

local function IsModuleTrue(self) return true end

--- Create a new module for the addon.
-- The new module can have its own embeded libraries and/or use a module prototype to be mixed into the module.\\
-- A module has the same functionality as a real addon, it can have modules of its own, and has the same API as
-- an addon object.
-- @name //addon//:NewModule
-- @paramsig name[, prototype|lib[, lib, ...]]
-- @param name unique name of the module
-- @param prototype object to derive this module from, methods and values from this table will be mixed into the module (optional)
-- @param lib List of libraries to embed into the addon
-- @usage
-- -- Create a module with some embeded libraries
-- MyModule = MyAddon:NewModule("MyModule", "AceEvent-3.0", "AceHook-3.0")
--
-- -- Create a module with a prototype
-- local prototype = { OnEnable = function(self) print("OnEnable called!") end }
-- MyModule = MyAddon:NewModule("MyModule", prototype, "AceEvent-3.0", "AceHook-3.0")
function NewModule(self, name, prototype, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	if type(name) ~= "string" then error(strfmt("Usage: NewModule(name, [prototype, [lib, lib, lib, ...]): 'name' - string expected got '%s'.", type(name)), 2) end
	if type(prototype) ~= "string" and type(prototype) ~= "table" and type(prototype) ~= "nil" then error(strfmt("Usage: NewModule(name, [prototype, [lib, lib, lib, ...]): 'prototype' - table (prototype), string (lib) or nil expected got '%s'.", type(prototype)), 2) end

	if self.modules[name] then error(strfmt("Usage: NewModule(name, [prototype, [lib, lib, lib, ...]): 'name' - Module '%s' already exists.", name), 2) end

	-- modules are basically addons. We treat them as such. They will be added to the initializequeue properly as well.
	-- NewModule can only be called after the parent addon is present thus the modules will be initialized after their parent is.
	local module = AceAddon:NewAddon(strfmt("%s_%s", self.name or tostring(self), name))

	module.IsModule = IsModuleTrue
	module:SetEnabledState(self.defaultModuleState)
	module.moduleName = name

	local args = new()
	args[1] = a1
	args[2] = a2
	args[3] = a3
	args[4] = a4
	args[5] = a5
	args[6] = a6
	args[7] = a7
	args[8] = a8
	args[9] = a9
	args[10] = a10

	if type(prototype) == "string" then
		AceAddon:EmbedLibraries(module, prototype, args)
	else
		AceAddon:EmbedLibraries(module, nil, args)
	end
	del(args)
	AceAddon:EmbedLibraries(module, nil, self.defaultModuleLibraries)

	if not prototype or type(prototype) == "string" then
		prototype = self.defaultModulePrototype or nil
	end

	if type(prototype) == "table" then
		local mt = getmetatable(module)
		mt.__index = prototype
		setmetatable(module, mt)  -- More of a Base class type feel.
	end

	safecall(self.OnModuleCreated, 2, self, module) -- Was in Ace2 and I think it could be a cool thing to have handy.
	self.modules[name] = module
	tinsert(self.orderedModules, module)

	return module
end

--- Returns the real name of the addon or module, without any prefix.
-- @name //addon//:GetName
-- @paramsig
-- @usage
-- print(MyAddon:GetName())
-- -- prints "MyAddon"
function GetName(self)
	return self.moduleName or self.name
end

--- Enables the Addon, if possible, return true or false depending on success.
-- This internally calls AceAddon:EnableAddon(), thus dispatching a OnEnable callback
-- and enabling all modules of the addon (unless explicitly disabled).\\
-- :Enable() also sets the internal `enableState` variable to true
-- @name //addon//:Enable
-- @paramsig
-- @usage
-- -- Enable MyModule
-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
-- MyModule = MyAddon:GetModule("MyModule")
-- MyModule:Enable()
function Enable(self)
	self:SetEnabledState(true)

	-- nevcairiel 2013-04-27: don't enable an addon/module if its queued for init still
	-- it'll be enabled after the init process
	if not queuedForInitialization(self) then
		return AceAddon:EnableAddon(self)
	end
end

--- Disables the Addon, if possible, return true or false depending on success.
-- This internally calls AceAddon:DisableAddon(), thus dispatching a OnDisable callback
-- and disabling all modules of the addon.\\
-- :Disable() also sets the internal `enableState` variable to false
-- @name //addon//:Disable
-- @paramsig
-- @usage
-- -- Disable MyAddon
-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
-- MyAddon:Disable()
function Disable(self)
	self:SetEnabledState(false)
	return AceAddon:DisableAddon(self)
end

--- Enables the Module, if possible, return true or false depending on success.
-- Short-hand function that retrieves the module via `:GetModule` and calls `:Enable` on the module object.
-- @name //addon//:EnableModule
-- @paramsig name
-- @usage
-- -- Enable MyModule using :GetModule
-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
-- MyModule = MyAddon:GetModule("MyModule")
-- MyModule:Enable()
--
-- -- Enable MyModule using the short-hand
-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
-- MyAddon:EnableModule("MyModule")
function EnableModule(self, name)
	local module = self:GetModule( name )
	return module:Enable()
end

--- Disables the Module, if possible, return true or false depending on success.
-- Short-hand function that retrieves the module via `:GetModule` and calls `:Disable` on the module object.
-- @name //addon//:DisableModule
-- @paramsig name
-- @usage
-- -- Disable MyModule using :GetModule
-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
-- MyModule = MyAddon:GetModule("MyModule")
-- MyModule:Disable()
--
-- -- Disable MyModule using the short-hand
-- MyAddon = LibStub("AceAddon-3.0"):GetAddon("MyAddon")
-- MyAddon:DisableModule("MyModule")
function DisableModule(self, name)
	local module = self:GetModule( name )
	return module:Disable()
end

--- Set the default libraries to be mixed into all modules created by this object.
-- Note that you can only change the default module libraries before any module is created.
-- @name //addon//:SetDefaultModuleLibraries
-- @paramsig lib[, lib, ...]
-- @param lib List of libraries to embed into the addon
-- @usage
-- -- Create the addon object
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon")
-- -- Configure default libraries for modules (all modules need AceEvent-3.0)
-- MyAddon:SetDefaultModuleLibraries("AceEvent-3.0")
-- -- Create a module
-- MyModule = MyAddon:NewModule("MyModule")
function SetDefaultModuleLibraries(self,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	if next(self.modules) then
		error("Usage: SetDefaultModuleLibraries(...): cannot change the module defaults after a module has been registered.", 2)
	end
	local args = self.defaultModuleLibraries or {}

	args[1] = a1
	args[2] = a2
	args[3] = a3
	args[4] = a4
	args[5] = a5
	args[6] = a6
	args[7] = a7
	args[8] = a8
	args[9] = a9
	args[10] = a10
	truncate(tmp,10)

	self.defaultModuleLibraries = args
end

--- Set the default state in which new modules are being created.
-- Note that you can only change the default state before any module is created.
-- @name //addon//:SetDefaultModuleState
-- @paramsig state
-- @param state Default state for new modules, true for enabled, false for disabled
-- @usage
-- -- Create the addon object
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon")
-- -- Set the default state to "disabled"
-- MyAddon:SetDefaultModuleState(false)
-- -- Create a module and explicilty enable it
-- MyModule = MyAddon:NewModule("MyModule")
-- MyModule:Enable()
function SetDefaultModuleState(self, state)
	if next(self.modules) then
		error("Usage: SetDefaultModuleState(state): cannot change the module defaults after a module has been registered.", 2)
	end
	self.defaultModuleState = state
end

--- Set the default prototype to use for new modules on creation.
-- Note that you can only change the default prototype before any module is created.
-- @name //addon//:SetDefaultModulePrototype
-- @paramsig prototype
-- @param prototype Default prototype for the new modules (table)
-- @usage
-- -- Define a prototype
-- local prototype = { OnEnable = function(self) print("OnEnable called!") end }
-- -- Set the default prototype
-- MyAddon:SetDefaultModulePrototype(prototype)
-- -- Create a module and explicitly Enable it
-- MyModule = MyAddon:NewModule("MyModule")
-- MyModule:Enable()
-- -- should print "OnEnable called!" now
-- @see NewModule
function SetDefaultModulePrototype(self, prototype)
	if next(self.modules) then
		error("Usage: SetDefaultModulePrototype(prototype): cannot change the module defaults after a module has been registered.", 2)
	end
	if type(prototype) ~= "table" then
		error(strfmt("Usage: SetDefaultModulePrototype(prototype): 'prototype' - table expected got '%s'.", type(prototype)), 2)
	end
	self.defaultModulePrototype = prototype
end

--- Set the state of an addon or module
-- This should only be called before any enabling actually happend, e.g. in/before OnInitialize.
-- @name //addon//:SetEnabledState
-- @paramsig state
-- @param state the state of an addon or module  (enabled=true, disabled=false)
function SetEnabledState(self, state)
	self.enabledState = state
end


--- Return an iterator of all modules associated to the addon.
-- @name //addon//:IterateModules
-- @paramsig
-- @usage
-- -- Enable all modules
-- for name, module in MyAddon:IterateModules() do
--    module:Enable()
-- end
local function IterateModules(self) return pairs(self.modules) end

-- Returns an iterator of all embeds in the addon
-- @name //addon//:IterateEmbeds
-- @paramsig
local function IterateEmbeds(self) return pairs(AceAddon.embeds[self]) end

--- Query the enabledState of an addon.
-- @name //addon//:IsEnabled
-- @paramsig
-- @usage
-- if MyAddon:IsEnabled() then
--     MyAddon:Disable()
-- end
local function IsEnabled(self) return self.enabledState end
local mixins = {
	NewModule = NewModule,
	GetModule = GetModule,
	Enable = Enable,
	Disable = Disable,
	EnableModule = EnableModule,
	DisableModule = DisableModule,
	IsEnabled = IsEnabled,
	SetDefaultModuleLibraries = SetDefaultModuleLibraries,
	SetDefaultModuleState = SetDefaultModuleState,
	SetDefaultModulePrototype = SetDefaultModulePrototype,
	SetEnabledState = SetEnabledState,
	IterateModules = IterateModules,
	IterateEmbeds = IterateEmbeds,
	GetName = GetName,
}
local function IsModule(self) return false end
local pmixins = {
	defaultModuleState = true,
	enabledState = true,
	IsModule = IsModule,
}
-- Embed( target )
-- target (object) - target object to embed aceaddon in
--
-- this is a local function specifically since it's meant to be only called internally
function Embed(target, skipPMixins)
	for k, v in pairs(mixins) do
		target[k] = v
	end
	if not skipPMixins then
		for k, v in pairs(pmixins) do
			target[k] = target[k] or v
		end
	end
end


-- - Initialize the addon after creation.
-- This function is only used internally during the ADDON_LOADED event
-- It will call the **OnInitialize** function on the addon object (if present),
-- and the **OnEmbedInitialize** function on all embeded libraries.
--
-- **Note:** Do not call this function manually, unless you're absolutely sure that you know what you are doing.
-- @param addon addon object to intialize
function AceAddon:InitializeAddon(addon)
	safecall(addon.OnInitialize, 1, addon)

	local embeds = self.embeds[addon]
	for i = 1, tgetn(embeds) do
		local lib = LibStub:GetLibrary(embeds[i], true)
		if lib then safecall(lib.OnEmbedInitialize, 2, lib, addon) end
	end

	-- we don't call InitializeAddon on modules specifically, this is handled
	-- from the event handler and only done _once_
end

-- - Enable the addon after creation.
-- Note: This function is only used internally during the PLAYER_LOGIN event, or during ADDON_LOADED,
-- if IsLoggedIn() already returns true at that point, e.g. for LoD Addons.
-- It will call the **OnEnable** function on the addon object (if present),
-- and the **OnEmbedEnable** function on all embeded libraries.\\
-- This function does not toggle the enable state of the addon itself, and will return early if the addon is disabled.
--
-- **Note:** Do not call this function manually, unless you're absolutely sure that you know what you are doing.
-- Use :Enable on the addon itself instead.
-- @param addon addon object to enable
function AceAddon:EnableAddon(addon)
	if type(addon) == "string" then addon = AceAddon:GetAddon(addon) end
	if self.statuses[addon.name] or not addon.enabledState then return false end

	-- set the statuses first, before calling the OnEnable. this allows for Disabling of the addon in OnEnable.
	self.statuses[addon.name] = true

	safecall(addon.OnEnable, 1, addon)

	-- make sure we're still enabled before continueing
	if self.statuses[addon.name] then
		local embeds = self.embeds[addon]
		for i = 1, tgetn(embeds) do
			local lib = LibStub:GetLibrary(embeds[i], true)
			if lib then safecall(lib.OnEmbedEnable, 2, lib, addon) end
		end

		-- enable possible modules.
		local modules = addon.orderedModules
		for i = 1, tgetn(modules) do
			self:EnableAddon(modules[i])
		end
	end
	return self.statuses[addon.name] -- return true if we're disabled
end

-- - Disable the addon
-- Note: This function is only used internally.
-- It will call the **OnDisable** function on the addon object (if present),
-- and the **OnEmbedDisable** function on all embeded libraries.\\
-- This function does not toggle the enable state of the addon itself, and will return early if the addon is still enabled.
--
-- **Note:** Do not call this function manually, unless you're absolutely sure that you know what you are doing.
-- Use :Disable on the addon itself instead.
-- @param addon addon object to enable
function AceAddon:DisableAddon(addon)
	if type(addon) == "string" then addon = AceAddon:GetAddon(addon) end
	if not self.statuses[addon.name] then return false end

	-- set statuses first before calling OnDisable, this allows for aborting the disable in OnDisable.
	self.statuses[addon.name] = false

	safecall(addon.OnDisable, 1, addon)

	-- make sure we're still disabling...
	if not self.statuses[addon.name] then
		local embeds = self.embeds[addon]
		for i = 1, tgetn(embeds) do
			local lib = LibStub:GetLibrary(embeds[i], true)
			if lib then safecall(lib.OnEmbedDisable, 2, lib, addon) end
		end
		-- disable possible modules.
		local modules = addon.orderedModules
		for i = 1, tgetn(modules) do
			self:DisableAddon(modules[i])
		end
	end

	return not self.statuses[addon.name] -- return true if we're disabled
end

--- Get an iterator over all registered addons.
-- @usage
-- -- Print a list of all installed AceAddon's
-- for name, addon in AceAddon:IterateAddons() do
--   print("Addon: " .. name)
-- end
function AceAddon:IterateAddons() return pairs(self.addons) end

--- Get an iterator over the internal status registry.
-- @usage
-- -- Print a list of all enabled addons
-- for name, status in AceAddon:IterateAddonStatus() do
--   if status then
--     print("EnabledAddon: " .. name)
--   end
-- end
function AceAddon:IterateAddonStatus() return pairs(self.statuses) end

-- Following Iterators are deprecated, and their addon specific versions should be used
-- e.g. addon:IterateEmbeds() instead of :IterateEmbedsOnAddon(addon)
function AceAddon:IterateEmbedsOnAddon(addon) return pairs(self.embeds[addon]) end
function AceAddon:IterateModulesOfAddon(addon) return pairs(addon.modules) end


local onEvent
do
local IsLoggedIn = false
-- Event Handling
function onEvent()
	-- 2011-08-17 nevcairiel - ignore the load event of Blizzard_DebugTools, so a potential startup error isn't swallowed up
	-- Ace3v: When the ADDON_LOADED event is triggerd, global arg1 is the loaded addon name
	--        so onEvent(event, arg1) won't work because it will cover the global variables
	if (event == "ADDON_LOADED"  and arg1 ~= "Blizzard_DebugTools") or event == "PLAYER_LOGIN" then
		-- if a addon loads another addon, recursion could happen here, so we need to validate the table on every iteration
		-- Ace3v: When an Ace3 addons is loaded, then he initializeque should not be empty unless
		--        the addon does not use the library. If an addon that does not use Ace3 library
		--        is loaded, we will also receive the ADDON_LOADED event but in this case the
		--        queue will be empty so we have nothing to do.
		while(tgetn(AceAddon.initializequeue) > 0) do
			local addon = tremove(AceAddon.initializequeue, 1)
			-- this might be an issue with recursion - TODO: validate
			if event == "ADDON_LOADED" then addon.baseName = arg1 end
			AceAddon:InitializeAddon(addon)
			tinsert(AceAddon.enablequeue, addon)
		end

		if event == "PLAYER_LOGIN" then
			IsLoggedIn = true
		end

		if IsLoggedIn then
			while(tgetn(AceAddon.enablequeue) > 0) do
				local addon = tremove(AceAddon.enablequeue, 1)
				AceAddon:EnableAddon(addon)
			end
		end
	end
end
end	-- onEvent

AceAddon.frame:RegisterEvent("ADDON_LOADED")
AceAddon.frame:RegisterEvent("PLAYER_LOGIN")
AceAddon.frame:SetScript("OnEvent", onEvent)

-- upgrade embeded
for name, addon in pairs(AceAddon.addons) do
	Embed(addon, true)
end

================
File: Libs/vanilla/Ace3/AceAddon-3.0/AceAddon-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceAddon-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceBucket-3.0/AceBucket-3.0.lua
================
--- A bucket to catch events in. **AceBucket-3.0** provides throttling of events that fire in bursts and
-- your addon only needs to know about the full burst.
--
-- This Bucket implementation works as follows:\\
--   Initially, no schedule is running, and its waiting for the first event to happen.\\
--   The first event will start the bucket, and get the scheduler running, which will collect all
--   events in the given interval. When that interval is reached, the bucket is pushed to the
--   callback and a new schedule is started. When a bucket is empty after its interval, the scheduler is
--   stopped, and the bucket is only listening for the next event to happen, basically back in its initial state.
--
-- In addition, the buckets collect information about the "arg1" argument of the events that fire, and pass those as a
-- table to your callback. This functionality was mostly designed for the UNIT_* events.\\
-- The table will have the different values of "arg1" as keys, and the number of occurances as their value, e.g.\\
--   { ["player"] = 2, ["target"] = 1, ["party1"] = 1 }
--
-- **AceBucket-3.0** can be embeded into your addon, either explicitly by calling AceBucket:Embed(MyAddon) or by
-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
-- and can be accessed directly, without having to explicitly call AceBucket itself.\\
-- It is recommended to embed AceBucket, otherwise you'll have to specify a custom `self` on all calls you
-- make into AceBucket.
-- @usage
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("BucketExample", "AceBucket-3.0")
--
-- function MyAddon:OnEnable()
--   -- Register a bucket that listens to all the HP related events,
--   -- and fires once per second
--   self:RegisterBucketEvent({"UNIT_HEALTH", "UNIT_MAXHEALTH"}, 1, "UpdateHealth")
-- end
--
-- function MyAddon:UpdateHealth(units)
--   if units.player then
--     print("Your HP changed!")
--   end
-- end
-- @class file
-- @name AceBucket-3.0.lua
-- @release $Id: AceBucket-3.0.lua 895 2009-12-06 16:28:55Z nevcairiel $

local MAJOR, MINOR = "AceBucket-3.0", 3
local AceBucket, oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceBucket then return end -- No Upgrade needed

local AceCore = LibStub("AceCore-3.0")
local wipe = AceCore.wipe

AceBucket.buckets = AceBucket.buckets or {}
AceBucket.embeds = AceBucket.embeds or {}
AceBucket.bucketCache = AceBucket.bucketCache or setmetatable({}, {__mode='k'})

-- the libraries will be lazyly bound later, to avoid errors due to loading order issues
local AceEvent, AceTimer

-- Lua APIs
local tconcat = table.concat
local type, next, pairs = type, next, pairs
local tonumber, tostring, rawset = tonumber, tostring, rawset
local assert, loadstring, error = assert, loadstring, error

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: LibStub, geterrorhandler

local bucketCache = AceBucket.bucketCache

--[[
	 xpcall safecall implementation
]]
local safecall = AceCore.safecall

-- FireBucket ( bucket )
--
-- send the bucket to the callback function and schedule the next FireBucket in interval seconds
local function FireBucket(bucket)
	local received = bucket.received
	-- we dont want to fire empty buckets
	if next(received) then
		local callback = bucket.callback
		local timer = bucket.timer
		if type(callback) == "string" then
			safecall(bucket.object[callback], 2, bucket.object, received)
		else
			safecall(callback, 1, received)
		end
		-- Ace3v: if the timer becomes different, that means the bucket has been cancelled in the callback
		-- and the received table was already cleared once, it may also contain the new datas if the
		-- event/message for the new bucket is also fired in the callback
		if bucket.timer == timer then
			for k in pairs(received) do
				received[k] = nil
			end
			-- if the bucket was not empty, schedule another FireBucket in interval seconds
			bucket.timer = AceTimer.ScheduleTimer(bucket, FireBucket, bucket.interval, 1, bucket)
		end
	else -- if it was empty, clear the timer and wait for the next event
		bucket.timer = nil
	end
end

-- BucketHandler ( event, arg1 )
--
-- callback func for AceEvent
-- stores arg1 in the received table, and schedules the bucket if necessary
local function BucketHandler(self, a1)
	if not self.isMessage then a1 = arg1 end
	if a1 == nil then
		a1 = "nil"
	end

	self.received[a1] = (self.received[a1] or 0) + 1

	-- if we are not scheduled yet, start a timer on the interval for our bucket to be cleared
	if not self.timer then
		self.timer = AceTimer.ScheduleTimer(self, FireBucket, self.interval, 1, self)
	end
end

-- RegisterBucket( event, interval, callback, isMessage )
--
-- event(string or table) - the event, or a table with the events, that this bucket listens to
-- interval(int) - time between bucket fireings
-- callback(func or string) - function pointer, or method name of the object, that gets called when the bucket is cleared
-- isMessage(boolean) - register AceEvent Messages instead of game events
local function RegisterBucket(self, event, interval, callback, isMessage)
	-- try to fetch the librarys
	if not AceEvent or not AceTimer then
		AceEvent = LibStub:GetLibrary("AceEvent-3.0", true)
		AceTimer = LibStub:GetLibrary("AceTimer-3.0", true)
		if not AceEvent or not AceTimer then
			error(MAJOR .. " requires AceEvent-3.0 and AceTimer-3.0", 3)
		end
	end

	if type(event) ~= "string" and type(event) ~= "table" then error("Usage: RegisterBucket(event, interval, callback): 'event' - string or table expected.", 3) end
	if not callback then
		if type(event) == "string" then
			callback = event
		else
			error("Usage: RegisterBucket(event, interval, callback): cannot omit callback when event is not a string.", 3)
		end
	end

	if not tonumber(interval) then error("Usage: RegisterBucket(event, interval, callback): 'interval' - number expected.", 3) end
	if type(callback) ~= "string" and type(callback) ~= "function" then error("Usage: RegisterBucket(event, interval, callback): 'callback' - string or function or nil expected.", 3) end
	if type(callback) == "string" and type(self[callback]) ~= "function" then error("Usage: RegisterBucket(event, interval, callback): 'callback' - method not found on target object.", 3) end

	local bucket = next(bucketCache)
	if bucket then
		bucketCache[bucket] = nil
	else
		bucket = { handler = BucketHandler, received = {} }
	end
	bucket.isMessage = isMessage
	bucket.object, bucket.callback, bucket.interval = self, callback, tonumber(interval)

	local regFunc = isMessage and AceEvent.RegisterMessage or AceEvent.RegisterEvent

	if type(event) == "table" then
		for _,e in pairs(event) do
			regFunc(bucket, e, "handler")
		end
	else
		regFunc(bucket, event, "handler")
	end

	local handle = tostring(bucket)
	AceBucket.buckets[handle] = bucket

	return handle
end

--- Register a Bucket for an event (or a set of events)
-- @param event The event to listen for, or a table of events.
-- @param interval The Bucket interval (burst interval)
-- @param callback The callback function, either as a function reference, or a string pointing to a method of the addon object.
-- @return The handle of the bucket (for unregistering)
-- @usage
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceBucket-3.0")
-- MyAddon:RegisterBucketEvent("BAG_UPDATE", 0.2, "UpdateBags")
--
-- function MyAddon:UpdateBags()
--   -- do stuff
-- end
function AceBucket:RegisterBucketEvent(event, interval, callback)
	return RegisterBucket(self, event, interval, callback, false)
end

--- Register a Bucket for an AceEvent-3.0 addon message (or a set of messages)
-- @param message The message to listen for, or a table of messages.
-- @param interval The Bucket interval (burst interval)
-- @param callback The callback function, either as a function reference, or a string pointing to a method of the addon object.
-- @return The handle of the bucket (for unregistering)
-- @usage
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceBucket-3.0")
-- MyAddon:RegisterBucketEvent("SomeAddon_InformationMessage", 0.2, "ProcessData")
--
-- function MyAddon:ProcessData()
--   -- do stuff
-- end
function AceBucket:RegisterBucketMessage(message, interval, callback)
	return RegisterBucket(self, message, interval, callback, true)
end

--- Unregister any events and messages from the bucket and clear any remaining data.
-- @param handle The handle of the bucket as returned by RegisterBucket*
function AceBucket:UnregisterBucket(handle)
	local bucket = AceBucket.buckets[handle]
	if bucket then
		AceEvent.UnregisterAllEvents(bucket)
		AceEvent.UnregisterAllMessages(bucket)

		-- clear any remaining data in the bucket
		for k in pairs(bucket.received) do
			bucket.received[k] = nil
		end

		if bucket.timer then
			AceTimer.CancelTimer(bucket, bucket.timer)
			bucket.timer = nil
		end

		AceBucket.buckets[handle] = nil
		-- store our bucket in the cache
		bucketCache[bucket] = true
	end
end

--- Unregister all buckets of the current addon object (or custom "self").
function AceBucket:UnregisterAllBuckets()
	-- hmm can we do this more efficient? (it is not done often so shouldn't matter much)
	for handle, bucket in pairs(AceBucket.buckets) do
		if bucket.object == self then
			AceBucket.UnregisterBucket(self, handle)
		end
	end
end

-- embedding and embed handling
local mixins = {
	"RegisterBucketEvent",
	"RegisterBucketMessage",
	"UnregisterBucket",
	"UnregisterAllBuckets",
}

-- Embeds AceBucket into the target object making the functions from the mixins list available on target:..
-- @param target target object to embed AceBucket in
function AceBucket:Embed( target )
	for _, v in pairs( mixins ) do
		target[v] = self[v]
	end
	self.embeds[target] = true
	return target
end

function AceBucket:OnEmbedDisable( target )
	target:UnregisterAllBuckets()
end

for addon in pairs(AceBucket.embeds) do
	AceBucket:Embed(addon)
end

================
File: Libs/vanilla/Ace3/AceBucket-3.0/AceBucket-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceBucket-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceComm-3.0/AceComm-3.0.lua
================
--- **AceComm-3.0** allows you to send messages of unlimited length over the addon comm channels.
-- It'll automatically split the messages into multiple parts and rebuild them on the receiving end.\\
-- **ChatThrottleLib** is of course being used to avoid being disconnected by the server.
--
-- **AceComm-3.0** can be embeded into your addon, either explicitly by calling AceComm:Embed(MyAddon) or by
-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
-- and can be accessed directly, without having to explicitly call AceComm itself.\\
-- It is recommended to embed AceComm, otherwise you'll have to specify a custom `self` on all calls you
-- make into AceComm.
-- @class file
-- @name AceComm-3.0
-- @release $Id: AceComm-3.0.lua 1107 2014-02-19 16:40:32Z nevcairiel $

--[[ AceComm-3.0

TODO: Time out old data rotting around from dead senders? Not a HUGE deal since the number of possible sender names is somewhat limited.

]]

local MAJOR, MINOR = "AceComm-3.0", 9

local AceComm,oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceComm then return end

local CallbackHandler = LibStub:GetLibrary("CallbackHandler-1.0")
local CTL = assert(ChatThrottleLib, "AceComm-3.0 requires ChatThrottleLib")

-- Lua APIs
local type, next, pairs, tostring = type, next, pairs, tostring
local strlen, strsub, strfind = string.len, string.sub, string.find
local tinsert, tconcat, tgetn, tremove = table.insert, table.concat, table.getn, table.remove
local error, assert = error, assert


-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: LibStub, DEFAULT_CHAT_FRAME, geterrorhandler, RegisterAddonMessagePrefix

AceComm.embeds = AceComm.embeds or {}

-- for my sanity and yours, let's give the message type bytes some names
local MSG_MULTI_FIRST = "\001"
local MSG_MULTI_NEXT  = "\002"
local MSG_MULTI_LAST  = "\003"
local MSG_ESCAPE = "\004"

-- remove old structures (pre WoW 4.0)
AceComm.multipart_origprefixes = nil
AceComm.multipart_reassemblers = nil

-- the multipart message spool: indexed by a combination of sender+distribution+
AceComm.multipart_spool = AceComm.multipart_spool or {}

--- Register for Addon Traffic on a specified prefix
-- @param prefix A printable character (\032-\255) classification of the message (typically AddonName or AddonNameEvent), max 16 characters
-- @param method Callback to call on message reception: Function reference, or method name (string) to call on self. Defaults to "OnCommReceived"
function AceComm:RegisterComm(prefix, method)
	if method == nil then
		method = "OnCommReceived"
	end

	if strlen(prefix) > 16 then -- TODO: 15?
		error("AceComm:RegisterComm(prefix,method): prefix length is limited to 16 characters")
	end

	return AceComm._RegisterComm(self, prefix, method)	-- created by CallbackHandler
end

local warnedPrefix=false

--- Send a message over the Addon Channel
-- @param prefix A printable character (\032-\255) classification of the message (typically AddonName or AddonNameEvent)
-- @param text Data to send, nils (\000) not allowed. Any length.
-- @param distribution Addon channel, e.g. "RAID", "GUILD", etc; see SendAddonMessage API
-- @param target Destination for some distributions; see SendAddonMessage API
-- @param prio OPTIONAL: ChatThrottleLib priority, "BULK", "NORMAL" or "ALERT". Defaults to "NORMAL".
-- @param callbackFn OPTIONAL: callback function to be called as each chunk is sent. receives 3 args: the user supplied arg (see next), the number of bytes sent so far, and the number of bytes total to send.
-- @param callbackArg: OPTIONAL: first arg to the callback function. nil will be passed if not specified.
function AceComm:SendCommMessage(prefix, text, distribution, target, prio, callbackFn, callbackArg)
	prio = prio or "NORMAL"	-- pasta's reference implementation had different prio for singlepart and multipart, but that's a very bad idea since that can easily lead to out-of-sequence delivery!
	if not( type(prefix)=="string" and
			type(text)=="string" and
			type(distribution)=="string" and
			(target==nil or type(target)=="string") and
			(prio=="BULK" or prio=="NORMAL" or prio=="ALERT")
		) then
		error('Usage: SendCommMessage(addon, "prefix", "text", "distribution"[, "target"[, "prio"[, callbackFn, callbackarg]]])', 2)
	end

	local textlen = strlen(text)
	-- Yes, the max is 255 even if the dev post said 256. I tested. Char 256+ get silently truncated. /Mikk, 20110327
	-- Ace3v: substract the prefix length
	local maxtextlen = 254 - strlen(prefix)
	local queueName = prefix..distribution..(target or "")

	local ctlCallback = nil
	if callbackFn then
		ctlCallback = function(sent)
			return callbackFn(callbackArg, sent, textlen)
		end
	end

	local forceMultipart
	if strfind(text, "^[\001-\009]") then -- 4.1+: see if the first character is a control character
		-- we need to escape the first character with a \004
		if textlen+1 > maxtextlen then	-- would we go over the size limit?
			forceMultipart = true	-- just make it multipart, no escape problems then
		else
			text = "\004" .. text
		end
	end

	if not forceMultipart and textlen <= maxtextlen then
		-- fits all in one message
		CTL:SendAddonMessage(prio, prefix, text, distribution, target, queueName, ctlCallback, textlen)
	else
		maxtextlen = maxtextlen - 1	-- 1 extra byte for part indicator in prefix(4.0)/start of message(4.1)

		-- first part
		local chunk = strsub(text, 1, maxtextlen)
		CTL:SendAddonMessage(prio, prefix, MSG_MULTI_FIRST..chunk, distribution, target, queueName, ctlCallback, maxtextlen)

		-- continuation
		local pos = 1+maxtextlen

		while pos+maxtextlen <= textlen do
			chunk = strsub(text, pos, pos+maxtextlen-1)
			CTL:SendAddonMessage(prio, prefix, MSG_MULTI_NEXT..chunk, distribution, target, queueName, ctlCallback, pos+maxtextlen-1)
			pos = pos + maxtextlen
		end

		-- final part
		chunk = strsub(text, pos)
		CTL:SendAddonMessage(prio, prefix, MSG_MULTI_LAST..chunk, distribution, target, queueName, ctlCallback, textlen)
	end
end


----------------------------------------
-- Message receiving
----------------------------------------

do
	local compost = setmetatable({}, {__mode = "k"})
	local function new()
		local t = next(compost)
		if t then
			compost[t]=nil
			for i=tgetn(t),3,-1 do	-- faster than pairs loop. don't even nil out 1/2 since they'll be overwritten
				tremove(t)	-- Ace3v: t[i] = nil wont affect the tgetn return value
			end
			return t
		end

		return {}
	end

	local function lostdatawarning(prefix,sender,where)
		DEFAULT_CHAT_FRAME:AddMessage(MAJOR..": Warning: lost network data regarding '"..tostring(prefix).."' from '"..tostring(sender).."' (in "..where..")")
	end

	function AceComm:OnReceiveMultipartFirst(prefix, message, distribution, sender)
		local key = prefix.."\t"..distribution.."\t"..sender	-- a unique stream is defined by the prefix + distribution + sender
		local spool = AceComm.multipart_spool

		--[[
		if spool[key] then
			lostdatawarning(prefix,sender,"First")
			-- continue and overwrite
		end
		--]]

		spool[key] = message  -- plain string for now
	end

	function AceComm:OnReceiveMultipartNext(prefix, message, distribution, sender)
		local key = prefix.."\t"..distribution.."\t"..sender	-- a unique stream is defined by the prefix + distribution + sender
		local spool = AceComm.multipart_spool
		local olddata = spool[key]

		if not olddata then
			--lostdatawarning(prefix,sender,"Next")
			return
		end

		if type(olddata)~="table" then
			-- ... but what we have is not a table. So make it one. (Pull a composted one if available)
			local t = new()
			t[1] = olddata    -- add old data as first string
			t[2] = message    -- and new message as second string
			spool[key] = t    -- and put the table in the spool instead of the old string
		else
			tinsert(olddata, message)
		end
	end

	function AceComm:OnReceiveMultipartLast(prefix, message, distribution, sender)
		local key = prefix.."\t"..distribution.."\t"..sender	-- a unique stream is defined by the prefix + distribution + sender
		local spool = AceComm.multipart_spool
		local olddata = spool[key]

		if not olddata then
			--lostdatawarning(prefix,sender,"End")
			return
		end

		spool[key] = nil

		if type(olddata) == "table" then
			-- if we've received a "next", the spooled data will be a table for rapid & garbage-free tconcat
			tinsert(olddata, message)
			AceComm.callbacks:Fire(prefix, 3, tconcat(olddata, ""), distribution, sender)
			compost[olddata] = true
		else
			-- if we've only received a "first", the spooled data will still only be a string
			AceComm.callbacks:Fire(prefix, 3, olddata..message, distribution, sender)
		end
	end
end






----------------------------------------
-- Embed CallbackHandler
----------------------------------------

if not AceComm.callbacks then
	AceComm.callbacks = CallbackHandler:New(AceComm,
						"_RegisterComm",
						"UnregisterComm",
						"UnregisterAllComm")
end

AceComm.callbacks.OnUsed = nil
AceComm.callbacks.OnUnused = nil

-- Ace3v: in vanilla, global vars:
--   event -> event type
--   arg1  -> prefix
--   arg2  -> message
--   arg3  -> channel
--   arg4  -> sender
local function OnEvent()
	local prefix, message, distribution, sender = arg1, arg2, arg3, arg4
	if event == "CHAT_MSG_ADDON" then
		local _, _, control, rest = strfind(message, "^([\001-\009])(.*)")
		if control then
			if control==MSG_MULTI_FIRST then
				AceComm:OnReceiveMultipartFirst(prefix, rest, distribution, sender)
			elseif control==MSG_MULTI_NEXT then
				AceComm:OnReceiveMultipartNext(prefix, rest, distribution, sender)
			elseif control==MSG_MULTI_LAST then
				AceComm:OnReceiveMultipartLast(prefix, rest, distribution, sender)
			elseif control==MSG_ESCAPE then
				AceComm.callbacks:Fire(prefix, 3, rest, distribution, sender)
			else
				-- unknown control character, ignore SILENTLY (dont warn unnecessarily about future extensions!)
			end
		else
			-- single part: fire it off immediately and let CallbackHandler decide if it's registered or not
			AceComm.callbacks:Fire(prefix, 3, message, distribution, sender)
		end
	else
		assert(false, "Received "..tostring(event).." event?!")
	end
end

AceComm.frame = AceComm.frame or CreateFrame("Frame", "AceComm30Frame")
AceComm.frame:SetScript("OnEvent", OnEvent)
AceComm.frame:UnregisterAllEvents()
AceComm.frame:RegisterEvent("CHAT_MSG_ADDON")


----------------------------------------
-- Base library stuff
----------------------------------------

local mixins = {
	"RegisterComm",
	"UnregisterComm",
	"UnregisterAllComm",
	"SendCommMessage",
}

-- Embeds AceComm-3.0 into the target object making the functions from the mixins list available on target:..
-- @param target target object to embed AceComm-3.0 in
function AceComm:Embed(target)
	for k, v in pairs(mixins) do
		target[v] = self[v]
	end
	self.embeds[target] = true
	return target
end

function AceComm:OnEmbedDisable(target)
	target:UnregisterAllComm()
end

-- Update embeds
for target, v in pairs(AceComm.embeds) do
	AceComm:Embed(target)
end

================
File: Libs/vanilla/Ace3/AceComm-3.0/AceComm-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="ChatThrottleLib.lua"/>
	<Script file="AceComm-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceComm-3.0/ChatThrottleLib.lua
================
--
-- ChatThrottleLib by Mikk
--
-- Manages AddOn chat output to keep player from getting kicked off.
--
-- ChatThrottleLib:SendChatMessage/:SendAddonMessage functions that accept 
-- a Priority ("BULK", "NORMAL", "ALERT") as well as prefix for SendChatMessage.
--
-- Priorities get an equal share of available bandwidth when fully loaded.
-- Communication channels are separated on extension+chattype+destination and
-- get round-robinned. (Destination only matters for whispers and channels,
-- obviously)
--
-- Will install hooks for SendChatMessage and SendAddonMessage to measure
-- bandwidth bypassing the library and use less bandwidth itself.
--
--
-- Fully embeddable library. Just copy this file into your addon directory,
-- add it to the .toc, and it's done.
--
-- Can run as a standalone addon also, but, really, just embed it! :-)
--
-- LICENSE: ChatThrottleLib is released into the Public Domain
--

local CTL_VERSION = 24

local AceCore = LibStub("AceCore-3.0")
local _G = AceCore._G
local hooksecurefunc = AceCore.hooksecurefunc
local wipe = AceCore.wipe

if _G.ChatThrottleLib then
	if _G.ChatThrottleLib.version >= CTL_VERSION then
		-- There's already a newer (or same) version loaded. Buh-bye.
		return
	elseif not _G.ChatThrottleLib.securelyHooked then
		print("ChatThrottleLib: Warning: There's an ANCIENT ChatThrottleLib.lua (pre-wow 2.0, <v16) in an addon somewhere. Get the addon updated or copy in a newer ChatThrottleLib.lua (>=v16) in it!")
		-- ATTEMPT to unhook; this'll behave badly if someone else has hooked...
		-- ... and if someone has securehooked, they can kiss that goodbye too... >.<
		_G.SendChatMessage = _G.ChatThrottleLib.ORIG_SendChatMessage
		if _G.ChatThrottleLib.ORIG_SendAddonMessage then
			_G.SendAddonMessage = _G.ChatThrottleLib.ORIG_SendAddonMessage
		end
	end
	_G.ChatThrottleLib.ORIG_SendChatMessage = nil
	_G.ChatThrottleLib.ORIG_SendAddonMessage = nil
end

if not _G.ChatThrottleLib then
	_G.ChatThrottleLib = {}
end

ChatThrottleLib = _G.ChatThrottleLib  -- in case some addon does "local ChatThrottleLib" above us and we're copypasted (AceComm-2, sigh)
local ChatThrottleLib = _G.ChatThrottleLib

ChatThrottleLib.version = CTL_VERSION



------------------ TWEAKABLES -----------------

ChatThrottleLib.MAX_CPS = 800			  -- 2000 seems to be safe if NOTHING ELSE is happening. let's call it 800.
ChatThrottleLib.MSG_OVERHEAD = 40		-- Guesstimate overhead for sending a message; source+dest+chattype+protocolstuff

ChatThrottleLib.BURST = 4000				-- WoW's server buffer seems to be about 32KB. 8KB should be safe, but seen disconnects on _some_ servers. Using 4KB now.

ChatThrottleLib.MIN_FPS = 20				-- Reduce output CPS to half (and don't burst) if FPS drops below this value


local setmetatable = setmetatable
local table_remove = table.remove
local tinsert = table.insert
local tostring = tostring
local GetTime = GetTime
local math_min = math.min
local math_max = math.max
local next = next
local strlen = string.len
local GetFramerate = GetFramerate
local strlower = string.lower
local unpack,type,pairs = unpack,type,pairs
local UnitInRaid,UnitInParty = UnitInRaid,UnitInParty


-----------------------------------------------------------------------
-- Double-linked ring implementation

local Ring = {}
local RingMeta = { __index = Ring }

function Ring:New()
	local ret = {}
	setmetatable(ret, RingMeta)
	return ret
end

function Ring:Add(obj)	-- Append at the "far end" of the ring (aka just before the current position)
	if self.pos then
		obj.prev = self.pos.prev
		obj.prev.next = obj
		obj.next = self.pos
		obj.next.prev = obj
	else
		obj.next = obj
		obj.prev = obj
		self.pos = obj
	end
end

function Ring:Remove(obj)
	obj.next.prev = obj.prev
	obj.prev.next = obj.next
	if self.pos == obj then
		self.pos = obj.next
		if self.pos == obj then
			self.pos = nil
		end
	end
end



-----------------------------------------------------------------------
-- Recycling bin for pipes 
-- A pipe is a plain integer-indexed queue of messages
-- Pipes normally live in Rings of pipes  (3 rings total, one per priority)

ChatThrottleLib.PipeBin = nil -- pre-v19, drastically different
local PipeBin = setmetatable({}, {__mode="k"})

local function DelPipe(pipe)
	PipeBin[pipe] = true
end

local function NewPipe()
	local pipe = next(PipeBin)
	if pipe then
		wipe(pipe)
		PipeBin[pipe] = nil
		return pipe
	end
	return {}
end




-----------------------------------------------------------------------
-- Recycling bin for messages

ChatThrottleLib.MsgBin = nil -- pre-v19, drastically different
local MsgBin = setmetatable({}, {__mode="k"})

local function DelMsg(msg)
	msg[1] = nil
	-- there's more parameters, but they're very repetetive so the string pool doesn't suffer really, and it's faster to just not delete them.
	MsgBin[msg] = true
end

local function NewMsg()
	local msg = next(MsgBin)
	if msg then
		MsgBin[msg] = nil
		return msg
	end
	return {}
end


-----------------------------------------------------------------------
-- ChatThrottleLib:Init
-- Initialize queues, set up frame for OnUpdate, etc


function ChatThrottleLib:Init()	

	-- Set up queues
	if not self.Prio then
		self.Prio = {}
		self.Prio["ALERT"] = { ByName = {}, Ring = Ring:New(), avail = 0 }
		self.Prio["NORMAL"] = { ByName = {}, Ring = Ring:New(), avail = 0 }
		self.Prio["BULK"] = { ByName = {}, Ring = Ring:New(), avail = 0 }
	end

	-- v4: total send counters per priority
	for _, Prio in pairs(self.Prio) do
		Prio.nTotalSent = Prio.nTotalSent or 0
	end

	if not self.avail then
		self.avail = 0 -- v5
	end
	if not self.nTotalSent then
		self.nTotalSent = 0 -- v5
	end


	-- Set up a frame to get OnUpdate events
	if not self.Frame then
		self.Frame = CreateFrame("Frame")
		self.Frame:Hide()
	end
	self.Frame:SetScript("OnUpdate", self.OnUpdate)
	self.Frame:SetScript("OnEvent", self.OnEvent)	-- v11: Monitor P_E_W so we can throttle hard for a few seconds
	self.Frame:RegisterEvent("PLAYER_ENTERING_WORLD")
	self.OnUpdateDelay = 0
	self.LastAvailUpdate = GetTime()
	self.HardThrottlingBeginTime = GetTime()	-- v11: Throttle hard for a few seconds after startup

	-- Hook SendChatMessage and SendAddonMessage so we can measure unpiped traffic and avoid overloads (v7)
	if not self.securelyHooked then
		-- Use secure hooks as of v16. Old regular hook support yanked out in v21.
		self.securelyHooked = true
		--SendChatMessage
		hooksecurefunc("SendChatMessage", function(text, chattype, language, destination)
			return ChatThrottleLib.Hook_SendChatMessage(text, chattype, language, destination)
		end)
		--SendAddonMessage
		hooksecurefunc("SendAddonMessage", function(prefix, text, chattype, destination)
			return ChatThrottleLib.Hook_SendAddonMessage(prefix, text, chattype, destination)
		end)
	end
	self.nBypass = 0
end


-----------------------------------------------------------------------
-- ChatThrottleLib.Hook_SendChatMessage / .Hook_SendAddonMessage

local bMyTraffic = false

function ChatThrottleLib.Hook_SendChatMessage(text, chattype, language, destination)
	if bMyTraffic then
		return
	end
	local self = ChatThrottleLib
	local size = strlen(tostring(text or "")) + strlen(tostring(destination or "")) + self.MSG_OVERHEAD
	self.avail = self.avail - size
	self.nBypass = self.nBypass + size	-- just a statistic
end
function ChatThrottleLib.Hook_SendAddonMessage(prefix, text, chattype, destination)
	if bMyTraffic then
		return
	end
	local self = ChatThrottleLib
	local size = strlen(tostring(text or "")) + strlen(tostring(prefix or ""));
	size = size + strlen(tostring(destination or "")) + self.MSG_OVERHEAD
	self.avail = self.avail - size
	self.nBypass = self.nBypass + size	-- just a statistic
end



-----------------------------------------------------------------------
-- ChatThrottleLib:UpdateAvail
-- Update self.avail with how much bandwidth is currently available

function ChatThrottleLib:UpdateAvail()
	local now = GetTime()
	local MAX_CPS = self.MAX_CPS;
	local newavail = MAX_CPS * (now - self.LastAvailUpdate)
	local avail = self.avail

	if now - self.HardThrottlingBeginTime < 5 then
		-- First 5 seconds after startup/zoning: VERY hard clamping to avoid irritating the server rate limiter, it seems very cranky then
		avail = math_min(avail + (newavail*0.1), MAX_CPS*0.5)
		self.bChoking = true
	elseif GetFramerate() < self.MIN_FPS then		-- GetFrameRate call takes ~0.002 secs
		avail = math_min(MAX_CPS, avail + newavail*0.5)
		self.bChoking = true		-- just a statistic
	else
		avail = math_min(self.BURST, avail + newavail)
		self.bChoking = false
	end

	avail = math_max(avail, 0-(MAX_CPS*2))	-- Can go negative when someone is eating bandwidth past the lib. but we refuse to stay silent for more than 2 seconds; if they can do it, we can.

	self.avail = avail
	self.LastAvailUpdate = now

	return avail
end


-----------------------------------------------------------------------
-- Despooling logic
-- Reminder:
-- - We have 3 Priorities, each containing a "Ring" construct ...
-- - ... made up of N "Pipe"s (1 for each destination/pipename)
-- - and each pipe contains messages

function ChatThrottleLib:Despool(Prio)
	local ring = Prio.Ring
	while ring.pos and Prio.avail > ring.pos[1].nSize do
		local msg = table_remove(ring.pos, 1)
		if not ring.pos[1] then  -- did we remove last msg in this pipe?
			local pipe = Prio.Ring.pos
			Prio.Ring:Remove(pipe)
			Prio.ByName[pipe.name] = nil
			DelPipe(pipe)
		else
			Prio.Ring.pos = Prio.Ring.pos.next
		end
		local didSend=false
		local lowerDest = strlower(msg[3] or "")
		if lowerDest == "raid" and not UnitInRaid("player") then
			-- do nothing
		elseif lowerDest == "party" and not UnitInParty("player") then
			-- do nothing
		else
			Prio.avail = Prio.avail - msg.nSize
			bMyTraffic = true
			msg.f(unpack(msg, 1, msg.n))
			bMyTraffic = false
			Prio.nTotalSent = Prio.nTotalSent + msg.nSize
			DelMsg(msg)
			didSend = true
		end
		-- notify caller of delivery (even if we didn't send it)
		if msg.callbackFn then
			msg.callbackFn (msg.callbackArg, didSend)
		end
		-- USER CALLBACK MAY ERROR
	end
end


function ChatThrottleLib.OnEvent()
	-- v11: We know that the rate limiter is touchy after login. Assume that it's touchy after zoning, too.
	local self = ChatThrottleLib
	if event == "PLAYER_ENTERING_WORLD" then
		self.HardThrottlingBeginTime = GetTime()	-- Throttle hard for a few seconds after zoning
		self.avail = 0
	end
end


function ChatThrottleLib.OnUpdate()
	local self = ChatThrottleLib

	self.OnUpdateDelay = self.OnUpdateDelay + arg1
	if self.OnUpdateDelay < 0.08 then
		return
	end
	self.OnUpdateDelay = 0

	self:UpdateAvail()

	if self.avail < 0  then
		return -- argh. some bastard is spewing stuff past the lib. just bail early to save cpu.
	end

	-- See how many of our priorities have queued messages (we only have 3, don't worry about the loop)
	local n = 0
	for prioname,Prio in pairs(self.Prio) do
		if Prio.Ring.pos or Prio.avail < 0 then 
			n = n + 1 
		end
	end

	-- Anything queued still?
	if n<1 then
		-- Nope. Move spillover bandwidth to global availability gauge and clear self.bQueueing
		for prioname, Prio in pairs(self.Prio) do
			self.avail = self.avail + Prio.avail
			Prio.avail = 0
		end
		self.bQueueing = false
		self.Frame:Hide()
		return
	end

	-- There's stuff queued. Hand out available bandwidth to priorities as needed and despool their queues
	local avail = self.avail/n
	self.avail = 0

	for prioname, Prio in pairs(self.Prio) do
		if Prio.Ring.pos or Prio.avail < 0 then
			Prio.avail = Prio.avail + avail
			if Prio.Ring.pos and Prio.avail > Prio.Ring.pos[1].nSize then
				self:Despool(Prio)
				-- Note: We might not get here if the user-supplied callback function errors out! Take care!
			end
		end
	end

end




-----------------------------------------------------------------------
-- Spooling logic

function ChatThrottleLib:Enqueue(prioname, pipename, msg)
	local Prio = self.Prio[prioname]
	local pipe = Prio.ByName[pipename]
	if not pipe then
		self.Frame:Show()
		pipe = NewPipe()
		pipe.name = pipename
		Prio.ByName[pipename] = pipe
		Prio.Ring:Add(pipe)
	end

	tinsert(pipe,msg)

	self.bQueueing = true
end

function ChatThrottleLib:SendChatMessage(prio, prefix,   text, chattype, language, destination, queueName, callbackFn, callbackArg)
	if not self or not prio or not prefix or not text or not self.Prio[prio] then
		error('Usage: ChatThrottleLib:SendChatMessage("{BULK||NORMAL||ALERT}", "prefix", "text"[, "chattype"[, "language"[, "destination"]]]', 2)
	end
	if callbackFn and type(callbackFn)~="function" then
		error('ChatThrottleLib:ChatMessage(): callbackFn: expected function, got '..type(callbackFn), 2)
	end

	local nSize = strlen(text)

--[[   -- Vanilla dont have limit?

	if nSize>255 then
		error("ChatThrottleLib:SendChatMessage(): message length cannot exceed 255 bytes", 2)
	end
]]
	nSize = nSize + self.MSG_OVERHEAD

	-- Check if there's room in the global available bandwidth gauge to send directly
	if not self.bQueueing and nSize < self:UpdateAvail() then
		self.avail = self.avail - nSize
		bMyTraffic = true
		_G.SendChatMessage(text, chattype, language, destination)
		bMyTraffic = false
		self.Prio[prio].nTotalSent = self.Prio[prio].nTotalSent + nSize
		if callbackFn then
			callbackFn (callbackArg, true)
		end
		-- USER CALLBACK MAY ERROR
		return
	end

	-- Message needs to be queued
	local msg = NewMsg()
	msg.f = _G.SendChatMessage
	msg[1] = text
	msg[2] = chattype or "SAY"
	msg[3] = language
	msg[4] = destination
	msg.n = 4
	msg.nSize = nSize
	msg.callbackFn = callbackFn
	msg.callbackArg = callbackArg

	self:Enqueue(prio, queueName or (prefix..(chattype or "SAY")..(destination or "")), msg)
end


function ChatThrottleLib:SendAddonMessage(prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
	if not self or not prio or not prefix or not text or not chattype or not self.Prio[prio] then
		error('Usage: ChatThrottleLib:SendAddonMessage("{BULK||NORMAL||ALERT}", "prefix", "text", "chattype"[, "target"])', 2)
	end
	if callbackFn and type(callbackFn)~="function" then
		error('ChatThrottleLib:SendAddonMessage(): callbackFn: expected function, got '..type(callbackFn), 2)
	end

	local nSize = strlen(text);

	if RegisterAddonMessagePrefix then
		--[[   -- Vanilla dont have limit?
		if nSize>255 then
			error("ChatThrottleLib:SendAddonMessage(): message length cannot exceed 255 bytes", 2)
		end
		]]
	else
		nSize = nSize + strlen(prefix) + 1
		--[[   -- Vanilla dont have limit?
		if nSize>255 then
			error("ChatThrottleLib:SendAddonMessage(): prefix + message length cannot exceed 254 bytes", 2)
		end
		]]
	end

	nSize = nSize + self.MSG_OVERHEAD;

	-- Check if there's room in the global available bandwidth gauge to send directly
	if not self.bQueueing and nSize < self:UpdateAvail() then
		self.avail = self.avail - nSize
		bMyTraffic = true
		_G.SendAddonMessage(prefix, text, chattype, target)
		bMyTraffic = false
		self.Prio[prio].nTotalSent = self.Prio[prio].nTotalSent + nSize
		if callbackFn then
			callbackFn (callbackArg, true)
		end
		-- USER CALLBACK MAY ERROR
		return
	end

	-- Message needs to be queued
	local msg = NewMsg()
	msg.f = _G.SendAddonMessage
	msg[1] = prefix
	msg[2] = text
	msg[3] = chattype
	msg[4] = target
	msg.n = (target~=nil) and 4 or 3;
	msg.nSize = nSize
	msg.callbackFn = callbackFn
	msg.callbackArg = callbackArg

	self:Enqueue(prio, queueName or (prefix..chattype..(target or "")), msg)
end




-----------------------------------------------------------------------
-- Get the ball rolling!

ChatThrottleLib:Init()

--[[ WoWBench debugging snippet
if(WOWB_VER) then
	local function SayTimer()
		print("SAY: "..GetTime().." "..arg1)
	end
	ChatThrottleLib.Frame:SetScript("OnEvent", SayTimer)
	ChatThrottleLib.Frame:RegisterEvent("CHAT_MSG_SAY")
end
]]

================
File: Libs/vanilla/Ace3/AceConfig-3.0/AceConfig-3.0.lua
================
--- AceConfig-3.0 wrapper library.
-- Provides an API to register an options table with the config registry,
-- as well as associate it with a slash command.
-- @class file
-- @name AceConfig-3.0
-- @release $Id: AceConfig-3.0.lua 969 2010-10-07 02:11:48Z shefki $

--[[
AceConfig-3.0

Very light wrapper library that combines all the AceConfig subcomponents into one more easily used whole.

]]

local MAJOR, MINOR = "AceConfig-3.0", 2
local AceConfig = LibStub:NewLibrary(MAJOR, MINOR)

if not AceConfig then return end

AceConfig.embeds = AceConfig.embeds or {}

local cfgreg = LibStub("AceConfigRegistry-3.0")
local cfgcmd = LibStub("AceConfigCmd-3.0")
--TODO: local cfgdlg = LibStub("AceConfigDialog-3.0", true)
--TODO: local cfgdrp = LibStub("AceConfigDropdown-3.0", true)

-- Lua APIs
local pcall, error, type, pairs = pcall, error, type, pairs

-- -------------------------------------------------------------------
-- :RegisterOptionsTable(appName, options, slashcmd, persist)
--
-- - appName - (string) application name
-- - options - table or function ref, see AceConfigRegistry
-- - slashcmd - slash command (string) or table with commands, or nil to NOT create a slash command

--- Register a option table with the AceConfig registry.
-- You can supply a slash command (or a table of slash commands) to register with AceConfigCmd directly.
-- @paramsig appName, options [, slashcmd]
-- @param appName The application name for the config table.
-- @param options The option table (or a function to generate one on demand).  http://www.wowace.com/addons/ace3/pages/ace-config-3-0-options-tables/
-- @param slashcmd A slash command to register for the option table, or a table of slash commands.
-- @usage
-- local AceConfig = LibStub("AceConfig-3.0")
-- AceConfig:RegisterOptionsTable("MyAddon", myOptions, {"/myslash", "/my"})
function AceConfig:RegisterOptionsTable(appName, options, slashcmd)
	if self == AceConfig then
		error([[Usage: RegisterOptionsTable(appName, options[, slashcmd]): 'self' - use your own 'self']], 2)
	end
	local ok,msg = pcall(cfgreg.RegisterOptionsTable, self, appName, options)
	if not ok then error(msg, 2) end
	
	if slashcmd then
		if type(slashcmd) == "table" then
			for _,cmd in pairs(slashcmd) do
				cfgcmd.CreateChatCommand(self, cmd, appName)
			end
		else
			cfgcmd.CreateChatCommand(self, slashcmd, appName)
		end
	end
end

function AceConfig:Embed(target)
	target["RegisterOptionsTable"] = self["RegisterOptionsTable"]
end

for addon in pairs(AceConfig.embeds) do
	AceConfig:Embed(addon)
end

================
File: Libs/vanilla/Ace3/AceConfig-3.0/AceConfig-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Include file="AceConfigRegistry-3.0\AceConfigRegistry-3.0.xml"/>
	<Include file="AceConfigCmd-3.0\AceConfigCmd-3.0.xml"/>
	<Include file="AceConfigDialog-3.0\AceConfigDialog-3.0.xml"/>
	<!--<Include file="AceConfigDropdown-3.0\AceConfigDropdown-3.0.xml"/>-->
	<Script file="AceConfig-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.lua
================
--- AceConfigCmd-3.0 handles access to an options table through the "command line" interface via the ChatFrames.
-- @class file
-- @name AceConfigCmd-3.0
-- @release $Id: AceConfigCmd-3.0.lua 1045 2011-12-09 17:58:40Z nevcairiel $

--[[
AceConfigCmd-3.0

Handles commandline optionstable access

REQUIRES: AceConsole-3.0 for command registration (loaded on demand)

]]

-- TODO: plugin args


local MAJOR, MINOR = "AceConfigCmd-3.0", 13
local AceConfigCmd = LibStub:NewLibrary(MAJOR, MINOR)

if not AceConfigCmd then return end

local AceCore = LibStub("AceCore-3.0")
local Dispatchers = AceCore.Dispatchers
local strtrim = AceCore.strtrim
local strsplit = AceCore.strsplit
local new, del = AceCore.new, AceCore.del
local wipe = AceCore.wipe

AceConfigCmd.commands = AceConfigCmd.commands or {}
AceConfigCmd.embeds = AceConfigCmd.embeds or {}
local commands = AceConfigCmd.commands

local cfgreg = LibStub("AceConfigRegistry-3.0")
local AceConsole -- LoD
local AceConsoleName = "AceConsole-3.0"

-- Lua APIs
local strbyte, strsub = string.byte, string.sub
local strlen, strupper, strlower = string.len, string.upper, string.lower
local strfind, strgfind, strgsub = string.find, string.gfind, string.gsub

local format = string.format
local tsort, tinsert, tgetn, tremove = table.sort, table.insert, table.getn, table.remove

-- WoW APIs
local _G = AceCore._G

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: LibStub, SELECTED_CHAT_FRAME, DEFAULT_CHAT_FRAME


local L = setmetatable({}, {	-- TODO: replace with proper locale
	__index = function(self,k) return k end
})



local function print(msg)
	(SELECTED_CHAT_FRAME or DEFAULT_CHAT_FRAME):AddMessage(msg)
end

-- constants used by getparam() calls below

local handlertypes = {["table"]=true}
local handlermsg = "expected a table"

local functypes = {["function"]=true, ["string"]=true}
local funcmsg = "expected function or member name"

local pickfirstset = AceCore.pickfirstset

-- err() - produce real error() regarding malformed options tables etc

local function err(info,inputpos,msg )
	local cmdstr=" "..strsub(info.input, 1, inputpos-1)
	error(MAJOR..": /" ..info[0] ..cmdstr ..": "..(msg or "malformed options table"), 2)
end


-- usererr() - produce chatframe message regarding bad slash syntax etc

local function usererr(info,inputpos,msg )
	local cmdstr=strsub(info.input, 1, inputpos-1);
	print("/" ..info[0] .. " "..cmdstr ..": "..(msg or "malformed options table"))
end


-- callmethod() - call a given named method (e.g. "get", "set") with given arguments



local function callmethod(info, inputpos, tab, methodtype, argc, a1, a2, a3, a4)
	local method = info[methodtype]
	if not method then
		err(info, inputpos, "'"..methodtype.."': not set")
	end

	argc = argc or 0
	info.arg = tab.arg
	info.option = tab
	info.type = tab.type

	if type(method)=="function" then
		return Dispatchers[argc+1](method, info, a1, a2, a3, a4)
	elseif type(method)=="string" then
		if type(info.handler[method])~="function" then
			err(info, inputpos, "'"..methodtype.."': '"..method.."' is not a member function of "..tostring(info.handler))
		end
		return Dispatchers[argc+2](info.handler[method], info.handler, info, a1, a2, a3, a4)
	else
		assert(false)	-- type should have already been checked on read
	end
end

-- callfunction() - call a given named function (e.g. "name", "desc") with given arguments

-- Ace3v: the variable arguments are currently unused, so we removed it
local function callfunction(info, tab, methodtype)
	local method = tab[methodtype]

	info.arg = tab.arg
	info.option = tab
	info.type = tab.type

	if type(method)=="function" then
		return method(info)
	else
		assert(false) -- type should have already been checked on read
	end
end

-- do_final() - do the final step (set/execute) along with validation and confirmation
-- Ace3v: experimental
-- @param argc	number of variable arguments
local function do_final(info, inputpos, tab, methodtype, argc, a1, a2, a3, a4)	-- currently maximum 4 arguments
	if info.validate then
		local res = callmethod(info,inputpos,tab,"validate",argc,a1,a2,a3,a4)
		if type(res)=="string" then
			usererr(info, inputpos, "'"..strsub(info.input, inputpos).."' - "..res)
			return
		end
	end
	-- console ignores .confirm

	callmethod(info,inputpos,tab,methodtype,argc,a1,a2,a3,a4)
end


-- getparam() - used by handle() to retreive and store "handler", "get", "set", etc

local function getparam(info, inputpos, tab, depth, paramname, types, errormsg)
	local old,oldat = info[paramname], info[paramname.."_at"]
	local val=tab[paramname]
	if val~=nil then
		if val==false then
			val=nil
		elseif not types[type(val)] then
			err(info, inputpos, "'" .. paramname.. "' - "..errormsg)
		end
		info[paramname] = val
		info[paramname.."_at"] = depth
	end
	return old,oldat
end


-- iterateargs(tab) - custom iterator that iterates both t.args and t.plugins.*
local function iterateargs(tab)
	if not tab.plugins then
		return pairs(tab.args)
	end

	local argtabkey,argtab=next(tab.plugins)
	local v

	return function(_, k)
		while argtab do
			k,v = next(argtab, k)
			if k then return k,v end
			if argtab==tab.args then
				argtab=nil
			else
				argtabkey,argtab = next(tab.plugins, argtabkey)
				if not argtabkey then
					argtab=tab.args
				end
			end
		end
	end
end

local function getValueFromTab(info, inputpos, tab, key)
	local v = tab[key]
	if type(v) == "function" or type(v) == "string" then
		info[key] = v
		v = callmethod(info, inputpos, tab, key)
		info[key] = nil
	end
	return v
end

local function checkhidden(info, inputpos, tab)
	if tab.cmdHidden~=nil then
		return tab.cmdHidden
	end
	return getValueFromTab(info, inputpos, tab, "hidden")
end

local function showhelp(info, inputpos, tab, depth, noHead)
	if not noHead then
		print("|cff33ff99"..info.appName.."|r: Arguments to |cffffff78/"..info[0].."|r "..strsub(info.input,1,inputpos-1)..":")
	end

	local sortTbl = new()	-- [1..n]=name
	local refTbl = new()	-- [name]=tableref

	for k,v in iterateargs(tab) do
		if not refTbl[k] then	-- a plugin overriding something in .args
			tinsert(sortTbl, k)
			refTbl[k] = v
		end
	end

	tsort(sortTbl, function(one, two)
		local o1 = refTbl[one].order or 100
		local o2 = refTbl[two].order or 100
		if type(o1) == "function" or type(o1) == "string" then
			info.order = o1
			tinsert(info, one)
			o1 = callmethod(info, inputpos, refTbl[one], "order")
			tremove(info)
			info.order = nil
		end
		if type(o2) == "function" or type(o1) == "string" then
			info.order = o2
			tinsert(info, two)
			o2 = callmethod(info, inputpos, refTbl[two], "order")
			tremove(info)
			info.order = nil
		end
		if o1<0 and o2<0 then return o1<o2 end
		if o2<0 then return true end
		if o1<0 then return false end
		if o1==o2 then return tostring(one)<tostring(two) end   -- compare names
		return o1<o2
	end)

	for i = 1, tgetn(sortTbl) do
		local k = sortTbl[i]
		local v = refTbl[k]
		if not checkhidden(info, inputpos, v) then
			if v.type ~= "description" and v.type ~= "header" then
				-- recursively show all inline groups
				local name, desc = v.name, v.desc
				if type(name) == "function" then
					name = callfunction(info, v, 'name')
				end
				if type(desc) == "function" then
					desc = callfunction(info, v, 'desc')
				end
				if v.type == "group" and pickfirstset(3, v.cmdInline, v.inline, false) then
					print("  "..(desc or name)..":")
					local oldhandler,oldhandler_at = getparam(info, inputpos, v, depth, "handler", handlertypes, handlermsg)
					showhelp(info, inputpos, v, depth, true)
					info.handler,info.handler_at = oldhandler,oldhandler_at
				else
					local key = strgsub(k, " ", "_")
					print("  |cffffff78"..key.."|r - "..(desc or name or ""))
				end
			end
		end
	end
	del(sortTbl)	-- Ace3v: release the tables
	del(refTbl)
end

local function keybindingValidateFunc(text)
	if text == nil or text == "NONE" then
		return nil
	end
	text = strupper(text)
	local shift, ctrl, alt
	local modifier
	while true do
		if text == "-" then
			break
		end
		modifier, text = strsplit('-', text, 2)
		if text then
			if modifier ~= "SHIFT" and modifier ~= "CTRL" and modifier ~= "ALT" then
				return false
			end
			if modifier == "SHIFT" then
				if shift then
					return false
				end
				shift = true
			end
			if modifier == "CTRL" then
				if ctrl then
					return false
				end
				ctrl = true
			end
			if modifier == "ALT" then
				if alt then
					return false
				end
				alt = true
			end
		else
			text = modifier
			break
		end
	end
	if text == "" then
		return false
	end
	if not strfind(text,"^F%d+$") and text ~= "CAPSLOCK" and strlen(text) ~= 1 and (strbyte(text) < 128 or strlen(text) > 4) and not _G["KEY_" .. text] then
		return false
	end
	local s = text
	if shift then
		s = "SHIFT-" .. s
	end
	if ctrl then
		s = "CTRL-" .. s
	end
	if alt then
		s = "ALT-" .. s
	end
	return s
end

-- handle() - selfrecursing function that processes input->optiontable
-- - depth - starts at 0
-- - retfalse - return false rather than produce error if a match is not found (used by inlined groups)

local function handle(info, inputpos, tab, depth, retfalse)

	if not(type(tab)=="table" and type(tab.type)=="string") then err(info,inputpos) end

	-------------------------------------------------------------------
	-- Grab hold of handler,set,get,func,etc if set (and remember old ones)
	-- Note that we do NOT validate if method names are correct at this stage,
	-- the handler may change before they're actually used!

	local oldhandler,oldhandler_at = getparam(info,inputpos,tab,depth,"handler",handlertypes,handlermsg)
	local oldset,oldset_at = getparam(info,inputpos,tab,depth,"set",functypes,funcmsg)
	local oldget,oldget_at = getparam(info,inputpos,tab,depth,"get",functypes,funcmsg)
	local oldfunc,oldfunc_at = getparam(info,inputpos,tab,depth,"func",functypes,funcmsg)
	local oldvalidate,oldvalidate_at = getparam(info,inputpos,tab,depth,"validate",functypes,funcmsg)
	--local oldconfirm,oldconfirm_at = getparam(info,inputpos,tab,depth,"confirm",functypes,funcmsg)

	-------------------------------------------------------------------
	-- Act according to .type of this table

	if tab.type=="group" then
		------------ group --------------------------------------------

		if type(tab.args)~="table" then err(info, inputpos) end
		if tab.plugins and type(tab.plugins)~="table" then err(info,inputpos) end

		-- grab next arg from input
		local _,nextpos,arg = strfind(info.input, " *([^ ]+) *", inputpos)
		if not arg then
			showhelp(info, inputpos, tab, depth)
			return
		end
		nextpos=nextpos+1

		-- loop .args and try to find a key with a matching name
		for k,v in iterateargs(tab) do
			if not(type(k)=="string" and type(v)=="table" and type(v.type)=="string") then err(info,inputpos, "options table child '"..tostring(k).."' is malformed") end

			-- is this child an inline group? if so, traverse into it
			if v.type=="group" and pickfirstset(3, v.cmdInline, v.inline, false) then
				tinsert(info,k)
				if handle(info, inputpos, v, depth+1, true)==false then
					tremove(info)
					-- wasn't found in there, but that's ok, we just keep looking down here
				else
					return	-- done, name was found in inline group
				end
			-- matching name and not a inline group
			elseif strlower(arg)==strlower(strgsub(k, " ", "_")) then
				tinsert(info,k)
				return handle(info,nextpos,v,depth+1)
			end
		end

		-- no match
		if retfalse then
			-- restore old infotable members and return false to indicate failure
			info.handler,info.handler_at = oldhandler,oldhandler_at
			info.set,info.set_at = oldset,oldset_at
			info.get,info.get_at = oldget,oldget_at
			info.func,info.func_at = oldfunc,oldfunc_at
			info.validate,info.validate_at = oldvalidate,oldvalidate_at
			--info.confirm,info.confirm_at = oldconfirm,oldconfirm_at
			return false
		end

		-- couldn't find the command, display error
		usererr(info, inputpos, "'"..arg.."' - " .. L["unknown argument"])
		return
	end

	local str = strsub(info.input,inputpos);

	if tab.type=="execute" then
		------------ execute --------------------------------------------
		do_final(info, inputpos, tab, "func")



	elseif tab.type=="input" then
		------------ input --------------------------------------------

		if str=="" and tab.nullable == false then
			usererr(info, inputpos, "'"..str.."' - " .. L["invalid input"])
			return
		end

		local res = true
		if tab.pattern then
			if not(type(tab.pattern)=="string") then err(info, inputpos, "'pattern' - expected a string") end
			if not strfind(str, tab.pattern) then
				usererr(info, inputpos, "'"..str.."' - " .. L["invalid input"])
				return
			end
		end

		do_final(info, inputpos, tab, "set", 1, str)



	elseif tab.type=="toggle" then
		------------ toggle --------------------------------------------
		local b
		local str = strtrim(strlower(str))
		if str=="" then
			b = callmethod(info, inputpos, tab, "get")

			if tab.tristate then
				--cycle in true, nil, false order
				if b then
					b = nil
				elseif b == nil then
					b = false
				else
					b = true
				end
			else
				b = not b
			end

		elseif str==L["on"] then
			b = true
		elseif str==L["off"] then
			b = false
		elseif tab.tristate and str==L["default"] then
			b = nil
		else
			if tab.tristate then
				usererr(info, inputpos, format(L["'%s' - expected 'on', 'off' or 'default', or no argument to toggle."], str))
			else
				usererr(info, inputpos, format(L["'%s' - expected 'on' or 'off', or no argument to toggle."], str))
			end
			return
		end

		do_final(info, inputpos, tab, "set", 1, b)


	elseif tab.type=="range" then
		------------ range --------------------------------------------
		local str = strtrim(strlower(str))
		if str == "" then
			-- TODO: Show current value
			return
		end

		local val = tonumber(str)
		if not val then
			usererr(info, inputpos, "'"..str.."' - "..L["expected number"])
			return
		end

		local step = getValueFromTab(info, inputpos, tab, "step")
		local min = getValueFromTab(info, inputpos, tab, "min")

		if type(step)=="number" then
			val = min + math.floor((val-min)/step) * step
		end

		if type(min)=="number" and val<min then
			usererr(info, inputpos, val.." - "..format(L["must be equal to or higher than %s"], tostring(min)) )
			return
		end

		local max = getValueFromTab(info, inputpos, tab, "max")
		if type(max)=="number" and val>max then
			usererr(info, inputpos, val.." - "..format(L["must be equal to or lower than %s"], tostring(max)) )
			return
		end

		do_final(info, inputpos, tab, "set", 1, val)


	elseif tab.type=="select" then
		------------ select ------------------------------------
		local str = strtrim(strlower(str))

		local values = getValueFromTab(info, inputpos, tab, "values")

		if str == "" then
			-- Ace3v: it is possbile to not have a current value
			--        we do this only for select but not for multiselect
			local b = tab.get
			if type(b) == "function" or type(b) == "string" then
				b = callmethod(info, inputpos, tab, "get")
			else
				b = nil
			end

			local fmt = "|cffffff78- [%s]|r %s"
			local fmt_sel = "|cffffff78- [%s]|r %s |cffff0000*|r"
			print(L["Options for |cffffff78"..info[tgetn(info)].."|r:"])
			for k, v in pairs(values) do
				if b == k then
					print(format(fmt_sel, k, v))
				else
					print(format(fmt, k, v))
				end
			end
			if tab.valuesTableDestroyable then del(values) end
			return
		end

		local ok
		for k,v in pairs(values) do
			if strlower(k)==str then
				str = k	-- overwrite with key (in case of case mismatches)
				ok = true
				break
			end
		end
		if tab.valuesTableDestroyable then del(values) end
		if not ok then
			usererr(info, inputpos, "'"..str.."' - "..L["unknown selection"])
			return
		end

		do_final(info, inputpos, tab, "set", 1, str)

	elseif tab.type=="multiselect" then
		------------ multiselect -------------------------------------------
		local str = strtrim(strlower(str))

		local values = getValueFromTab(info, inputpos, tab, "values")

		if str == "" then
			local fmt = "|cffffff78- [%s]|r %s"
			local fmt_sel = "|cffffff78- [%s]|r %s |cffff0000*|r"
			print(L["Options for |cffffff78"..info[tgetn(info)].."|r (multiple possible):"])
			for k, v in pairs(values) do
				if callmethod(info, inputpos, tab, "get", 1, k) then
					print(format(fmt_sel, k, v))
				else
					print(format(fmt, k, v))
				end
			end
			if tab.valuesTableDestroyable then del(values) end
			return
		end

		--build a table of the selections, checking that they exist
		--parse for =on =off =default in the process
		--table will be key = true for options that should toggle, key = [on|off|default] for options to be set
		local sels = new()
		for v in strgfind(str, "[^ ]+") do
			--parse option=on etc
			local _, _, opt, val = strfind(v, '(.+)=(.+)')
			--get option if toggling
			if not opt then
				opt = v
			end

			--check that the opt is valid
			local ok
			for k,v in pairs(values) do
				if strlower(k)==opt then
					opt = k	-- overwrite with key (in case of case mismatches)
					ok = true
					break
				end
			end
			if tab.valuesTableDestroyable then del(values) end

			if not ok then
				usererr(info, inputpos, "'"..opt.."' - "..L["unknown selection"])
				return
			end

			--check that if val was supplied it is valid
			if val then
				if val == L["on"] or val == L["off"] or (tab.tristate and val == L["default"]) then
					--val is valid insert it
					sels[opt] = val
				else
					if tab.tristate then
						usererr(info, inputpos, format(L["'%s' '%s' - expected 'on', 'off' or 'default', or no argument to toggle."], v, val))
					else
						usererr(info, inputpos, format(L["'%s' '%s' - expected 'on' or 'off', or no argument to toggle."], v, val))
					end
					del(sels)
					return
				end
			else
				-- no val supplied, toggle
				sels[opt] = true
			end
		end

		for opt, val in pairs(sels) do
			local newval

			if (val == true) then
				--toggle the option
				local b = callmethod(info, inputpos, tab, "get", 1, opt)

				if tab.tristate then
					--cycle in true, nil, false order
					if b then
						b = nil
					elseif b == nil then
						b = false
					else
						b = true
					end
				else
					b = not b
				end
				newval = b
			else
				--set the option as specified
				if val==L["on"] then
					newval = true
				elseif val==L["off"] then
					newval = false
				elseif val==L["default"] then
					newval = nil
				end
			end

			do_final(info, inputpos, tab, "set", 2, opt, newval)
		end
		del(sels)


	elseif tab.type=="color" then
		------------ color --------------------------------------------
		local str = strtrim(strlower(str))
		if str == "" then
			--TODO: Show current value
			return
		end

		local _, r, g, b, a

		local hasAlpha = getValueFromTab(info, inputpos, tab, 'hasAlpha')

		if hasAlpha then
			if strlen(str) == 8 and strfind(str, "^%x*$")  then
				--parse a hex string
				r,g,b,a = tonumber(strsub(str, 1, 2), 16) / 255, tonumber(strsub(str, 3, 4), 16) / 255, tonumber(strsub(str, 5, 6), 16) / 255, tonumber(strsub(str, 7, 8), 16) / 255
			else
				--parse seperate values
				_,_,r,g,b,a = strfind(str, "^([%d%.]+) ([%d%.]+) ([%d%.]+) ([%d%.]+)$")
				r,g,b,a = tonumber(r), tonumber(g), tonumber(b), tonumber(a)
			end
			if not (r and g and b and a) then
				usererr(info, inputpos, format(L["'%s' - expected 'RRGGBBAA' or 'r g b a'."], str))
				return
			end

			if r >= 0.0 and r <= 1.0 and g >= 0.0 and g <= 1.0 and b >= 0.0 and b <= 1.0 and a >= 0.0 and a <= 1.0 then
				--values are valid
			elseif r >= 0 and r <= 255 and g >= 0 and g <= 255 and b >= 0 and b <= 255 and a >= 0 and a <= 255 then
				--values are valid 0..255, convert to 0..1
				r = r / 255
				g = g / 255
				b = b / 255
				a = a / 255
			else
				--values are invalid
				usererr(info, inputpos, format(L["'%s' - values must all be either in the range 0..1 or 0..255."], str))
			end
		else
			a = 1.0
			if strlen(str) == 6 and strfind(str, "^%x*$") then
				--parse a hex string
				r,g,b = tonumber(strsub(str, 1, 2), 16) / 255, tonumber(strsub(str, 3, 4), 16) / 255, tonumber(strsub(str, 5, 6), 16) / 255
			else
				--parse seperate values
				_,_,r,g,b = strfind(str, "^([%d%.]+) ([%d%.]+) ([%d%.]+)$")
				r,g,b = tonumber(r), tonumber(g), tonumber(b)
			end
			if not (r and g and b) then
				usererr(info, inputpos, format(L["'%s' - expected 'RRGGBB' or 'r g b'."], str))
				return
			end
			if r >= 0.0 and r <= 1.0 and g >= 0.0 and g <= 1.0 and b >= 0.0 and b <= 1.0 then
				--values are valid
			elseif r >= 0 and r <= 255 and g >= 0 and g <= 255 and b >= 0 and b <= 255 then
				--values are valid 0..255, convert to 0..1
				r = r / 255
				g = g / 255
				b = b / 255
			else
				--values are invalid
				usererr(info, inputpos, format(L["'%s' - values must all be either in the range 0-1 or 0-255."], str))
			end
		end

		do_final(info, inputpos, tab, "set", 4, r,g,b,a)

	elseif tab.type=="keybinding" then
		------------ keybinding --------------------------------------------
		local str = strtrim(strlower(str))
		if str == "" then
			--TODO: Show current value
			return
		end
		local value = keybindingValidateFunc(strupper(str))
		if value == false then
			usererr(info, inputpos, format(L["'%s' - Invalid Keybinding."], str))
			return
		end

		do_final(info, inputpos, tab, "set", 1, value)

	elseif tab.type=="description" then
		------------ description --------------------
		-- ignore description, GUI config only
	else
		err(info, inputpos, "unknown options table item type '"..tostring(tab.type).."'")
	end
end

--- Handle the chat command.
-- This is usually called from a chat command handler to parse the command input as operations on an aceoptions table.\\
-- AceConfigCmd uses this function internally when a slash command is registered with `:CreateChatCommand`
-- @param slashcmd The slash command WITHOUT leading slash (only used for error output)
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param input The commandline input (as given by the WoW handler, i.e. without the command itself)
-- @usage
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceConsole-3.0")
-- -- Use AceConsole-3.0 to register a Chat Command
-- MyAddon:RegisterChatCommand("mychat", "ChatCommand")
--
-- -- Show the GUI if no input is supplied, otherwise handle the chat input.
-- function MyAddon:ChatCommand(input)
--   -- Assuming "MyOptions" is the appName of a valid options table
--   if not input or input:trim() == "" then
--     LibStub("AceConfigDialog-3.0"):Open("MyOptions")
--   else
--     LibStub("AceConfigCmd-3.0").HandleCommand(MyAddon, "mychat", "MyOptions", input)
--   end
-- end
-- Ace3v: experimental, user should copy info table if he wanna reuse it outside
--        then handler
local info_ = {}
function AceConfigCmd:HandleCommand(slashcmd, appName, input)

	local optgetter = cfgreg:GetOptionsTable(appName)
	if not optgetter then
		error([[Usage: HandleCommand("slashcmd", "appName", "input"): 'appName' - no options table "]]..tostring(appName)..[[" has been registered]], 2)
	end
	local options = assert( optgetter("cmd", MAJOR) )

	-- Ace3v: prevent user from using AceConfigCmd as self
	if self == AceConfigCmd then
		error([[Usage: HandleCommand("slashcmd", "appName", "input"): 'self' - use your own 'self']], 2)
	end

	--local info = {   -- Don't try to recycle this, it gets handed off to callbacks and whatnot
	--	[0] = slashcmd,
	--	appName = appName,
	--	options = options,
	--	input = input,
	--	self = self,
	--	handler = self,
	--	uiType = "cmd",
	--	uiName = MAJOR,
	--}

	wipe(info_)
	info_[0] = slashcmd
	info_.appName = appName
	info_.options = options
	info_.input = input
	info_.self = self
	info_.handler = self
	info_.uiType = "cmd"
	info_.uiName = MAJOR

	handle(info_, 1, options, 0)  -- (info, inputpos, table, depth)
end

--- Utility function to create a slash command handler.
-- Also registers tab completion with AceTab
-- @param slashcmd The slash command WITHOUT leading slash (only used for error output)
-- @param appName The application name as given to `:RegisterOptionsTable()`
function AceConfigCmd:CreateChatCommand(slashcmd, appName, func)
	if not AceConsole then
		AceConsole = LibStub(AceConsoleName)
	end

	-- Ace3v: prevent user from using AceConfigCmd as self
	if self == AceConfigCmd then
		error([[Usage: CreateChatCommand("slashcmd", "appName"[, "func"]): 'self' - use your own 'self']], 2)
	end

	local t = type(func)

	-- Ace3v: make it possible to call another function
	local handler
	if t == "string" then
		handler = function(input) self[func](self, input, slashcmd, appName) end
	elseif t ~= "function" then
		handler = function(input)
			AceConfigCmd.HandleCommand(self, slashcmd, appName, input)	-- upgradable
		end
	else
		handler = func
	end

	if AceConsole.RegisterChatCommand(self, slashcmd, handler, true) then
		-- succesfully registered so lets get the command -> app table in
		commands[slashcmd] = appName
	end
end

--- Utility function that returns the options table that belongs to a slashcommand.
-- Designed to be used for the AceTab interface.
-- @param slashcmd The slash command WITHOUT leading slash (only used for error output)
-- @return The options table associated with the slash command (or nil if the slash command was not registered)
function AceConfigCmd:GetChatCommandOptions(slashcmd)
	return commands[slashcmd]
end

function AceConfigCmd:Embed(target)
	target["HandleCommand"] = self["HandleCommand"]
	target["CreateChatCommand"] = self["CreateChatCommand"]
end

for addon in pairs(AceConfigCmd.embeds) do
	AceConfigCmd:Embed(addon)
end

================
File: Libs/vanilla/Ace3/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceConfigCmd-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.lua
================
--- AceConfigDialog-3.0 generates AceGUI-3.0 based windows based on option tables.
-- @class file
-- @name AceConfigDialog-3.0
-- @release $Id: AceConfigDialog-3.0.lua 1139 2016-07-03 07:43:51Z nevcairiel $

local LibStub = LibStub
local MAJOR, MINOR = "AceConfigDialog-3.0", 70
local AceConfigDialog, oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceConfigDialog then return end

local AceCore = LibStub("AceCore-3.0")
local _G = AceCore._G
local wipe, strsplit = AceCore.wipe, AceCore.strsplit
local safecall = AceCore.safecall
local Dispatchers = AceCore.Dispatchers
local countargs = AceCore.countargs

AceConfigDialog.OpenFrames = AceConfigDialog.OpenFrames or {}
AceConfigDialog.Status = AceConfigDialog.Status or {}
AceConfigDialog.frame = AceConfigDialog.frame or CreateFrame("Frame")

AceConfigDialog.frame.apps = AceConfigDialog.frame.apps or {}
AceConfigDialog.frame.closing = AceConfigDialog.frame.closing or {}
AceConfigDialog.frame.closeAllOverride = AceConfigDialog.frame.closeAllOverride or {}

local gui = LibStub("AceGUI-3.0")
local reg = LibStub("AceConfigRegistry-3.0")

-- Lua APIs
local tconcat, tinsert, tsort, tremove, tgetn, tsetn = table.concat, table.insert, table.sort, table.remove, table.getn, table.setn
local format, strfind, strupper = string.format, string.find, string.upper
local assert, loadstring, error = assert, loadstring, error
local pairs, next, type, unpack, ipairs = pairs, next, type, unpack, ipairs
local rawset, tostring, tonumber = rawset, tostring, tonumber
local math_min, math_max, math_floor = math.min, math.max, math.floor

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: NORMAL_FONT_COLOR, GameTooltip, StaticPopupDialogs, ACCEPT, CANCEL, StaticPopup_Show
-- GLOBALS: PlaySound, GameFontHighlight, GameFontHighlightSmall, GameFontHighlightLarge
-- GLOBALS: CloseSpecialWindows, InterfaceOptions_AddCategory, geterrorhandler

local emptyTbl = {}

local width_multiplier = 170

--[[
Group Types
  Tree 	- All Descendant Groups will all become nodes on the tree, direct child options will appear above the tree
		- Descendant Groups with inline=true and thier children will not become nodes

  Tab	- Direct Child Groups will become tabs, direct child options will appear above the tab control
		- Grandchild groups will default to inline unless specified otherwise

  Select- Same as Tab but with entries in a dropdown rather than tabs


  Inline Groups
	- Will not become nodes of a select group, they will be effectivly part of thier parent group seperated by a border
	- If declared on a direct child of a root node of a select group, they will appear above the group container control
	- When a group is displayed inline, all descendants will also be inline members of the group

]]

-- Recycling functions
local new, del, copy
--newcount, delcount,createdcount,cached = 0,0,0
do
	local pool = setmetatable({},{__mode="k"})
	function new()
		--newcount = newcount + 1
		local t = next(pool)
		if t then
			pool[t] = nil
			return t
		else
			--createdcount = createdcount + 1
			return {}
		end
	end

	function copy(t)
		local c = new()
		for k, v in pairs(t) do
			c[k] = v
		end
		tsetn(c, tgetn(t))
		return c
	end

	function del(t)
		--delcount = delcount + 1
		wipe(t)
		pool[t] = true
	end

--	function cached()
--		local n = 0
--		for k in pairs(pool) do
--			n = n + 1
--		end
--		return n
--	end
end

-- picks the first non-nil value and returns it
local pickfirstset = AceCore.pickfirstset

--gets an option from a given group, checking plugins
local function GetSubOption(group, key)
	if group.plugins then
		for plugin, t in pairs(group.plugins) do
			if t[key] then
				return t[key]
			end
		end
	end

	return group.args[key]
end

--Option member type definitions, used to decide how to access it

--Is the member Inherited from parent options
local isInherited = {
	set = true,
	get = true,
	func = true,
	confirm = true,
	validate = true,
	disabled = true,
	hidden = true
}

--Does a string type mean a literal value, instead of the default of a method of the handler
local stringIsLiteral = {
	name = true,
	desc = true,
	icon = true,
	usage = true,
	width = true,
	image = true,
	fontSize = true,
}

--Is Never a function or method
local allIsLiteral = {
	type = true,
	descStyle = true,
	imageWidth = true,
	imageHeight = true,
}

--gets the value for a member that could be a function
--function refs are called with an info arg
--every other type is returned
local function GetOptionsMemberValue(membername, option, options, path, appName, argc, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	--get definition for the member
	local inherits = isInherited[membername]

	--get the member of the option, traversing the tree if it can be inherited
	local member

	if inherits then
		local group = options
		if group[membername] ~= nil then
			member = group[membername]
		end
		for i = 1, tgetn(path) do
			group = GetSubOption(group, path[i])
			if group[membername] ~= nil then
				member = group[membername]
			end
		end
	else
		member = option[membername]
	end

	--check if we need to call a functon, or if we have a literal value
	if (not allIsLiteral[membername]) and
		(type(member) == "function" or ((not stringIsLiteral[membername]) and type(member) == "string")) then
		--We have a function to call
		local info = new()
		--traverse the options table, picking up the handler and filling the info with the path
		local handler
		local group = options
		handler = group.handler or handler

		local l = tgetn(path)
		for i = 1, l do
			group = GetSubOption(group, path[i])
			info[i] = path[i]
			handler = group.handler or handler
		end
		tsetn(info, l)

		info.options = options
		info.appName = appName
		info[0] = appName
		info.arg = option.arg
		info.handler = handler
		info.option = option
		info.type = option.type
		info.uiType = "dialog"
		info.uiName = MAJOR

		argc = argc or 0
		local a, b, c ,d
		--using 4 returns for the get of a color type, increase if a type needs more
		if type(member) == "function" then
			--Call the function
			a,b,c,d = Dispatchers[argc+1](member,info,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
		else
			--Call the method
			if handler and handler[member] then
				a,b,c,d = Dispatchers[argc+2](handler[member],handler,info,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
			else
				error(format("Method %s doesn't exist in handler for type %s", member, membername))
			end
		end
		del(info)
		return a,b,c,d
	else
		--The value isnt a function to call, return it
		return member
	end
end

--[[calls an options function that could be inherited, method name or function ref
local function CallOptionsFunction(funcname ,option, options, path, appName, ...)
	local info = new()

	local func
	local group = options
	local handler

	--build the info table containing the path
	-- pick up functions while traversing the tree
	if group[funcname] ~= nil then
		func = group[funcname]
	end
	handler = group.handler or handler

	for i, v in ipairs(path) do
		group = GetSubOption(group, v)
		info[i] = v
		if group[funcname] ~= nil then
			func =  group[funcname]
		end
		handler = group.handler or handler
	end

	info.options = options
	info[0] = appName
	info.arg = option.arg

	local a, b, c ,d
	if type(func) == "string" then
		if handler and handler[func] then
			a,b,c,d = handler[func](handler, info, ...)
		else
			error(string.format("Method %s doesn't exist in handler for type func", func))
		end
	elseif type(func) == "function" then
		a,b,c,d = func(info, ...)
	end
	del(info)
	return a,b,c,d
end
--]]

--tables to hold orders and names for options being sorted, will be created with new()
--prevents needing to call functions repeatedly while sorting
local tempOrders
local tempNames

local function compareOptions(a,b)
	if not a then
		return true
	end
	if not b then
		return false
	end
	local OrderA, OrderB = tempOrders[a] or 100, tempOrders[b] or 100
	if OrderA == OrderB then
		local NameA = (type(tempNames[a]) == "string") and tempNames[a] or ""
		local NameB = (type(tempNames[b]) == "string") and tempNames[b] or ""
		return strupper(NameA) < strupper(NameB)
	end
	if OrderA < 0 then
		if OrderB > 0 then
			return false
		end
	else
		if OrderB < 0 then
			return true
		end
	end
	return OrderA < OrderB
end

--builds 2 tables out of an options group
-- keySort, sorted keys
-- opts, combined options from .plugins and args
local function BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
	tempOrders = new()
	tempNames = new()

	if group.plugins then
		for plugin, t in pairs(group.plugins) do
			for k, v in pairs(t) do
				if not opts[k] then
					tinsert(keySort, k)
					opts[k] = v

					tinsert(path,k)
					tempOrders[k] = GetOptionsMemberValue("order", v, options, path, appName)
					tempNames[k] = GetOptionsMemberValue("name", v, options, path, appName)
					tremove(path)
				end
			end
		end
	end

	for k, v in pairs(group.args) do
		if not opts[k] then
			tinsert(keySort, k)
			opts[k] = v

			tinsert(path,k)
			tempOrders[k] = GetOptionsMemberValue("order", v, options, path, appName)
			tempNames[k] = GetOptionsMemberValue("name", v, options, path, appName)
			tremove(path)
		end
	end

	tsort(keySort, compareOptions)

	del(tempOrders)
	del(tempNames)
end

local function DelTree(tree)
	if tree.children then
		local childs = tree.children
		for i = 1, tgetn(childs) do
			DelTree(childs[i])
			del(childs[i])
		end
		del(childs)
	end
end

local function CleanUserData(widget, event)

	local user = widget:GetUserDataTable()

	if user.path then
		del(user.path)
	end

	if widget.type == "TreeGroup" then
		local tree = user.tree
		widget:SetTree(nil)
		if tree then
			for i = 1, tgetn(tree) do
				DelTree(tree[i])
				del(tree[i])
			end
			del(tree)
		end
	end

	if widget.type == "TabGroup" then
		widget:SetTabs(nil)
		if user.tablist then
			del(user.tablist)
		end
	end

	if widget.type == "DropdownGroup" then
		widget:SetGroupList(nil)
		if user.grouplist then
			del(user.grouplist)
		end
		if user.orderlist then
			del(user.orderlist)
		end
	end
end

-- - Gets a status table for the given appname and options path.
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param path The path to the options (a table with all group keys)
-- @return
function AceConfigDialog:GetStatusTable(appName, path)
	local status = self.Status

	if not status[appName] then
		status[appName] = {}
		status[appName].status = {}
		status[appName].children = {}
	end

	status = status[appName]

	if path then
		for i = 1, tgetn(path) do
			local v = path[i]
			if not status.children[v] then
				status.children[v] = {}
				status.children[v].status = {}
				status.children[v].children = {}
			end
			status = status.children[v]
		end
	end

	return status.status
end

--- Selects the specified path in the options window.
-- The path specified has to match the keys of the groups in the table.
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param ... The path to the key that should be selected
do
local args = {nil,nil,nil,nil,nil,nil,nil,nil,nil,nil}
function AceConfigDialog:SelectGroup(appName, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	local path = new()

	local app = reg:GetOptionsTable(appName)
	if not app then
		error(format("%s isn't registed with AceConfigRegistry, unable to open config", appName), 2)
	end
	local options = app("dialog", MAJOR)
	local group = options
	local status = self:GetStatusTable(appName, path)
	if not status.groups then
		status.groups = {}
	end
	status = status.groups
	local treevalue
	local treestatus

	args[1] = a1
	args[2] = a2
	args[3] = a3
	args[4] = a4
	args[5] = a5
	args[6] = a6
	args[7] = a7
	args[8] = a8
	args[9] = a9
	args[10] = a10
	for n = 1, 10 do
		local key = args[n]
		arg[n] = nil

		if not key then break end

		if group.childGroups == "tab" or group.childGroups == "select" then
			--if this is a tab or select group, select the group
			status.selected = key
			--children of this group are no longer extra levels of a tree
			treevalue = nil
		else
			--tree group by default
			if treevalue then
				--this is an extra level of a tree group, build a uniquevalue for it
				treevalue = treevalue.."\001"..key
			else
				--this is the top level of a tree group, the uniquevalue is the same as the key
				treevalue = key
				if not status.groups then
					status.groups = {}
				end
				--save this trees status table for any extra levels or groups
				treestatus = status
			end
			--make sure that the tree entry is open, and select it.
			--the selected group will be overwritten if a child is the final target but still needs to be open
			treestatus.selected = treevalue
			treestatus.groups[treevalue] = true

		end

		--move to the next group in the path
		group = GetSubOption(group, key)
		if not group then
			break
		end
		tinsert(path, key)
		status = self:GetStatusTable(appName, path)
		if not status.groups then
			status.groups = {}
		end
		status = status.groups
	end

	del(path)
	reg:NotifyChange(appName)
end
end -- AceConfigDialog:SelectGroup

local function OptionOnMouseOver(widget, event)
	--show a tooltip/set the status bar to the desc text
	local user = widget:GetUserDataTable()
	local opt = user.option
	local options = user.options
	local path = user.path
	local appName = user.appName

	GameTooltip:SetOwner(widget.frame, "ANCHOR_TOPRIGHT")
	local name = GetOptionsMemberValue("name", opt, options, path, appName)
	local desc = GetOptionsMemberValue("desc", opt, options, path, appName)
	local usage = GetOptionsMemberValue("usage", opt, options, path, appName)
	local descStyle = opt.descStyle

	if descStyle and descStyle ~= "tooltip" then return end

	GameTooltip:SetText(name, 1, .82, 0, true)

	if opt.type == "multiselect" then
		GameTooltip:AddLine(user.text, 0.5, 0.5, 0.8, true)
	end
	if type(desc) == "string" then
		GameTooltip:AddLine(desc, 1, 1, 1, true)
	end
	if type(usage) == "string" then
		GameTooltip:AddLine("Usage: "..usage, NORMAL_FONT_COLOR.r, NORMAL_FONT_COLOR.g, NORMAL_FONT_COLOR.b, true)
	end

	GameTooltip:Show()
end

local function OptionOnMouseLeave(widget, event)
	GameTooltip:Hide()
end

local function GetFuncName(option)
	local type = option.type
	if type == "execute" then
		return "func"
	else
		return "set"
	end
end

local function confirmPopup(appName, rootframe, basepath, info, message, func, argc,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	if not StaticPopupDialogs["ACECONFIGDIALOG30_CONFIRM_DIALOG"] then
		StaticPopupDialogs["ACECONFIGDIALOG30_CONFIRM_DIALOG"] = {}
	end
	local t = StaticPopupDialogs["ACECONFIGDIALOG30_CONFIRM_DIALOG"]
	for k in pairs(t) do
		t[k] = nil
	end
	t.text = message
	t.button1 = ACCEPT
	t.button2 = CANCEL
	t.preferredIndex = STATICPOPUP_NUMDIALOGS
	local dialog, oldstrata
	t.OnAccept = function()
		safecall(func, tgetn(t), unpack(t))
		if dialog and oldstrata then
			dialog:SetFrameStrata(oldstrata)
		end
		AceConfigDialog:Open(appName, rootframe, unpack(basepath or emptyTbl))
		del(info)
	end
	t.OnCancel = function()
		if dialog and oldstrata then
			dialog:SetFrameStrata(oldstrata)
		end
		AceConfigDialog:Open(appName, rootframe, unpack(basepath or emptyTbl))
		del(info)
	end
	t[1] = a1
	t[2] = a2
	t[3] = a3
	t[4] = a4
	t[5] = a5
	t[6] = a6
	t[7] = a7
	t[8] = a8
	t[9] = a9
	t[10] = a10
	for i=1,argc do
		t[i] = t[i] or false
	end
	for i=argc+1,10 do
		t[i] = nil
	end
	tsetn(t,argc)
	t.timeout = 0
	t.whileDead = 1
	t.hideOnEscape = 1

	dialog = StaticPopup_Show("ACECONFIGDIALOG30_CONFIRM_DIALOG")
	if dialog then
		oldstrata = dialog:GetFrameStrata()
		dialog:SetFrameStrata("TOOLTIP")
	end
end

local function ActivateControl(widget, event, argc, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	--This function will call the set / execute handler for the widget
	--widget:GetUserDataTable() contains the needed info
	local user = widget:GetUserDataTable()
	local option = user.option
	local options = user.options
	local path = user.path
	local info = new()

	local func
	local group = options
	local funcname = GetFuncName(option)
	local handler
	local confirm
	local validate
	--build the info table containing the path
	-- pick up functions while traversing the tree
	if group[funcname] ~= nil then
		func =  group[funcname]
	end
	handler = group.handler or handler
	confirm = group.confirm
	validate = group.validate

	local l = tgetn(path)
	for i = 1, l do
		local v = path[i]
		group = GetSubOption(group, v)
		info[i] = v
		if group[funcname] ~= nil then
			func =  group[funcname]
		end
		handler = group.handler or handler
		if group.confirm ~= nil then
			confirm = group.confirm
		end
		if group.validate ~= nil then
			validate = group.validate
		end
	end
	tsetn(info, l)

	info.options = options
	info.appName = user.appName
	info.arg = option.arg
	info.handler = handler
	info.option = option
	info.type = option.type
	info.uiType = "dialog"
	info.uiName = MAJOR

	local name

	if type(option.name) == "function" then
		name = option.name(info)
	elseif type(option.name) == "string" then
		name = option.name
	else
		name = ""
	end
	local usage = option.usage
	local pattern = option.pattern

	local validated = true

	if option.type == "input" then
		if type(pattern)=="string" then
			if not strfind(a1, pattern) then
				validated = false
			end
		end
	end

	local success
	if validated and option.type ~= "execute" then
		if type(validate) == "string" then
			if handler and handler[validate] then
				success, validated = safecall(handler[validate], argc+2, handler, info, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
				if not success then validated = false end
			else
				error(format("Method %s doesn't exist in handler for type execute", validate))
			end
		elseif type(validate) == "function" then
			success, validated = safecall(validate, argc+1, info, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
			if not success then validated = false end
		end
	end

	local rootframe = user.rootframe
	if type(validated) == "string" then
		--validate function returned a message to display
		if rootframe.SetStatusText then
			rootframe:SetStatusText(validated)
		else
			-- TODO: do something else.
		end
		PlaySound("igPlayerInviteDecline")
		del(info)
		return true
	elseif not validated then
		--validate returned false
		if rootframe.SetStatusText then
			if usage then
				rootframe:SetStatusText(name..": "..usage)
			else
				if pattern then
					rootframe:SetStatusText(name..": Expected "..pattern)
				else
					rootframe:SetStatusText(name..": Invalid Value")
				end
			end
		else
			-- TODO: do something else
		end
		PlaySound("igPlayerInviteDecline")
		del(info)
		return true
	else

		local confirmText = option.confirmText
		--call confirm func/method
		if type(confirm) == "string" then
			if handler and handler[confirm] then
				success, confirm = safecall(handler[confirm], argc+2, handler, info, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
				if success and type(confirm) == "string" then
					confirmText = confirm
					confirm = true
				elseif not success then
					confirm = false
				end
			else
				error(format("Method %s doesn't exist in handler for type confirm", confirm))
			end
		elseif type(confirm) == "function" then
			success, confirm = safecall(confirm, argc+1, info, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
			if success and type(confirm) == "string" then
				confirmText = confirm
				confirm = true
			elseif not success then
				confirm = false
			end
		end

		--confirm if needed
		if type(confirm) == "boolean" then
			if confirm then
				if not confirmText then
					local name, desc = option.name, option.desc
					if type(name) == "function" then
						name = name(info)
					end
					if type(desc) == "function" then
						desc = desc(info)
					end
					confirmText = name
					if desc then
						confirmText = confirmText.." - "..desc
					end
				end

				local iscustom = user.rootframe:GetUserData("iscustom")
				local rootframe

				if iscustom then
					rootframe = user.rootframe
				end
				local basepath = user.rootframe:GetUserData("basepath")
				if type(func) == "string" then
					if handler and handler[func] then
						confirmPopup(user.appName, rootframe, basepath, info, confirmText, handler[func], argc+2, handler, info, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
					else
						error(format("Method %s doesn't exist in handler for type func", func))
					end
				elseif type(func) == "function" then
					confirmPopup(user.appName, rootframe, basepath, info, confirmText, func, argc+1, info,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
				end
				--func will be called and info deleted when the confirm dialog is responded to
				return
			end
		end

		--call the function
		if type(func) == "string" then
			if handler and handler[func] then
				safecall(handler[func], argc+2, handler, info, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
			else
				error(format("Method %s doesn't exist in handler for type func", func))
			end
		elseif type(func) == "function" then
			safecall(func, argc+1, info, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
		end

		local iscustom = user.rootframe:GetUserData("iscustom")
		local basepath = user.rootframe:GetUserData("basepath") or emptyTbl
		--full refresh of the frame, some controls dont cause this on all events
		if option.type == "color" then
			if event == "OnValueConfirmed" then

				if iscustom then
					AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
				else
					AceConfigDialog:Open(user.appName, unpack(basepath))
				end
			end
		elseif option.type == "range" then
			if event == "OnMouseUp" then
				if iscustom then
					AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
				else
					AceConfigDialog:Open(user.appName, unpack(basepath))
				end
			end
		--multiselects don't cause a refresh on 'OnValueChanged' only 'OnClosed'
		elseif option.type == "multiselect" then
			user.valuechanged = true
		else
			if iscustom then
				AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
			else
				AceConfigDialog:Open(user.appName, unpack(basepath))
			end
		end

	end
	del(info)
end

local function ActivateSlider(widget, event, _, value)
	local option = widget:GetUserData("option")
	local min, max, step = option.min or (not option.softMin and 0 or nil),
		option.max or (not option.softMax and 100 or nil), option.step
	if min then
		if step then
			value = math_floor((value - min) / step + 0.5) * step + min
		end
		value = math_max(value, min)
	end
	if max then
		value = math_min(value, max)
	end
	ActivateControl(widget,event,1,value)
end

--called from a checkbox that is part of an internally created multiselect group
--this type is safe to refresh on activation of one control
local function ActivateMultiControl(widget, event, argc, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	ActivateControl(widget, event, argc+1, widget:GetUserData("value"), a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	local user = widget:GetUserDataTable()
	local iscustom = user.rootframe:GetUserData("iscustom")
	local basepath = user.rootframe:GetUserData("basepath") or emptyTbl
	if iscustom then
		AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
	else
		AceConfigDialog:Open(user.appName, unpack(basepath))
	end
end

local function MultiControlOnClosed(widget, event)
	local user = widget:GetUserDataTable()
	if user.valuechanged then
		local iscustom = user.rootframe:GetUserData("iscustom")
		local basepath = user.rootframe:GetUserData("basepath") or emptyTbl
		if iscustom then
			AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
		else
			AceConfigDialog:Open(user.appName, unpack(basepath))
		end
	end
end

local function FrameOnClose(widget, event)
	local appName = widget:GetUserData("appName")
	AceConfigDialog.OpenFrames[appName] = nil
	gui:Release(widget)
end

local function CheckOptionHidden(option, options, path, appName)
	--check for a specific boolean option
	local hidden = pickfirstset(2,option.dialogHidden,option.guiHidden)
	if hidden ~= nil then
		return hidden
	end

	return GetOptionsMemberValue("hidden", option, options, path, appName)
end

local function CheckOptionDisabled(option, options, path, appName)
	--check for a specific boolean option
	local disabled = pickfirstset(2,option.dialogDisabled,option.guiDisabled)
	if disabled ~= nil then
		return disabled
	end

	return GetOptionsMemberValue("disabled", option, options, path, appName)
end

--[[
local function BuildTabs(group, options, path, appName)
	local tabs = new()
	local text = new()
	local keySort = new()
	local opts = new()

	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)

	for i = 1, #keySort do
		local k = keySort[i]
		local v = opts[k]
		if v.type == "group" then
			path[#path+1] = k
			local inline = pickfirstset(4,v.dialogInline,v.guiInline,v.inline, false)
			local hidden = CheckOptionHidden(v, options, path, appName)
			if not inline and not hidden then
				tinsert(tabs, k)
				text[k] = GetOptionsMemberValue("name", v, options, path, appName)
			end
			path[#path] = nil
		end
	end

	del(keySort)
	del(opts)

	return tabs, text
end
]]
local function BuildSelect(group, options, path, appName)
	local groups = new()
	local order = new()
	local keySort = new()
	local opts = new()

	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)

	for i = 1, tgetn(keySort) do
		local k = keySort[i]
		local v = opts[k]
		if v.type == "group" then
			tinsert(path,k)
			local inline = pickfirstset(4,v.dialogInline,v.guiInline,v.inline, false)
			local hidden = CheckOptionHidden(v, options, path, appName)
			if not inline and not hidden then
				groups[k] = GetOptionsMemberValue("name", v, options, path, appName)
				tinsert(order, k)
			end
			tremove(path)
		end
	end

	del(opts)
	del(keySort)

	return groups, order
end

local function BuildSubGroups(group, tree, options, path, appName)
	local keySort = new()
	local opts = new()

	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)

	for i = 1, tgetn(keySort) do
		local k = keySort[i]
		local v = opts[k]
		if v.type == "group" then
			tinsert(path,k)
			local inline = pickfirstset(4,v.dialogInline,v.guiInline,v.inline, false)
			local hidden = CheckOptionHidden(v, options, path, appName)
			if not inline and not hidden then
				local entry = new()
				entry.value = k
				entry.text = GetOptionsMemberValue("name", v, options, path, appName)
				entry.icon = GetOptionsMemberValue("icon", v, options, path, appName)
				entry.iconCoords = GetOptionsMemberValue("iconCoords", v, options, path, appName)
				entry.disabled = CheckOptionDisabled(v, options, path, appName)
				if not tree.children then tree.children = new() end
				tinsert(tree.children,entry)
				if (v.childGroups or "tree") == "tree" then
					BuildSubGroups(v,entry, options, path, appName)
				end
			end
			tremove(path)
		end
	end

	del(keySort)
	del(opts)
end

local function BuildGroups(group, options, path, appName, recurse)
	local tree = new()
	local keySort = new()
	local opts = new()

	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)

	for i = 1, tgetn(keySort) do
		local k = keySort[i]
		local v = opts[k]
		if v.type == "group" then
			tinsert(path,k)
			local inline = pickfirstset(4,v.dialogInline,v.guiInline,v.inline, false)
			local hidden = CheckOptionHidden(v, options, path, appName)
			if not inline and not hidden then
				local entry = new()
				entry.value = k
				entry.text = GetOptionsMemberValue("name", v, options, path, appName)
				entry.icon = GetOptionsMemberValue("icon", v, options, path, appName)
				entry.disabled = CheckOptionDisabled(v, options, path, appName)
				tinsert(tree,entry)
				if recurse and (v.childGroups or "tree") == "tree" then
					BuildSubGroups(v,entry, options, path, appName)
				end
			end
			tremove(path)
		end
	end
	del(keySort)
	del(opts)
	return tree
end

local function InjectInfo(control, options, option, path, rootframe, appName)
	local user = control:GetUserDataTable()
	local l = tgetn(path)
	for i = 1, l do
		user[i] = path[i]
	end
	tsetn(user,l)

	user.rootframe = rootframe
	user.option = option
	user.options = options
	user.path = copy(path)
	user.appName = appName
	control:SetCallback("OnRelease", CleanUserData)
	control:SetCallback("OnLeave", OptionOnMouseLeave)
	control:SetCallback("OnEnter", OptionOnMouseOver)
end

--[[
	options - root of the options table being fed
	container - widget that controls will be placed in
	rootframe - Frame object the options are in
	path - table with the keys to get to the group being fed
--]]

local function FeedOptions(appName, options,container,rootframe,path,group,inline)
	local keySort = new()
	local opts = new()

	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)

	for i = 1, tgetn(keySort) do
		local k = keySort[i]
		local v = opts[k]
		tinsert(path, k)
		local hidden = CheckOptionHidden(v, options, path, appName)
		local name = GetOptionsMemberValue("name", v, options, path, appName)
		if not hidden then
			if v.type == "group" then
				if inline or pickfirstset(4, v.dialogInline,v.guiInline,v.inline, false) then
					--Inline group
					local GroupContainer
					if name and name ~= "" then
						GroupContainer = gui:Create("InlineGroup")
						GroupContainer:SetTitle(name or "")
					else
						GroupContainer = gui:Create("SimpleGroup")
					end

					GroupContainer.width = "fill"
					GroupContainer:SetLayout("flow")
					container:AddChild(GroupContainer)
					FeedOptions(appName,options,GroupContainer,rootframe,path,v,true)
				end
			else
				--Control to feed
				local control

				local name = GetOptionsMemberValue("name", v, options, path, appName)

				if v.type == "execute" then

					local imageCoords = GetOptionsMemberValue("imageCoords",v, options, path, appName)
					local image, width, height = GetOptionsMemberValue("image",v, options, path, appName)

					if type(image) == "string" or type(image) == "number" then
						control = gui:Create("Icon")
						if not width then
							width = GetOptionsMemberValue("imageWidth",v, options, path, appName)
						end
						if not height then
							height = GetOptionsMemberValue("imageHeight",v, options, path, appName)
						end
						if type(imageCoords) == "table" then
							control:SetImage(image, unpack(imageCoords))
						else
							control:SetImage(image)
						end
						if type(width) ~= "number" then
							width = 32
						end
						if type(height) ~= "number" then
							height = 32
						end
						control:SetImageSize(width, height)
						control:SetLabel(name)
					else
						control = gui:Create("Button")
						control:SetText(name)
					end
					control:SetCallback("OnClick",ActivateControl)

				elseif v.type == "input" then
					local controlType = v.dialogControl or v.control or (v.multiline and "MultiLineEditBox") or "EditBox"
					control = gui:Create(controlType)
					if not control then
						geterrorhandler()(format("Invalid Custom Control Type - %s", tostring(controlType)))
						control = gui:Create(v.multiline and "MultiLineEditBox" or "EditBox")
					end

					if v.multiline and control.SetNumLines then
						control:SetNumLines(tonumber(v.multiline) or 4)
					end
					control:SetLabel(name)
					control:SetCallback("OnEnterPressed",ActivateControl)
					local text = GetOptionsMemberValue("get",v, options, path, appName)
					if type(text) ~= "string" then
						text = ""
					end
					control:SetText(text)

				elseif v.type == "toggle" then
					control = gui:Create("CheckBox")
					control:SetLabel(name)
					control:SetTriState(v.tristate)
					local value = GetOptionsMemberValue("get",v, options, path, appName)
					control:SetValue(value)
					control:SetCallback("OnValueChanged",ActivateControl)

					if v.descStyle == "inline" then
						local desc = GetOptionsMemberValue("desc", v, options, path, appName)
						control:SetDescription(desc)
					end

					local image = GetOptionsMemberValue("image", v, options, path, appName)
					local imageCoords = GetOptionsMemberValue("imageCoords", v, options, path, appName)

					if type(image) == "string" or type(image) == "number" then
						if type(imageCoords) == "table" then
							control:SetImage(image, unpack(imageCoords))
						else
							control:SetImage(image)
						end
					end
				elseif v.type == "range" then
					control = gui:Create("Slider")
					control:SetLabel(name)
					control:SetSliderValues(v.softMin or v.min or 0, v.softMax or v.max or 100, v.bigStep or v.step or 0)
					control:SetIsPercent(v.isPercent)
					local value = GetOptionsMemberValue("get",v, options, path, appName)
					if type(value) ~= "number" then
						value = 0
					end
					control:SetValue(value)
					control:SetCallback("OnValueChanged",ActivateSlider)
					control:SetCallback("OnMouseUp",ActivateSlider)

				elseif v.type == "select" then
					local values = GetOptionsMemberValue("values", v, options, path, appName)
					if v.style == "radio" then
						local disabled = CheckOptionDisabled(v, options, path, appName)
						local width = GetOptionsMemberValue("width",v,options,path,appName)
						control = gui:Create("InlineGroup")
						control:SetLayout("Flow")
						control:SetTitle(name)
						control.width = "fill"

						control:PauseLayout()
						local optionValue = GetOptionsMemberValue("get",v, options, path, appName)
						local t = {}
						for value, text in pairs(values) do
							tinsert(t,value)
						end
						tsort(t)
						for k, value in ipairs(t) do
							local text = values[value]
							local radio = gui:Create("CheckBox")
							radio:SetLabel(text)
							radio:SetUserData("value", value)
							radio:SetUserData("text", text)
							radio:SetDisabled(disabled)
							radio:SetType("radio")
							radio:SetValue(optionValue == value)
							radio:SetCallback("OnValueChanged", ActivateMultiControl)
							InjectInfo(radio, options, v, path, rootframe, appName)
							control:AddChild(radio)
							if width == "double" then
								radio:SetWidth(width_multiplier * 2)
							elseif width == "half" then
								radio:SetWidth(width_multiplier / 2)
							elseif width == "full" then
								radio.width = "fill"
							else
								radio:SetWidth(width_multiplier)
							end
						end
						control:ResumeLayout()
						control:DoLayout()
					else
						local controlType = v.dialogControl or v.control or "Dropdown"
						control = gui:Create(controlType)
						if not control then
							geterrorhandler()(format("Invalid Custom Control Type - %s", tostring(controlType)))
							control = gui:Create("Dropdown")

						end
						local itemType = v.itemControl
						if itemType and not gui:GetWidgetVersion(itemType) then
							geterrorhandler()(format("Invalid Custom Item Type - %s", tostring(itemType)))
							itemType = nil
						end
						control:SetLabel(name)
						control:SetList(values, nil, itemType)
						local value = GetOptionsMemberValue("get",v, options, path, appName)
						if not values[value] then
							value = nil
						end
						control:SetValue(value)
						control:SetCallback("OnValueChanged", ActivateControl)
					end

				elseif v.type == "multiselect" then
					local values = GetOptionsMemberValue("values", v, options, path, appName)

					local disabled = CheckOptionDisabled(v, options, path, appName)

					local controlType = v.dialogControl or v.control

					local valuesort = new()
					if values then
						for value, text in pairs(values) do
							tinsert(valuesort, value)
						end
					end
					tsort(valuesort)

					if controlType then
						control = gui:Create(controlType)
						if not control then
							geterrorhandler()(format("Invalid Custom Control Type - %s", tostring(controlType)))
						end
					end
					if control then
						control:SetMultiselect(true)
						control:SetLabel(name)
						control:SetList(values)
						control:SetDisabled(disabled)
						control:SetCallback("OnValueChanged",ActivateControl)
						control:SetCallback("OnClosed", MultiControlOnClosed)
						local width = GetOptionsMemberValue("width",v,options,path,appName)
						if width == "double" then
							control:SetWidth(width_multiplier * 2)
						elseif width == "half" then
							control:SetWidth(width_multiplier / 2)
						elseif width == "full" then
							control.width = "fill"
						else
							control:SetWidth(width_multiplier)
						end
						--check:SetTriState(v.tristate)
						for i = 1, tgetn(valuesort) do
							local key = valuesort[i]
							local value = GetOptionsMemberValue("get", v, options, path, appName, 1, key)
							control:SetItemValue(key,value)
						end
					else
						control = gui:Create("InlineGroup")
						control:SetLayout("Flow")
						control:SetTitle(name)
						control.width = "fill"

						control:PauseLayout()
						local width = GetOptionsMemberValue("width",v,options,path,appName)
						for i = 1, tgetn(valuesort) do
							local value = valuesort[i]
							local text = values[value]
							local check = gui:Create("CheckBox")
							check:SetLabel(text)
							check:SetUserData("value", value)
							check:SetUserData("text", text)
							check:SetDisabled(disabled)
							check:SetTriState(v.tristate)
							check:SetValue(GetOptionsMemberValue("get",v, options, path, appName, 1, value))
							check:SetCallback("OnValueChanged",ActivateMultiControl)
							InjectInfo(check, options, v, path, rootframe, appName)
							control:AddChild(check)
							if width == "double" then
								check:SetWidth(width_multiplier * 2)
							elseif width == "half" then
								check:SetWidth(width_multiplier / 2)
							elseif width == "full" then
								check.width = "fill"
							else
								check:SetWidth(width_multiplier)
							end
						end
						control:ResumeLayout()
						control:DoLayout()


					end

					del(valuesort)

				elseif v.type == "color" then
					control = gui:Create("ColorPicker")
					control:SetLabel(name)
					control:SetHasAlpha(GetOptionsMemberValue("hasAlpha",v, options, path, appName))
					control:SetColor(GetOptionsMemberValue("get",v, options, path, appName))
					control:SetCallback("OnValueChanged",ActivateControl)
					control:SetCallback("OnValueConfirmed",ActivateControl)

				elseif v.type == "keybinding" then
					control = gui:Create("Keybinding")
					control:SetLabel(name)
					control:SetKey(GetOptionsMemberValue("get",v, options, path, appName))
					control:SetCallback("OnKeyChanged",ActivateControl)

				elseif v.type == "header" then
					control = gui:Create("Heading")
					control:SetText(name)
					control.width = "fill"

				elseif v.type == "description" then
					control = gui:Create("Label")
					control:SetText(name)

					local fontSize = GetOptionsMemberValue("fontSize",v, options, path, appName)
					if fontSize == "medium" then
						control:SetFontObject(GameFontHighlight)
					elseif fontSize == "large" then
						control:SetFontObject(GameFontHighlightLarge)
					else -- small or invalid
						control:SetFontObject(GameFontHighlightSmall)
					end

					local imageCoords = GetOptionsMemberValue("imageCoords",v, options, path, appName)
					local image, width, height = GetOptionsMemberValue("image",v, options, path, appName)

					if type(image) == "string" or type(image) == "number" then
						if not width then
							width = GetOptionsMemberValue("imageWidth",v, options, path, appName)
						end
						if not height then
							height = GetOptionsMemberValue("imageHeight",v, options, path, appName)
						end
						if type(imageCoords) == "table" then
							control:SetImage(image, unpack(imageCoords))
						else
							control:SetImage(image)
						end
						if type(width) ~= "number" then
							width = 32
						end
						if type(height) ~= "number" then
							height = 32
						end
						control:SetImageSize(width, height)
					end
					local width = GetOptionsMemberValue("width",v,options,path,appName)
					control.width = not width and "fill"
				end

				--Common Init
				if control then
					if control.width ~= "fill" then
						local width = GetOptionsMemberValue("width",v,options,path,appName)
						if width == "double" then
							control:SetWidth(width_multiplier * 2)
						elseif width == "half" then
							control:SetWidth(width_multiplier / 2)
						elseif width == "full" then
							control.width = "fill"
						else
							control:SetWidth(width_multiplier)
						end
					end
					if control.SetDisabled then
						local disabled = CheckOptionDisabled(v, options, path, appName)
						control:SetDisabled(disabled)
					end

					InjectInfo(control, options, v, path, rootframe, appName)
					container:AddChild(control)
				end

			end
		end
		tremove(path)
	end
	container:ResumeLayout()
	container:DoLayout()
	del(keySort)
	del(opts)
end

-- Ace3v: recursive
local function BuildPath(path, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	if a1 then
		tinsert(path,a1)
		BuildPath(path,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	end
end

local function TreeOnButtonEnter(widget, event, _, uniquevalue, button)
	local user = widget:GetUserDataTable()
	if not user then return end
	local options = user.options
	local option = user.option
	local path = user.path
	local appName = user.appName

	local feedpath = new()
	local l = tgetn(path)
	for i = 1, l do
		feedpath[i] = path[i]
	end
	tsetn(feedpath,l)

	BuildPath(feedpath, strsplit("\001", uniquevalue))
	local group = options
	for i = 1, tgetn(feedpath) do
		if not group then return end
		group = GetSubOption(group, feedpath[i])
	end

	local name = GetOptionsMemberValue("name", group, options, feedpath, appName)
	local desc = GetOptionsMemberValue("desc", group, options, feedpath, appName)

	GameTooltip:SetOwner(button, "ANCHOR_NONE")
	if widget.type == "TabGroup" then
		GameTooltip:SetPoint("BOTTOM",button,"TOP")
	else
		GameTooltip:SetPoint("LEFT",button,"RIGHT")
	end

	GameTooltip:SetText(name, 1, .82, 0, true)

	if type(desc) == "string" then
		GameTooltip:AddLine(desc, 1, 1, 1, true)
	end

	GameTooltip:Show()
end

local function TreeOnButtonLeave(widget, event, _, value, button)
	GameTooltip:Hide()
end

local function GroupExists(appName, options, path, uniquevalue)

	if not uniquevalue then return false end
	local feedpath = new()
	local temppath = new()
	local l = tgetn(path)
	for i = 1, l do
		feedpath[i] = path[i]
	end
	tsetn(feedpath,l)

	BuildPath(feedpath, strsplit("\001", uniquevalue))

	local group = options
	for i = 1, tgetn(feedpath) do
		local v = feedpath[i]
		temppath[i] = v
		group = GetSubOption(group, v)

		if not group or group.type ~= "group" or CheckOptionHidden(group, options, temppath, appName) then
			del(feedpath)
			del(temppath)
			return false
		end
	end
	del(feedpath)
	del(temppath)
	return true
end

local function GroupSelected(widget, event, _, uniquevalue)
	if not uniquevalue then widget:ReleaseChildren() return end

	local user = widget:GetUserDataTable()

	local options = user.options
	local option = user.option
	local path = user.path
	local rootframe = user.rootframe

	local feedpath = new()
	local l = tgetn(path)
	for i = 1, l do
		feedpath[i] = path[i]
	end
	tsetn(feedpath,l)

	BuildPath(feedpath, strsplit("\001", uniquevalue))
	local group = options
	for i = 1, tgetn(feedpath) do
		group = GetSubOption(group, feedpath[i])
	end
	widget:ReleaseChildren()

	AceConfigDialog:FeedGroup(user.appName,options,widget,rootframe,feedpath)

	del(feedpath)
end

--[[
-- INTERNAL --
This function will feed one group, and any inline child groups into the given container
Select Groups will only have the selection control (tree, tabs, dropdown) fed in
and have a group selected, this event will trigger the feeding of child groups

Rules:
	If the group is Inline, FeedOptions
	If the group has no child groups, FeedOptions

	If the group is a tab or select group, FeedOptions then add the Group Control
	If the group is a tree group FeedOptions then
		its parent isnt a tree group:  then add the tree control containing this and all child tree groups
		if its parent is a tree group, its already a node on a tree
--]]

function AceConfigDialog:FeedGroup(appName,options,container,rootframe,path, isRoot)

	local group = options
	--follow the path to get to the curent group
	local inline
	local grouptype, parenttype = options.childGroups, "none"

	for i = 1, tgetn(path) do
		local v = path[i]
		group = GetSubOption(group, v)
		inline = inline or pickfirstset(4,group.dialogInline,group.guiInline,group.inline, false)
		parenttype = grouptype
		grouptype = group.childGroups
	end

	if not parenttype then
		parenttype = "tree"
	end

	--check if the group has child groups
	local hasChildGroups
	for k, v in pairs(group.args) do
		if v.type == "group" and not pickfirstset(4, v.dialogInline, v.guiInline, v.inline, false) and
			not CheckOptionHidden(v, options, path, appName) then
			hasChildGroups = true
		end
	end
	if group.plugins then
		for plugin, t in pairs(group.plugins) do
			for k, v in pairs(t) do
				if v.type == "group" and not pickfirstset(4, v.dialogInline, v.guiInline, v.inline, false) and
					not CheckOptionHidden(v, options, path, appName) then
					hasChildGroups = true
				end
			end
		end
	end

	container:SetLayout("flow")
	local scroll

	--Add a scrollframe if we are not going to add a group control, this is the inverse of the conditions for that later on
	if (not (hasChildGroups and not inline)) or
		(grouptype ~= "tab" and grouptype ~= "select" and (parenttype == "tree" and not isRoot)) then
		if container.type ~= "InlineGroup" and container.type ~= "SimpleGroup" then
			scroll = gui:Create("ScrollFrame")
			scroll:SetLayout("flow")
			scroll.width = "fill"
			scroll.height = "fill"
			container:SetLayout("fill")
			container:AddChild(scroll)
			container = scroll
		end
	end

	FeedOptions(appName,options,container,rootframe,path,group,nil)

	if scroll then
		container:PerformLayout()
		local status = self:GetStatusTable(appName, path)
		if not status.scroll then
			status.scroll = {}
		end
		scroll:SetStatusTable(status.scroll)
	end

	if hasChildGroups and not inline then
		local name = GetOptionsMemberValue("name", group, options, path, appName)
		if grouptype == "tab" then

			local tab = gui:Create("TabGroup")
			InjectInfo(tab, options, group, path, rootframe, appName)
			tab:SetCallback("OnGroupSelected", GroupSelected)
			tab:SetCallback("OnTabEnter", TreeOnButtonEnter)
			tab:SetCallback("OnTabLeave", TreeOnButtonLeave)

			local status = AceConfigDialog:GetStatusTable(appName, path)
			if not status.groups then
				status.groups = {}
			end
			tab:SetStatusTable(status.groups)
			tab.width = "fill"
			tab.height = "fill"

			local tabs = BuildGroups(group, options, path, appName)
			tab:SetTabs(tabs)
			tab:SetUserData("tablist", tabs)

			for i = 1, tgetn(tabs) do
				local entry = tabs[i]
				if not entry.disabled then
					tab:SelectTab((GroupExists(appName, options, path,status.groups.selected) and status.groups.selected) or entry.value)
					break
				end
			end

			container:AddChild(tab)

		elseif grouptype == "select" then

			local select = gui:Create("DropdownGroup")
			select:SetTitle(name)
			InjectInfo(select, options, group, path, rootframe, appName)
			select:SetCallback("OnGroupSelected", GroupSelected)
			local status = AceConfigDialog:GetStatusTable(appName, path)
			if not status.groups then
				status.groups = {}
			end
			select:SetStatusTable(status.groups)
			local grouplist, orderlist = BuildSelect(group, options, path, appName)
			select:SetGroupList(grouplist, orderlist)
			select:SetUserData("grouplist", grouplist)
			select:SetUserData("orderlist", orderlist)

			local firstgroup = orderlist[1]
			if firstgroup then
				select:SetGroup((GroupExists(appName, options, path, status.groups.selected) and status.groups.selected) or firstgroup)
			end

			select.width = "fill"
			select.height = "fill"

			container:AddChild(select)

		--assume tree group by default
		--if parenttype is tree then this group is already a node on that tree
		elseif (parenttype ~= "tree") or isRoot then
			local tree = gui:Create("TreeGroup")
			InjectInfo(tree, options, group, path, rootframe, appName)
			tree:EnableButtonTooltips(false)

			tree.width = "fill"
			tree.height = "fill"

			tree:SetCallback("OnGroupSelected", GroupSelected)
			tree:SetCallback("OnButtonEnter", TreeOnButtonEnter)
			tree:SetCallback("OnButtonLeave", TreeOnButtonLeave)

			local status = AceConfigDialog:GetStatusTable(appName, path)
			if not status.groups then
				status.groups = {}
			end
			local treedefinition = BuildGroups(group, options, path, appName, true)
			tree:SetStatusTable(status.groups)

			tree:SetTree(treedefinition)
			tree:SetUserData("tree",treedefinition)

			for i = 1, tgetn(treedefinition) do
				local entry = treedefinition[i]
				if not entry.disabled then
					tree:SelectByValue((GroupExists(appName, options, path,status.groups.selected) and status.groups.selected) or entry.value)
					break
				end
			end

			container:AddChild(tree)
		end
	end
end

local old_CloseSpecialWindows


local function RefreshOnUpdate(this)
	for appName in pairs(this.closing) do
		if AceConfigDialog.OpenFrames[appName] then
			AceConfigDialog.OpenFrames[appName]:Hide()
		end
		if AceConfigDialog.BlizOptions and AceConfigDialog.BlizOptions[appName] then
			for key, widget in pairs(AceConfigDialog.BlizOptions[appName]) do
				if not widget:IsVisible() then
					widget:ReleaseChildren()
				end
			end
		end
		this.closing[appName] = nil
	end

	if this.closeAll then
		for k, v in pairs(AceConfigDialog.OpenFrames) do
			if not this.closeAllOverride[k] then
				v:Hide()
			end
		end
		this.closeAll = nil
		wipe(this.closeAllOverride)
	end

	for appName in pairs(this.apps) do
		if AceConfigDialog.OpenFrames[appName] then
			local user = AceConfigDialog.OpenFrames[appName]:GetUserDataTable()
			AceConfigDialog:Open(appName, unpack(user.basepath or emptyTbl))
		end
		if AceConfigDialog.BlizOptions and AceConfigDialog.BlizOptions[appName] then
			for key, widget in pairs(AceConfigDialog.BlizOptions[appName]) do
				local user = widget:GetUserDataTable()
				if widget:IsVisible() then
					AceConfigDialog:Open(widget:GetUserData("appName"), widget, unpack(user.basepath or emptyTbl))
				end
			end
		end
		this.apps[appName] = nil
	end
	this:SetScript("OnUpdate", nil)
end

-- Upgrade the OnUpdate script as well, if needed.
if AceConfigDialog.frame:GetScript("OnUpdate") then
	AceConfigDialog.frame:SetScript("OnUpdate", function() RefreshOnUpdate(this) end)
end

--- Close all open options windows
function AceConfigDialog:CloseAll()
	AceConfigDialog.frame.closeAll = true
	AceConfigDialog.frame:SetScript("OnUpdate", function() RefreshOnUpdate(this) end)
	if next(self.OpenFrames) then
		return true
	end
end

--- Close a specific options window.
-- @param appName The application name as given to `:RegisterOptionsTable()`
function AceConfigDialog:Close(appName)
	if self.OpenFrames[appName] then
		AceConfigDialog.frame.closing[appName] = true
		AceConfigDialog.frame:SetScript("OnUpdate", function() RefreshOnUpdate(this) end)
		return true
	end
end

-- Internal -- Called by AceConfigRegistry
function AceConfigDialog:ConfigTableChanged(event, appName)
	AceConfigDialog.frame.apps[appName] = true
	AceConfigDialog.frame:SetScript("OnUpdate", function() RefreshOnUpdate(this) end)
end

reg.RegisterCallback(AceConfigDialog, "ConfigTableChange", "ConfigTableChanged")

--- Sets the default size of the options window for a specific application.
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param width The default width
-- @param height The default height
function AceConfigDialog:SetDefaultSize(appName, width, height)
	local status = AceConfigDialog:GetStatusTable(appName)
	if type(width) == "number" and type(height) == "number" then
		status.width = width
		status.height = height
	end
end

--- Open an option window at the specified path (if any).
-- This function can optionally feed the group into a pre-created container
-- instead of creating a new container frame.
-- @paramsig appName [, container][, ...]
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param container An optional container frame to feed the options into
-- @param ... The path to open after creating the options window (see `:SelectGroup` for details)
function AceConfigDialog:Open(appName, container, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	if not old_CloseSpecialWindows then
		old_CloseSpecialWindows = CloseSpecialWindows
		CloseSpecialWindows = function()
			local found = old_CloseSpecialWindows()
			return self:CloseAll() or found
		end
	end
	local app = reg:GetOptionsTable(appName)
	if not app then
		error(format("%s isn't registed with AceConfigRegistry, unable to open config", appName), 2)
	end
	local options = app("dialog", MAJOR)

	local f

	local path = new()
	local name = GetOptionsMemberValue("name", options, options, path, appName)

	--If an optional path is specified add it to the path table before feeding the options
	--as container is optional as well it may contain the first element of the path
	if type(container) == "string" then
		tinsert(path, container)
		container = nil
	end
	BuildPath(path, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)

	local option = options
	if type(container) == "table" and container.type == "BlizOptionsGroup" and tgetn(path) > 0 then
		for i = 1, tgetn(path) do
			option = options.args[path[i]]
		end
		name = format("%s - %s", name, GetOptionsMemberValue("name", option, options, path, appName))
	end

	--if a container is given feed into that
	if container then
		f = container
		f:ReleaseChildren()
		f:SetUserData("appName", appName)
		f:SetUserData("iscustom", true)
		if tgetn(path) > 0 then
			f:SetUserData("basepath", copy(path))
		end
		local status = AceConfigDialog:GetStatusTable(appName)
		if not status.width then
			status.width =  700
		end
		if not status.height then
			status.height = 500
		end
		if f.SetStatusTable then
			f:SetStatusTable(status)
		end
		if f.SetTitle then
			f:SetTitle(name or "")
		end
	else
		if not self.OpenFrames[appName] then
			f = gui:Create("Frame")
			self.OpenFrames[appName] = f
		else
			f = self.OpenFrames[appName]
		end
		f:ReleaseChildren()
		f:SetCallback("OnClose", FrameOnClose)
		f:SetUserData("appName", appName)
		if tgetn(path) > 0 then
			f:SetUserData("basepath", copy(path))
		end
		f:SetTitle(name or "")
		local status = AceConfigDialog:GetStatusTable(appName)
		f:SetStatusTable(status)
	end

	self:FeedGroup(appName,options,f,f,path,true)
	if f.Show then
		f:Show()
	end
	del(path)

	if AceConfigDialog.frame.closeAll then
		-- close all is set, but thats not good, since we're just opening here, so force it
		AceConfigDialog.frame.closeAllOverride[appName] = true
	end
end

-- convert pre-39 BlizOptions structure to the new format
if oldminor and oldminor < 39 and AceConfigDialog.BlizOptions then
	local old = AceConfigDialog.BlizOptions
	local new = {}
	for key, widget in pairs(old) do
		local appName = widget:GetUserData("appName")
		if not new[appName] then new[appName] = {} end
		new[appName][key] = widget
	end
	AceConfigDialog.BlizOptions = new
else
	AceConfigDialog.BlizOptions = AceConfigDialog.BlizOptions or {}
end

local function FeedToBlizPanel(widget, event)
	local path = widget:GetUserData("path")
	AceConfigDialog:Open(widget:GetUserData("appName"), widget, unpack(path or emptyTbl))
end

local function ClearBlizPanel(widget, event)
	local appName = widget:GetUserData("appName")
	AceConfigDialog.frame.closing[appName] = true
	AceConfigDialog.frame:SetScript("OnUpdate", function() RefreshOnUpdate(this) end)
end

--- Add an option table into the Blizzard Interface Options panel.
-- You can optionally supply a descriptive name to use and a parent frame to use,
-- as well as a path in the options table.\\
-- If no name is specified, the appName will be used instead.
--
-- If you specify a proper `parent` (by name), the interface options will generate a
-- tree layout. Note that only one level of children is supported, so the parent always
-- has to be a head-level note.
--
-- This function returns a reference to the container frame registered with the Interface
-- Options. You can use this reference to open the options with the API function
-- `InterfaceOptionsFrame_OpenToCategory`.
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param name A descriptive name to display in the options tree (defaults to appName)
-- @param parent The parent to use in the interface options tree.
-- @param ... The path in the options table to feed into the interface options panel.
-- @return The reference to the frame registered into the Interface Options.
function AceConfigDialog:AddToBlizOptions(appName, name, parent, ...)
	local BlizOptions = AceConfigDialog.BlizOptions
	if not BlizOptions.tree then BlizOptions.tree = {} end

	local key = appName
	local l = tgetn(arg)
	for n = 1, l do
		key = key .. "\001" .. arg[n]
	end

	if not BlizOptions[appName] then
		BlizOptions[appName] = {}
	end

	if not BlizOptions[appName][key] then
		local group = gui:Create("BlizOptionsGroup")
		BlizOptions[appName][key] = group
		group:SetName(name or appName, parent)

		group:SetTitle(name or appName)
		group:SetUserData("appName", appName)
		if l > 0 then
			local path = {}
			for n = 1, l do
				tinsert(path, arg[n])
			end
			group:SetUserData("path", path)
		end
		group:SetCallback("OnShow", FeedToBlizPanel)
		group:SetCallback("OnHide", ClearBlizPanel)
		InterfaceOptions_AddCategory(group)
		return group.frame
	else
		error(format("%s has already been added to the Blizzard Options Window with the given path", appName), 2)
	end
end


	function InterfaceOptions_AddCategory(widget, addon, position)
		local parent = widget.frame.parent;
		local appName = widget:GetUserData("appName")
	local tree = AceConfigDialog.BlizOptions.tree
		if (parent) then
			for k, v in pairs(tree) do
				if (v.value == parent) then
					if not v.children then
						v.children = {}
					end
					tinsert(v.children, { value = widget.frame.name, text = widget.frame.name, frame = widget });
					return;
				end
			end
		end

		if (position) then
			tinsert(tree, position, { value = appName, text = widget.frame.name, frame = widget });
		else
			tinsert(tree, { value = appName, text = widget.frame.name, frame = widget });
		end
	end

	local function SelectTreeGroup(container, event, count, group)
		container:ReleaseChildren()
		local bg = gui:Create("BlizOptionsGroup")


		bg:SetCallback("OnShow", FeedToBlizPanel)
		bg:SetCallback("OnHide", ClearBlizPanel)
		local path = {}
		BuildPath(path, strsplit("\001", group))
		local node
		local app = tremove(path, 1)
		for k, v in pairs(container.tree) do
			if v.value == app then
				if table.getn(path) < 1 then
					node = v
				else
					for j, w in pairs(v.children) do

						if w.value == path[1] then
							node = w
							break;
						end
					end
				end
				break;
			end
		end
		bg:SetName(node.value, app)
		bg:SetTitle(node.frame.label:GetText())
		bg:SetUserData("appName", app)
		bg:SetUserData("path", node.frame:GetUserData("path"))
		bg.width = "fill"
		bg.height = "fill"
		container:AddChild(bg)
	end

	_G["AddonConfigFrame"] = _G["AddonConfigFrame"] or nil
	local frame
	function InterfaceOptionsFrame_OpenToCategory(...)
	local tree = AceConfigDialog.BlizOptions.tree
		-- Create the frame container
		frame = _G["AddonConfigFrame"] or gui:Create("Frame")
		_G["AddonConfigFrame"] = frame
		if frame:IsShown() then
			frame:ReleaseChildren()
		end
		frame:SetTitle("Addon's Configuration")
		frame:SetStatusText("Addons configuration panel")
		frame:SetCallback("OnClose", function(widget) gui:Release(widget); _G["AddonConfigFrame"] = nil end)
		frame:SetLayout("Flow")
		frame:SetWidth(850)
		-- Create the TreeGroup
		local tg = gui:Create("TreeGroup")
		tg:SetLayout("Flow")
		tg:SetTree(tree)
		--tg:SetWidth(320)
		tg.width = "fill"
		tg.height = "fill"
		tg:SetCallback("OnGroupSelected", SelectTreeGroup)
		frame:AddChild(tg)
		local l = tgetn(arg)
		local path = new()

		if l > 0 then
			for n = 1, l do
				tinsert(path, arg[n])
			end
		tg:SelectByPath(unpack(path))
		end
		del(path)
	end

================
File: Libs/vanilla/Ace3/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceConfigDialog-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.lua
================
--- AceConfigRegistry-3.0 handles central registration of options tables in use by addons and modules.\\
-- Options tables can be registered as raw tables, OR as function refs that return a table.\\
-- Such functions receive three arguments: "uiType", "uiName", "appName". \\
-- * Valid **uiTypes**: "cmd", "dropdown", "dialog". This is verified by the library at call time. \\
-- * The **uiName** field is expected to contain the full name of the calling addon, including version, e.g. "FooBar-1.0". This is verified by the library at call time.\\
-- * The **appName** field is the options table name as given at registration time \\
--
-- :IterateOptionsTables() (and :GetOptionsTable() if only given one argument) return a function reference that the requesting config handling addon must call with valid "uiType", "uiName".
-- @class file
-- @name AceConfigRegistry-3.0
-- @release $Id: AceConfigRegistry-3.0.lua 1139 2016-07-03 07:43:51Z nevcairiel $
local MAJOR, MINOR = "AceConfigRegistry-3.0", 16
local AceConfigRegistry = LibStub:NewLibrary(MAJOR, MINOR)

if not AceConfigRegistry then return end

AceConfigRegistry.tables = AceConfigRegistry.tables or {}

local CallbackHandler = LibStub:GetLibrary("CallbackHandler-1.0")

if not AceConfigRegistry.callbacks then
	AceConfigRegistry.callbacks = CallbackHandler:New(AceConfigRegistry)
end

-- Lua APIs
local tinsert, tconcat, tgetn = table.insert, table.concat, table.getn
local strfind = string.find
local type, tostring, pairs = type, tostring, pairs
local error, assert = error, assert

-----------------------------------------------------------------------
-- Validating options table consistency:


AceConfigRegistry.validated = {
	-- list of options table names ran through :ValidateOptionsTable automatically.
	-- CLEARED ON PURPOSE, since newer versions may have newer validators
	cmd = {},
	dropdown = {},
	dialog = {},
}

local function err(msg, errlvl, ...)
	local l = tgetn(arg)
	local i,j = 1,l
	while i < j do
		arg[i], arg[j] = arg[j], arg[i]
		i = i+1
		j = j-1
	end
	error(MAJOR..":ValidateOptionsTable(): "..tconcat(arg,".")..msg, errlvl+2)
end

local isstring={["string"]=true, _="string"}
local isstringfunc={["string"]=true,["function"]=true, _="string or funcref"}
local istable={["table"]=true,   _="table"}
local ismethodtable={["table"]=true,["string"]=true,["function"]=true,   _="methodname, funcref or table"}
local optstring={["nil"]=true,["string"]=true, _="string"}
local optstringfunc={["nil"]=true,["string"]=true,["function"]=true, _="string or funcref"}
local optstringnumberfunc={["nil"]=true,["string"]=true,["number"]=true,["function"]=true, _="string, number or funcref"}
local optnumber={["nil"]=true,["number"]=true, _="number"}
local optmethod={["nil"]=true,["string"]=true,["function"]=true, _="methodname or funcref"}
local optmethodfalse={["nil"]=true,["string"]=true,["function"]=true,["boolean"]={[false]=true},  _="methodname, funcref or false"}
local optmethodnumber={["nil"]=true,["string"]=true,["function"]=true,["number"]=true,  _="methodname, funcref or number"}
local optmethodtable={["nil"]=true,["string"]=true,["function"]=true,["table"]=true,  _="methodname, funcref or table"}
local optmethodbool={["nil"]=true,["string"]=true,["function"]=true,["boolean"]=true,  _="methodname, funcref or boolean"}
local opttable={["nil"]=true,["table"]=true,  _="table"}
local optbool={["nil"]=true,["boolean"]=true,  _="boolean"}
local optboolnumber={["nil"]=true,["boolean"]=true,["number"]=true,  _="boolean or number"}

local basekeys={
	type=isstring,
	name=isstringfunc,
	desc=optstringfunc,
	descStyle=optstring,
	order=optmethodnumber,
	validate=optmethodfalse,
	confirm=optmethodbool,
	confirmText=optstring,
	disabled=optmethodbool,
	hidden=optmethodbool,
		guiHidden=optmethodbool,
		dialogHidden=optmethodbool,
		dropdownHidden=optmethodbool,
	cmdHidden=optmethodbool,
	icon=optstringnumberfunc,
	iconCoords=optmethodtable,
	handler=opttable,
	get=optmethodfalse,
	set=optmethodfalse,
	func=optmethodfalse,
	arg={["*"]=true},
	width=optstring,
}

local typedkeys={
	header={},
	description={
		image=optstringnumberfunc,
		imageCoords=optmethodtable,
		imageHeight=optnumber,
		imageWidth=optnumber,
		fontSize=optstringfunc,
	},
	group={
		args=istable,
		plugins=opttable,
		inline=optbool,
			cmdInline=optbool,
			guiInline=optbool,
			dropdownInline=optbool,
			dialogInline=optbool,
		childGroups=optstring,
	},
	execute={
		image=optstringnumberfunc,
		imageCoords=optmethodtable,
		imageHeight=optnumber,
		imageWidth=optnumber,
	},
	input={
		pattern=optstring,
		usage=optstring,
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
		multiline=optboolnumber,
		nullable=optbool,
	},
	toggle={
		tristate=optbool,
		image=optstringnumberfunc,
		imageCoords=optmethodtable,
	},
	tristate={
	},
	range={
		min=optnumber,
		softMin=optnumber,
		max=optnumber,
		softMax=optnumber,
		step=optnumber,
		bigStep=optnumber,
		isPercent=optbool,
	},
	select={
		values=ismethodtable,
		valuesTableDestroyable=optbool,	-- Ace3v: if the values table is generated by AceCore.new
		style={
			["nil"]=true,
			["string"]={dropdown=true,radio=true},
			_="string: 'dropdown' or 'radio'"
		},
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
		itemControl=optstring,
	},
	multiselect={
		values=ismethodtable,
		valuesTableDestroyable=optbool,	-- Ace3v: if the values table is generated by AceCore.new
		style=optstring,
		tristate=optbool,
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
	},
	color={
		hasAlpha=optmethodbool,
	},
	keybinding={
		-- TODO
	},
}

local function validateKey(k,errlvl,arg)
	errlvl=(errlvl or 0)+1
	if type(k)~="string" then
		err("["..tostring(k).."] - key is not a string", errlvl, arg)
	end
	if strfind(k, "[%c\127]") then
		err("["..tostring(k).."] - key name contained control characters", errlvl, arg)
	end
end

local function validateVal(v, oktypes, errlvl, arg)
	errlvl=(errlvl or 0)+1
	local isok=oktypes[type(v)] or oktypes["*"]

	if not isok then
		err(": expected a "..oktypes._..", got '"..tostring(v).."'", errlvl, arg)
	end
	if type(isok)=="table" then		-- isok was a table containing specific values to be tested for!
		if not isok[v] then
			err(": did not expect "..type(v).." value '"..tostring(v).."'", errlvl, arg)
		end
	end
end

local function validate(options,errlvl,arg)
	errlvl=(errlvl or 0)+1
	-- basic consistency
	if type(options)~="table" then
		err(": expected a table, got a "..type(options), errlvl, arg)
	end
	if type(options.type)~="string" then
		err(".type: expected a string, got a "..type(options.type), errlvl, arg)
	end

	-- get type and 'typedkeys' member
	local tk = typedkeys[options.type]
	if not tk then
		err(".type: unknown type '"..options.type.."'", errlvl, arg)
	end

	-- make sure that all options[] are known parameters
	for k,v in pairs(options) do
		if not (tk[k] or basekeys[k]) then
			err(": unknown parameter", errlvl,tostring(k), arg)
		end
	end

	-- verify that required params are there, and that everything is the right type
	for k,oktypes in pairs(basekeys) do
		validateVal(options[k], oktypes, errlvl, k, arg)
	end
	for k,oktypes in pairs(tk) do
		validateVal(options[k], oktypes, errlvl, k, arg)
	end

	-- extra logic for groups
	if options.type=="group" then
		for k,v in pairs(options.args) do
			validateKey(k,errlvl,"args", arg)
			validate(v, errlvl,k,"args", arg)
		end
		if options.plugins then
			for plugname,plugin in pairs(options.plugins) do
				if type(plugin)~="table" then
					err(": expected a table, got '"..tostring(plugin).."'", errlvl,tostring(plugname), "plugins", arg)
				end
				for k,v in pairs(plugin) do
					validateKey(k,errlvl,tostring(plugname),"plugins",arg)
					validate(v, errlvl,k,tostring(plugname),"plugins",arg)
				end
			end
		end
	end
end


--- Validates basic structure and integrity of an options table \\
-- Does NOT verify that get/set etc actually exist, since they can be defined at any depth
-- @param options The table to be validated
-- @param name The name of the table to be validated (shown in any error message)
-- @param errlvl (optional number) error level offset, default 0 (=errors point to the function calling :ValidateOptionsTable)
function AceConfigRegistry:ValidateOptionsTable(options,name,errlvl)
	errlvl=(errlvl or 0)+1
	name = name or "Optionstable"
	if not options.name then
		options.name=name	-- bit of a hack, the root level doesn't really need a .name :-/
	end
	validate(options,errlvl,name)
end

--- Fires a "ConfigTableChange" callback for those listening in on it, allowing config GUIs to refresh.
-- You should call this function if your options table changed from any outside event, like a game event
-- or a timer.
-- @param appName The application name as given to `:RegisterOptionsTable()`
function AceConfigRegistry:NotifyChange(appName)
	if not AceConfigRegistry.tables[appName] then return end
	AceConfigRegistry.callbacks:Fire("ConfigTableChange", 1, appName)
end

-- -------------------------------------------------------------------
-- Registering and retreiving options tables:


-- validateGetterArgs: helper function for :GetOptionsTable (or, rather, the getter functions returned by it)

local function validateGetterArgs(uiType, uiName, errlvl)
	errlvl=(errlvl or 0)+2
	if uiType~="cmd" and uiType~="dropdown" and uiType~="dialog" then
		error(MAJOR..": Requesting options table: 'uiType' - invalid configuration UI type, expected 'cmd', 'dropdown' or 'dialog'", errlvl)
	end
	if not strfind(uiName, "[A-Za-z]+-[0-9]") then	-- Expecting e.g. "MyLib-1.2"
		error(MAJOR..": Requesting options table: 'uiName' - badly formatted or missing version number. Expected e.g. 'MyLib-1.2'", errlvl)
	end
end

--- Register an options table with the config registry.
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param options The options table, OR a function reference that generates it on demand. \\
-- See the top of the page for info on arguments passed to such functions.
-- @param skipValidation Skip options table validation (primarily useful for extremely huge options, with a noticeable slowdown)
function AceConfigRegistry:RegisterOptionsTable(appName, options, skipValidation)
	if type(options)=="table" then
		if options.type~="group" then	-- quick sanity checker
			error(MAJOR..": RegisterOptionsTable(appName, options): 'options' - missing type='group' member in root group", 2)
		end
		AceConfigRegistry.tables[appName] = function(uiType, uiName, errlvl)
			errlvl=(errlvl or 0)+1
			validateGetterArgs(uiType, uiName, errlvl)
			if not AceConfigRegistry.validated[uiType][appName] and not skipValidation then
				AceConfigRegistry:ValidateOptionsTable(options, appName, errlvl)	-- upgradable
				AceConfigRegistry.validated[uiType][appName] = true
			end
			return options
		end
	elseif type(options)=="function" then
		AceConfigRegistry.tables[appName] = function(uiType, uiName, errlvl)
			errlvl=(errlvl or 0)+1
			validateGetterArgs(uiType, uiName, errlvl)
			local tab = assert(options(uiType, uiName, appName))
			if not AceConfigRegistry.validated[uiType][appName] and not skipValidation then
				AceConfigRegistry:ValidateOptionsTable(tab, appName, errlvl)	-- upgradable
				AceConfigRegistry.validated[uiType][appName] = true
			end
			return tab
		end
	else
		error(MAJOR..": RegisterOptionsTable(appName, options): 'options' - expected table or function reference", 2)
	end
end

--- Returns an iterator of ["appName"]=funcref pairs
function AceConfigRegistry:IterateOptionsTables()
	return pairs(AceConfigRegistry.tables)
end




--- Query the registry for a specific options table.
-- If only appName is given, a function is returned which you
-- can call with (uiType,uiName) to get the table.\\
-- If uiType&uiName are given, the table is returned.
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param uiType The type of UI to get the table for, one of "cmd", "dropdown", "dialog"
-- @param uiName The name of the library/addon querying for the table, e.g. "MyLib-1.0"
function AceConfigRegistry:GetOptionsTable(appName, uiType, uiName)
	local f = AceConfigRegistry.tables[appName]
	if not f then
		return nil
	end

	if uiType then
		return f(uiType,uiName,1)	-- get the table for us
	else
		return f	-- return the function
	end
end

================
File: Libs/vanilla/Ace3/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceConfigRegistry-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceConsole-3.0/AceConsole-3.0.lua
================
--- **AceConsole-3.0** provides registration facilities for slash commands.
-- You can register slash commands to your custom functions and use the `GetArgs` function to parse them
-- to your addons individual needs.
--
-- **AceConsole-3.0** can be embeded into your addon, either explicitly by calling AceConsole:Embed(MyAddon) or by
-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
-- and can be accessed directly, without having to explicitly call AceConsole itself.\\
-- It is recommended to embed AceConsole, otherwise you'll have to specify a custom `self` on all calls you
-- make into AceConsole.
-- @class file
-- @name AceConsole-3.0
-- @release $Id: AceConsole-3.0.lua 1143 2016-07-11 08:52:03Z nevcairiel $
local MAJOR,MINOR = "AceConsole-3.0", 7

local AceConsole, oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceConsole then return end -- No upgrade needed

local AceCore = LibStub("AceCore-3.0")

AceConsole.embeds = AceConsole.embeds or {} -- table containing objects AceConsole is embedded in.
AceConsole.commands = AceConsole.commands or {} -- table containing commands registered
AceConsole.weakcommands = AceConsole.weakcommands or {} -- table containing self, command => func references for weak commands that don't persist through enable/disable

-- Lua APIs
local tinsert, tconcat, tgetn, tsetn = table.insert, table.concat, table.getn, table.setn
local tostring = tostring
local type, pairs, error = type, pairs, error
local format, strfind, strsub = string.format, string.find, string.sub
local max = math.max
local strupper, strlower = string.upper, string.lower

-- WoW APIs
local _G = AceCore._G

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: DEFAULT_CHAT_FRAME, SlashCmdList, hash_SlashCmdList
local Print
do
local tmp = {}
function Print(self, frame, arg)
	if self ~= AceConsole then
		tmp[1] = "|cff33ff99"..tostring(self).."|r:"
	else
		tmp[1] = ''
	end
	if type(arg) == "string" then
		frame:AddMessage(tmp[1]..arg)
	else	-- arg is table and may contain frame as first element if argument frame is nil
		local b, e = frame and 1 or 2, tgetn(arg)
		if e >= b then
			frame = frame or arg[1]
			for i=0,e-b do
				tmp[2+i] = tostring(arg[b+i])
			end
			frame:AddMessage(tconcat(tmp," ",1,e-b+2)) -- explicitly, because the length is not affected by assignment
		end
	end
end
end	-- Print

--- Print to DEFAULT_CHAT_FRAME or given ChatFrame (anything with an .AddMessage function)
-- @paramsig [chatframe ,] ...
-- @param chatframe Custom ChatFrame to print to (or any frame with an .AddMessage function)
-- @param ... List of any values to be printed
function AceConsole:Print(...)
	local frame = arg[1]
	if type(frame) == "table" and frame.AddMessage then	-- Is first argument something with an .AddMessage member?
		return Print(self, nil, arg)
	else
		return Print(self, DEFAULT_CHAT_FRAME, arg)
	end
end

--- Formatted (using format()) print to DEFAULT_CHAT_FRAME or given ChatFrame (anything with an .AddMessage function)
-- @paramsig [chatframe ,] "format"[, ...]
-- @param chatframe Custom ChatFrame to print to (or any frame with an .AddMessage function)
-- @param format Format string - same syntax as standard Lua format()
-- @param ... Arguments to the format string
function AceConsole:Printf(a1, ...)
	local frame, succ, s
	if type(a1) == "table" and a1.AddMessage then	-- Is first argument something with an .AddMessage member?
		frame, succ, s = a1, pcall(format, unpack(arg))
	else
		frame, succ, s = DEFAULT_CHAT_FRAME, pcall(format, a1, unpack(arg))
	end
	if not succ then error(s,2) end
	return Print(self, frame, s)
end





--- Register a simple chat command
-- @param command Chat command to be registered WITHOUT leading "/"
-- @param func Function to call when the slash command is being used (funcref or methodname)
-- @param persist if false, the command will be soft disabled/enabled when aceconsole is used as a mixin (default: true)
function AceConsole:RegisterChatCommand( command, func, persist )
	if type(command)~="string" then error([[Usage: AceConsole:RegisterChatCommand(command, func[, persist ]): 'command' - expected a string]], 2) end

	if persist==nil then persist=true end	-- I'd rather have my addon's "/addon enable" around if the author screws up. Having some extra slash regged when it shouldnt be isn't as destructive. True is a better default. /Mikk

	local name = "ACECONSOLE_"..strupper(command)

	local t = type(func)

	if t  == "string" then
		-- Ace3v: prevent user from using AceConSole as self
		if self == AceConsole then
			error([[Usage: RegisterChatCommand(command, func[, persist]): 'self' - use your own 'self']], 2)
		end
		SlashCmdList[name] = function(input, editBox)
			self[func](self, input, editBox)
		end
	elseif t == "function" then
		SlashCmdList[name] = func
	else
		error([[Usage: AceConsole:RegisterChatCommand(command, func[, persist ]): 'func' - expected a string or a function]], 2)
	end
	_G["SLASH_"..name.."1"] = "/"..strlower(command)
	AceConsole.commands[command] = name
	-- non-persisting commands are registered for enabling disabling
	if not persist then
		if not AceConsole.weakcommands[self] then AceConsole.weakcommands[self] = {} end
		AceConsole.weakcommands[self][command] = func
	end
	return true
end

--- Unregister a chatcommand
-- @param command Chat command to be unregistered WITHOUT leading "/"
function AceConsole:UnregisterChatCommand( command )
	local name = AceConsole.commands[command]
	if name then
		SlashCmdList[name] = nil
		_G["SLASH_" .. name .. "1"] = nil
		AceConsole.commands[command] = nil
	end
end

--- Get an iterator over all Chat Commands registered with AceConsole
-- @return Iterator (pairs) over all commands
function AceConsole:IterateChatCommands() return pairs(AceConsole.commands) end

local function nils(n,argc,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	if n >= 1 then
		return nil, nils(n-1,argc,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	elseif not argc or argc == 0 then
		return
	else
		return a1, nils(0,argc-1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	end
end

--- Retreive one or more space-separated arguments from a string.
-- Treats quoted strings and itemlinks as non-spaced.
-- @param str The raw argument string
-- @param numargs How many arguments to get (default 1)
-- @param startpos Where in the string to start scanning (default  1)
-- @return Returns arg1, arg2, ..., nextposition\\
-- Missing arguments will be returned as nils. 'nextposition' is returned as 1e9 at the end of the string.
function AceConsole:GetArgs(str, numargs, startpos)
	numargs = numargs or 1
	startpos = max(startpos or 1, 1)

	local pos=startpos

	-- find start of new arg
	pos = strfind(str, "[^ ]", pos)
	if not pos then	-- whoops, end of string
		return nils(numargs, 1, 1e9)
	end

	if numargs<1 then
		return pos
	end

	-- quoted or space separated? find out which pattern to use
	local delim_or_pipe
	local ch = strsub(str, pos, pos)
	if ch=='"' then
		pos = pos + 1
		delim_or_pipe='([|"])'
	elseif ch=="'" then
		pos = pos + 1
		delim_or_pipe="([|'])"
	else
		delim_or_pipe="([| ])"
	end

	startpos = pos

	while true do
		-- find delimiter or hyperlink
		local ch,_
		pos,_,ch = strfind(str, delim_or_pipe, pos)

		if not pos then break end

		if ch=="|" then
			-- some kind of escape

			if strsub(str,pos,pos+1)=="|H" then
				-- It's a |H....|hhyper link!|h
				pos=strfind(str, "|h", pos+2)	-- first |h
				if not pos then break end

				pos=strfind(str, "|h", pos+2)	-- second |h
				if not pos then break end
			elseif strsub(str,pos, pos+1) == "|T" then
				-- It's a |T....|t  texture
				pos=strfind(str, "|t", pos+2)
				if not pos then break end
			end

			pos=pos+2 -- skip past this escape (last |h if it was a hyperlink)

		else
			-- found delimiter, done with this arg
			return strsub(str, startpos, pos-1), AceConsole:GetArgs(str, numargs-1, pos+1)
		end

	end

	-- search aborted, we hit end of string. return it all as one argument. (yes, even if it's an unterminated quote or hyperlink)
	return strsub(str, startpos), nils(numargs-1, 1, 1e9)
end


--- embedding and embed handling

local mixins = {
	"Print",
	"Printf",
	"RegisterChatCommand",
	"UnregisterChatCommand",
	"GetArgs",
}

-- Embeds AceConsole into the target object making the functions from the mixins list available on target:..
-- @param target target object to embed AceBucket in
function AceConsole:Embed( target )
	for k, v in pairs( mixins ) do
		target[v] = self[v]
	end
	self.embeds[target] = true
	return target
end

function AceConsole:OnEmbedEnable( target )
	if AceConsole.weakcommands[target] then
		for command, func in pairs( AceConsole.weakcommands[target] ) do
			target:RegisterChatCommand( command, func, false, true ) -- nonpersisting and silent registry
		end
	end
end

function AceConsole:OnEmbedDisable( target )
	if AceConsole.weakcommands[target] then
		for command, func in pairs( AceConsole.weakcommands[target] ) do
			target:UnregisterChatCommand( command ) -- TODO: this could potentially unregister a command from another application in case of command conflicts. Do we care?
		end
	end
end

for addon in pairs(AceConsole.embeds) do
	AceConsole:Embed(addon)
end

================
File: Libs/vanilla/Ace3/AceConsole-3.0/AceConsole-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceConsole-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceCore-3.0/AceCore-3.0.lua
================
local ACECORE_MAJOR, ACECORE_MINOR = "AceCore-3.0", 2
local AceCore, oldminor = LibStub:NewLibrary(ACECORE_MAJOR, ACECORE_MINOR)

if not AceCore then return end -- No upgrade needed

AceCore._G = AceCore._G or getfenv()
local _G = AceCore._G
local strsub, strgsub, strfind = string.sub, string.gsub, string.find
local tremove, tconcat = table.remove, table.concat
local tgetn, tsetn = table.getn, table.setn

local new, del
do
local list = setmetatable({}, {__mode = "k"})
function new()
	local t = next(list)
	if not t then
		return {}
	end
	list[t] = nil
	return t
end

function del(t)
	setmetatable(t, nil)
	for k in pairs(t) do
		t[k] = nil
	end
	tsetn(t,0)
	list[t] = true
end

print = print or function(text)
	DEFAULT_CHAT_FRAME:AddMessage(text)
end

-- debug
function AceCore.listcount()
	local count = 0
	for k in list do
		count = count + 1
	end
	return count
end
end	-- AceCore.new, AceCore.del
AceCore.new, AceCore.del = new, del

local function errorhandler(err)
	return geterrorhandler()(err)
end
AceCore.errorhandler = errorhandler

local function CreateSafeDispatcher(argCount)
	local code = [[
		local errorhandler = LibStub("AceCore-3.0").errorhandler
		local method, UP_ARGS
		local function call()
			local func, ARGS = method, UP_ARGS
			method, UP_ARGS = nil, NILS
			return func(ARGS)
		end
		return function(func, ARGS)
			method, UP_ARGS = func, ARGS
			return xpcall(call, errorhandler)
		end
	]]
	local c = 4*argCount-1
	local s = "b01,b02,b03,b04,b05,b06,b07,b08,b09,b10,b11,b12,b13,b14,b15,b16,b17,b18,b19,b20"
	code = strgsub(code, "UP_ARGS", string.sub(s,1,c))
	s = "a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20"
	code = strgsub(code, "ARGS", string.sub(s,1,c))
	s = "nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil"
	code = strgsub(code, "NILS", string.sub(s,1,c))
	return assert(loadstring(code, "safecall SafeDispatcher["..tostring(argCount).."]"))()
end

local SafeDispatchers = setmetatable({}, {__index=function(self, argCount)
	local dispatcher
	if not tonumber(argCount) then dbg(debugstack()) end
	if argCount > 0 then
		dispatcher = CreateSafeDispatcher(argCount)
	else
		dispatcher = function(func) return xpcall(func,errorhandler) end
	end
	rawset(self, argCount, dispatcher)
	return dispatcher
end})

local function safecall(func,argc,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20)
	-- we check to see if the func is passed is actually a function here and don't error when it isn't
	-- this safecall is used for optional functions like OnInitialize OnEnable etc. When they are not
	-- present execution should continue without hinderance
	if type(func) == "function" then
		return SafeDispatchers[argc](func,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20)
	end
end
AceCore.safecall = safecall

local function CreateDispatcher(argCount)
	local code = [[
		return function(func,ARGS)
			return func(ARGS)
		end
	]]
	local s = "a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20"
	code = strgsub(code, "ARGS", string.sub(s,1,4*argCount-1))
	return assert(loadstring(code, "call Dispatcher["..tostring(argCount).."]"))()
end

AceCore.Dispatchers = setmetatable({}, {__index=function(self, argCount)
	local dispatcher
	if argCount > 0 then
		dispatcher = CreateDispatcher(argCount)
	else
		dispatcher = function(func) return func() end
	end
	rawset(self, argCount, dispatcher)
	return dispatcher
end})

-- some string functions
-- vanilla available string operations:
--    sub, gfind, rep, gsub, char, dump, find, upper, len, format, byte, lower
-- we will just replace every string.match with string.find in the code
function AceCore.strtrim(s)
	return strgsub(s, "^%s*(.-)%s*$", "%1")
end

local function strsplit(delim, s, n)
	if n and n < 2 then return s end
	beg = beg or 1
	local i,j = string.find(s,delim,beg)
	if not i then
		return s, nil
	end
	return string.sub(s,1,j-1), strsplit(delim, string.sub(s,j+1), n and n-1 or nil)
end
AceCore.strsplit = strsplit

-- Ace3v: fonctions copied from AceHook-2.1
local protFuncs = {
	CameraOrSelectOrMoveStart = true, 	CameraOrSelectOrMoveStop = true,
	TurnOrActionStart = true,			TurnOrActionStop = true,
	PitchUpStart = true,				PitchUpStop = true,
	PitchDownStart = true,				PitchDownStop = true,
	MoveBackwardStart = true,			MoveBackwardStop = true,
	MoveForwardStart = true,			MoveForwardStop = true,
	Jump = true,						StrafeLeftStart = true,
	StrafeLeftStop = true,				StrafeRightStart = true,
	StrafeRightStop = true,				ToggleMouseMove = true,
	ToggleRun = true,					TurnLeftStart = true,
	TurnLeftStop = true,				TurnRightStart = true,
	TurnRightStop = true,
}

local function issecurevariable(x)
	return protFuncs[x] and 1 or nil
end
AceCore.issecurevariable = issecurevariable

local function hooksecurefunc(arg1, arg2, arg3)
	if type(arg1) == "string" then
		arg1, arg2, arg3 = _G, arg1, arg2
	end
	local orig = arg1[arg2]
	if type(orig) ~= "function" then
		error("The function "..arg2.." does not exist", 2)
	end
	arg1[arg2] = function(...)
		local tmp = {orig(unpack(arg))}
		arg3(unpack(arg))
		return unpack(tmp)
	end
end
AceCore.hooksecurefunc = hooksecurefunc

-- pickfirstset() - picks the first non-nil value and returns it
local function pickfirstset(argc,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	if (argc <= 1) or (a1 ~= nil) then
		return a1
	else
		return pickfirstset(argc-1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	end
end
AceCore.pickfirstset = pickfirstset

local function countargs(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	if (a1 == nil) then return 0 end
	return 1 + countargs(a2,a3,a4,a5,a6,a7,a8,a9,a10)
end
AceCore.countargs = countargs

-- wipe preserves metatable
function AceCore.wipe(t)
	for k,v in pairs(t) do t[k] = nil end
	tsetn(t,0)
	return t
end

function AceCore.truncate(t,e)
	e = e or tgetn(t)
	for i=1,e do
		if t[i] == nil then
			tsetn(t,i-1)
			return
		end
	end
	tsetn(t,e)
end

================
File: Libs/vanilla/Ace3/AceCore-3.0/AceCore-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceCore-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceCursor-3.0/AceCursor-3.0.lua
================
local ACECURSOR_MAJOR, ACECURSOR_MINOR = "AceCursor-3.0", 4
local AceCursor, oldminor = LibStub:NewLibrary(ACECURSOR_MAJOR, ACECURSOR_MINOR)

if not AceCursor then return end -- No upgrade needed

local AceCore = LibStub("AceCore-3.0")
local _G = AceCore._G
local hooksecurefunc = AceCore.hooksecurefunc

local ttName = "AceCursorTT"
local tt = CreateFrame("GameTooltip", ttName, nil, "GameTooltipTemplate")
tt:SetOwner(WorldFrame,"ANCHOR_NONE")
tt:SetScript("OnHide", function ()
    this:SetOwner(WorldFrame,"ANCHOR_NONE")
  end)
AceCursor.tooltip = tt

local cursorType, cursorData, cursorSubType, cursorSubData
function _G.GetCursorInfo()
	return cursorType, cursorData, cursorSubType, cursorSubData
end

local function setcursoritem(link)
	local _,_,id = strfind(link,"|Hitem:(%d+):")
	cursorType = "item"
	cursorData = tonumber(id)
	cursorSubType = link
	cursorSubData = nil
end

-- ClearCursor
if not AceCore_ClearCursor then
	hooksecurefunc("ClearCursor", function()
		return _G.AceCore_ClearCursor()
	end)
end

function _G.AceCore_ClearCursor()
	cursorType, cursorData, cursorSubType, cursorSubData = nil,nil,nil,nil
end

-- PickupContainerItem
if not AceCore_PickupContainerItem then
	hooksecurefunc("PickupContainerItem",
		function(container, slot)
			return _G.AceCore_PickupContainerItem(container, slot)
		end)
end

function _G.AceCore_PickupContainerItem(container, slot)
	if CursorHasItem() then
		return setcursoritem(GetContainerItemLink(container, slot))
	end
end

-- PickupInventoryItem
if not AceCore_PickupInventoryItem then
	hooksecurefunc("PickupInventoryItem",
		function(slot)
			return _G.AceCore_PickupInventoryItem(slot)
		end)
end

function _G.AceCore_PickupInventoryItem(slot)
	if CursorHasItem() then
		return setcursoritem(GetInventoryItemLink("player", slot))
	else
		cursorType, cursorData, cursorSubType, cursorSubData = nil,nil,nil,nil
	end
end

-- EquipCursorItem
if not _G.AceCore_EquipCursorItem then
	hooksecurefunc("EquipCursorItem",
		function(slot)
			return _G.AceCore_EquipCursorItem(slot)
		end)
end

function _G.AceCore_EquipCursorItem(slot)
		cursorType, cursorData, cursorSubType, cursorSubData = nil,nil,nil,nil
end

-- PickupBagFromSlot
if not _G.AceCore_PickupBagFromSlot then
	hooksecurefunc("PickupBagFromSlot",
		function(inventoryID)
			return _G.AceCore_PickupBagFromSlot(inventoryID)
		end)
end

function _G.AceCore_PickupBagFromSlot(inventoryID)
	return setcursoritem(GetInventoryItemLink("player", inventoryID))
end

-- PutItemInBag
if not _G.AceCore_PutItemInBag then
	hooksecurefunc("PutItemInBag",
		function(inventoryID)
			return _G.AceCore_PutItemInBag(inventoryID)
		end)
end

function _G.AceCore_PutItemInBag(inventoryID)
	cursorType, cursorData, cursorSubType, cursorSubData = nil,nil,nil,nil
end

-- PickupSpell
if not _G.AceCore_PickupSpell then
	hooksecurefunc("PickupSpell",
		function(spellbookID, bookType)
			return _G.AceCore_PickupSpell(spellbookID, bookType)
		end)
end

function _G.AceCore_PickupSpell(spellbookID, bookType)
	cursorType = "spell"
	cursorData = spellbookID
	cursorSubType = bookType
	cursorSubData = nil	-- Ace3v: how to get spellID?
end

-- PickupMacro
if not _G.AceCore_PickupMacro then
	hooksecurefunc("PickupMacro",
		function(macroID)
			return _G.AceCore_PickupMacro(macroID)
		end)
end

function _G.AceCore_PickupMacro(macroID)
	cursorType = "macro"
	cursorData = macroID
	cursorSubType = nil
	cursorSubData = nil
end

--[[------------------------------------
The Action part is not fully working yet
--------------------------------------]]
-- PickupAction
if not _G.AceCore_PickupAction then
	hooksecurefunc("PickupAction",
		function(slot)
			return _G.AceCore_PickupAction(slot)
		end)
end

function _G.AceCore_PickupAction(slot)
	-- cursorType = "action"
	-- cursorData = slot
	-- cursorSubType = nil
	-- cursorSubData = nil
end

-- PlaceAction
if not _G.AceCore_PlaceAction then
	hooksecurefunc("PlaceAction",
		function(slot)
			return _G.AceCore_PlaceAction(slot)
		end)
end

function _G.AceCore_PlaceAction(slot)
	cursorType, cursorData, cursorSubType, cursorSubData = nil,nil,nil,nil
end

local function setcursoraction(id)
	AceCursor.tooltip:SetOwner(UIParent, "ANCHOR_NONE")
	AceCursor.tooltip:ClearLines()
	AceCursor.tooltip:SetAction(id)
	cursorType = "action"
	cursorData = getglobal(ttName .."TextLeft1"):GetText()
	AceCursor.tooltip:Hide()
	cursorSubType = GetActionTexture(id)
	cursorSubData = id
end

local function setcursorpetaction(id)
	AceCursor.tooltip:SetOwner(UIParent, "ANCHOR_NONE")
	AceCursor.tooltip:ClearLines()
	AceCursor.tooltip:SetPetAction(id)
	cursorType = "petaction"
	cursorData = getglobal(ttName .."TextLeft1"):GetText()
	AceCursor.tooltip:Hide()
	local name, subtext, texture, isToken, isActive, autoCastAllowed, autoCastEnabled = GetPetActionInfo(id);
	cursorSubType = texture
	cursorSubData = id
end

local function ActionButton_OnClick()
	local id = ActionButton_GetPagedID(this)
	if ( IsShiftKeyDown() ) then
		setcursoraction(id)
		PickupAction(id)
	else
		if ( MacroFrame_SaveMacro ) then
			MacroFrame_SaveMacro();
		end
		UseAction(id, 1);
	end
	ActionButton_UpdateState();
end

local function ActionButton_OnDragStart()
	if ( LOCK_ACTIONBAR ~= "1" ) then
		local id = ActionButton_GetPagedID(this)
		setcursoraction(id)
		PickupAction(id);
		ActionButton_UpdateHotkeys(this.buttonType);
		ActionButton_UpdateState();
		ActionButton_UpdateFlash();
	end
end

local function ActionButton_OnReceiveDrag()
	if ( LOCK_ACTIONBAR ~= "1" ) then
		PlaceAction(ActionButton_GetPagedID(this));
		ActionButton_UpdateHotkeys(this.buttonType);
		ActionButton_UpdateState();
		ActionButton_UpdateFlash();
	end
end

local actionButtons = {
	"ActionButton",
	"BonusActionButton",
	"MultiBarLeftButton",
	"MultiBarRightButton",
	"MultiBarBottomLeftButton",
	"MultiBarBottomRightButton",
}

for _,btn in actionButtons do
	for i=1,12 do
		local frame = _G[btn..i]
		frame:SetScript("OnDragStart",ActionButton_OnDragStart)
		frame:SetScript("OnReceiveDrag",ActionButton_OnReceiveDrag)
		frame:SetScript("OnClick",ActionButton_OnClick)
	end
end

local function PetActionButton_OnClick()
	this:SetChecked(0);
	local id = this:GetID()
	if ( IsShiftKeyDown() ) then
		setcursorpetaction(id)
		PickupPetAction(id)
	else
		if ( arg1 == "LeftButton" ) then
			if ( IsPetAttackActive(id) ) then
				PetStopAttack();
			else
				CastPetAction(id);
			end
		else
			TogglePetAutocast(id);
		end
	end
end

local function PetActionButton_OnDragStart()
	if ( LOCK_ACTIONBAR ~= "1" ) then
		local id = this:GetID()
		setcursorpetaction(id)
		this:SetChecked(0);
		PickupPetAction(id);
		PetActionBar_Update();
	end
end

local function PetActionButton_OnReceiveDrag()
	if ( LOCK_ACTIONBAR ~= "1" ) then
		this:SetChecked(0);
		PickupPetAction(this:GetID());
		PetActionBar_Update();
	end
end

for i=1,10 do
	local frame = _G["PetActionButton"..i]
	frame:SetScript("OnDragStart",PetActionButton_OnDragStart)
	frame:SetScript("OnReceiveDrag",PetActionButton_OnReceiveDrag)
	frame:SetScript("OnClick",PetActionButton_OnClick)
end

================
File: Libs/vanilla/Ace3/AceCursor-3.0/AceCursor-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceCursor-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceDB-3.0/AceDB-3.0.lua
================
--- **AceDB-3.0** manages the SavedVariables of your addon.
-- It offers profile management, smart defaults and namespaces for modules.\\
-- Data can be saved in different data-types, depending on its intended usage.
-- The most common data-type is the `profile` type, which allows the user to choose
-- the active profile, and manage the profiles of all of his characters.\\
-- The following data types are available:
-- * **char** Character-specific data. Every character has its own database.
-- * **realm** Realm-specific data. All of the players characters on the same realm share this database.
-- * **class** Class-specific data. All of the players characters of the same class share this database.
-- * **race** Race-specific data. All of the players characters of the same race share this database.
-- * **faction** Faction-specific data. All of the players characters of the same faction share this database.
-- * **factionrealm** Faction and realm specific data. All of the players characters on the same realm and of the same faction share this database.
-- * **locale** Locale specific data, based on the locale of the players game client.
-- * **global** Global Data. All characters on the same account share this database.
-- * **profile** Profile-specific data. All characters using the same profile share this database. The user can control which profile should be used.
--
-- Creating a new Database using the `:New` function will return a new DBObject. A database will inherit all functions
-- of the DBObjectLib listed here. \\
-- If you create a new namespaced child-database (`:RegisterNamespace`), you'll get a DBObject as well, but note
-- that the child-databases cannot individually change their profile, and are linked to their parents profile - and because of that,
-- the profile related APIs are not available. Only `:RegisterDefaults` and `:ResetProfile` are available on child-databases.
--
-- For more details on how to use AceDB-3.0, see the [[AceDB-3.0 Tutorial]].
--
-- You may also be interested in [[libdualspec-1-0|LibDualSpec-1.0]] to do profile switching automatically when switching specs.
--
-- @usage
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("DBExample")
--
-- -- declare defaults to be used in the DB
-- local defaults = {
--   profile = {
--     setting = true,
--   }
-- }
--
-- function MyAddon:OnInitialize()
--   -- Assuming the .toc says ## SavedVariables: MyAddonDB
--   self.db = LibStub("AceDB-3.0"):New("MyAddonDB", defaults, true)
-- end
-- @class file
-- @name AceDB-3.0.lua
-- @release $Id: AceDB-3.0.lua 1142 2016-07-11 08:36:19Z nevcairiel $
local ACEDB_MAJOR, ACEDB_MINOR = "AceDB-3.0", 26
local AceDB, oldminor = LibStub:NewLibrary(ACEDB_MAJOR, ACEDB_MINOR)

if not AceDB then return end -- No upgrade needed

local AceCore = LibStub("AceCore-3.0")
local new, del = AceCore.new, AceCore.del

-- Lua APIs
local type, pairs, next, error = type, pairs, next, error
local setmetatable, getmetatable, rawset, rawget = setmetatable, getmetatable, rawset, rawget

-- WoW APIs
local _G = AceCore._G

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: LibStub

AceDB.db_registry = AceDB.db_registry or {}
AceDB.frame = AceDB.frame or CreateFrame("Frame")

local CallbackHandler
local CallbackDummy = { Fire = function() end }

local DBObjectLib = {}

-- Ace3v: for all recursive functions we must declare the iterator as local again, this step is necessary in vanilla
-- Example:
--   for k,v in pairs(table) do
--       local v = v
--       ...


--[[-------------------------------------------------------------------------
	AceDB Utility Functions
---------------------------------------------------------------------------]]

-- Simple shallow copy for copying defaults
local function copyTable(src, dest)
	if type(dest) ~= "table" then dest = {} end
	if type(src) == "table" then
		for k,v in pairs(src) do
			local v = v
			if type(v) == "table" then
				-- try to index the key first so that the metatable creates the defaults, if set, and use that table
				v = copyTable(v, dest[k])
			end
			dest[k] = v
		end
	end
	return dest
end

-- Called to add defaults to a section of the database
--
-- When a ["*"] default section is indexed with a new key, a table is returned
-- and set in the host table.  These tables must be cleaned up by removeDefaults
-- in order to ensure we don't write empty default tables.
local function copyDefaults(dest, src)
	-- this happens if some value in the SV overwrites our default value with a non-table
	--if type(dest) ~= "table" then return end
	for k, v in pairs(src) do
		local v = v
		if k == "*" or k == "**" then
			if type(v) == "table" then
				-- This is a metatable used for table defaults
				local mt = {
					-- This handles the lookup and creation of new subtables
					__index = function(t,k)
							if k == nil then return nil end
							local tbl = {}
							copyDefaults(tbl, v)
							rawset(t, k, tbl)
							return tbl
						end,
				}
				setmetatable(dest, mt)
				-- handle already existing tables in the SV
				for dk, dv in pairs(dest) do
					if not rawget(src, dk) and type(dv) == "table" then
						copyDefaults(dv, v)
					end
				end
			else
				-- Values are not tables, so this is just a simple return
				local mt = {__index = function(t,k) return k~=nil and v or nil end}
				setmetatable(dest, mt)
			end
		elseif type(v) == "table" then
			if not rawget(dest, k) then rawset(dest, k, {}) end
			if type(dest[k]) == "table" then
				copyDefaults(dest[k], v)
				if src['**'] then
					copyDefaults(dest[k], src['**'])
				end
			end
		else
			if rawget(dest, k) == nil then
				rawset(dest, k, v)
			end
		end
	end
end

-- Called to remove all defaults in the default table from the database
local function removeDefaults(db, defaults, blocker)
	-- remove all metatables from the db, so we don't accidentally create new sub-tables through them
	setmetatable(db, nil)
	-- loop through the defaults and remove their content
	for k,v in pairs(defaults) do
		local v = v
		if k == "*" or k == "**" then
			if type(v) == "table" then
				-- Loop through all the actual k,v pairs and remove
				for key, value in pairs(db) do
					local value = value
					if type(value) == "table" then
						-- if the key was not explicitly specified in the defaults table, just strip everything from * and ** tables
						if defaults[key] == nil and (not blocker or blocker[key] == nil) then
							removeDefaults(value, v)
							-- if the table is empty afterwards, remove it
							if next(value) == nil then
								db[key] = nil
							end
						-- if it was specified, only strip ** content, but block values which were set in the key table
						elseif k == "**" then
							removeDefaults(value, v, defaults[key])
						end
					end
				end
			elseif k == "*" then
				-- check for non-table default
				for key, value in pairs(db) do
					if defaults[key] == nil and v == value then
						db[key] = nil
					end
				end
			end
		elseif type(v) == "table" and type(db[k]) == "table" then
			-- if a blocker was set, dive into it, to allow multi-level defaults
			removeDefaults(db[k], v, blocker and blocker[k])
			if next(db[k]) == nil then
				db[k] = nil
			end
		else
			-- check if the current value matches the default, and that its not blocked by another defaults table
			if db[k] == defaults[k] and (not blocker or blocker[k] == nil) then
				db[k] = nil
			end
		end
	end
end

-- This is called when a table section is first accessed, to set up the defaults
local function initSection(db, section, svstore, key, defaults)
	local sv = rawget(db, "sv")

	local tableCreated
	if not sv[svstore] then sv[svstore] = {} end
	if not sv[svstore][key] then
		sv[svstore][key] = {}
		tableCreated = true
	end

	local tbl = sv[svstore][key]

	if defaults then
		copyDefaults(tbl, defaults)
	end
	rawset(db, section, tbl)

	return tableCreated, tbl
end

-- Metatable to handle the dynamic creation of sections and copying of sections.
local dbmt = {
	__index = function(t, section)
		local keys = rawget(t, "keys")
		local key = keys[section]
		if key then
			local defaultTbl = rawget(t, "defaults")
			local defaults = defaultTbl and defaultTbl[section]

			if section == "profile" then
				if initSection(t, section, "profiles", key, defaults) then
					-- Callback: OnNewProfile, database, newProfileKey
					t.callbacks:Fire("OnNewProfile", 2, t, key)
				end
			elseif section == "profiles" then
				local sv = rawget(t, "sv")
				if not sv.profiles then sv.profiles = {} end
				rawset(t, "profiles", sv.profiles)
			elseif section == "global" then
				local sv = rawget(t, "sv")
				if not sv.global then sv.global = {} end
				if defaults then
					copyDefaults(sv.global, defaults)
				end
				rawset(t, section, sv.global)
			else
				initSection(t, section, section, key, defaults)
			end
		end

		return rawget(t, section)
	end
}

local function validateDefaults(defaults, keyTbl, offset)
	if not defaults then return end
	offset = offset or 0
	for k in pairs(defaults) do
		if not keyTbl[k] or k == "profiles" then
			error(("Usage: AceDBObject:RegisterDefaults(defaults): '%s' is not a valid datatype."):format(k), 3 + offset)
		end
	end
end

local preserve_keys = {
	["callbacks"] = true,
	["RegisterCallback"] = true,
	["UnregisterCallback"] = true,
	["UnregisterAllCallbacks"] = true,
	["children"] = true,
}

local realmKey = GetRealmName()
local charKey = UnitName("player") .. " - " .. realmKey
local _, classKey = UnitClass("player")
local _, raceKey = UnitRace("player")
local _, factionKey = UnitFactionGroup("player")
-- Ace3v: the faction key may error when in GM mode
factionKey = factionKey or "Others"
local localeKey = string.lower(GetLocale())

-- Actual database initialization function
local function initdb(sv, defaults, defaultProfile, olddb, parent)
	-- Generate the database keys for each section

	-- map "true" to our "Default" profile
	if defaultProfile == true then defaultProfile = "Default" end

	local profileKey
	if not parent then
		-- Make a container for profile keys
		if not sv.profileKeys then sv.profileKeys = {} end

		-- Try to get the profile selected from the char db
		profileKey = sv.profileKeys[charKey] or defaultProfile or charKey

		-- save the selected profile for later
		sv.profileKeys[charKey] = profileKey
	else
		-- Use the profile of the parents DB
		profileKey = parent.keys.profile or defaultProfile or charKey

		-- clear the profileKeys in the DB, namespaces don't need to store them
		sv.profileKeys = nil
	end

	-- This table contains keys that enable the dynamic creation
	-- of each section of the table.  The 'global' and 'profiles'
	-- have a key of true, since they are handled in a special case
	local keyTbl= {
		["char"] = charKey,
		["realm"] = realmKey,
		["class"] = classKey,
		["race"] = raceKey,
		["faction"] = factionKey,
		["factionrealm"] = factionKey .. " - " .. realmKey,
		["profile"] = profileKey,
		["locale"] = localeKey,
		["global"] = true,
		["profiles"] = true,
	}

	validateDefaults(defaults, keyTbl, 1)

	-- This allows us to use this function to reset an entire database
	-- Clear out the old database
	if olddb then
		for k,v in pairs(olddb) do if not preserve_keys[k] then olddb[k] = nil end end
	end

	-- Give this database the metatable so it initializes dynamically
	local db = setmetatable(olddb or {}, dbmt)

	if not rawget(db, "callbacks") then
		-- try to load CallbackHandler-1.0 if it loaded after our library
		if not CallbackHandler then CallbackHandler = LibStub:GetLibrary("CallbackHandler-1.0", true) end
		db.callbacks = CallbackHandler and CallbackHandler:New(db) or CallbackDummy
	end

	-- Copy methods locally into the database object, to avoid hitting
	-- the metatable when calling methods

	if not parent then
		for name, func in pairs(DBObjectLib) do
			db[name] = func
		end
	else
		-- hack this one in
		db.RegisterDefaults = DBObjectLib.RegisterDefaults
		db.ResetProfile = DBObjectLib.ResetProfile
	end

	-- Set some properties in the database object
	db.profiles = sv.profiles
	db.keys = keyTbl
	db.sv = sv
	--db.sv_name = name
	db.defaults = defaults
	db.parent = parent

	-- store the DB in the registry
	AceDB.db_registry[db] = true

	return db
end

-- handle PLAYER_LOGOUT
-- strip all defaults from all databases
-- and cleans up empty sections
local function logoutHandler()
	if event == "PLAYER_LOGOUT" then
		for db in pairs(AceDB.db_registry) do
			db.callbacks:Fire("OnDatabaseShutdown", 1, db)
			db:RegisterDefaults(nil)

			-- cleanup sections that are empty without defaults
			local sv = rawget(db, "sv")
			for section in pairs(db.keys) do
				if rawget(sv, section) then
					-- global is special, all other sections have sub-entrys
					-- also don't delete empty profiles on main dbs, only on namespaces
					if section ~= "global" and (section ~= "profiles" or rawget(db, "parent")) then
						for key in pairs(sv[section]) do
							if not next(sv[section][key]) then
								sv[section][key] = nil
							end
						end
					end
					if not next(sv[section]) then
						sv[section] = nil
					end
				end
			end
		end
	end
end

AceDB.frame:RegisterEvent("PLAYER_LOGOUT")
AceDB.frame:SetScript("OnEvent", logoutHandler)


--[[-------------------------------------------------------------------------
	AceDB Object Method Definitions
---------------------------------------------------------------------------]]

--- Sets the defaults table for the given database object by clearing any
-- that are currently set, and then setting the new defaults.
-- @param defaults A table of defaults for this database
function DBObjectLib:RegisterDefaults(defaults)
	if defaults and type(defaults) ~= "table" then
		error("Usage: AceDBObject:RegisterDefaults(defaults): 'defaults' - table or nil expected.", 2)
	end

	validateDefaults(defaults, self.keys)

	-- Remove any currently set defaults
	if self.defaults then
		for section,key in pairs(self.keys) do
			if self.defaults[section] and rawget(self, section) then
				removeDefaults(self[section], self.defaults[section])
			end
		end
	end

	-- Set the DBObject.defaults table
	self.defaults = defaults

	-- Copy in any defaults, only touching those sections already created
	if defaults then
		for section,key in pairs(self.keys) do
			if defaults[section] and rawget(self, section) then
				copyDefaults(self[section], defaults[section])
			end
		end
	end
end

--- Changes the profile of the database and all of it's namespaces to the
-- supplied named profile
-- @param name The name of the profile to set as the current profile
function DBObjectLib:SetProfile(name)
	if type(name) ~= "string" then
		error("Usage: AceDBObject:SetProfile(name): 'name' - string expected.", 2)
	end

	-- changing to the same profile, dont do anything
	if name == self.keys.profile then return end

	local oldProfile = self.profile
	local defaults = self.defaults and self.defaults.profile

	-- Callback: OnProfileShutdown, database
	self.callbacks:Fire("OnProfileShutdown", 1, self)

	if oldProfile and defaults then
		-- Remove the defaults from the old profile
		removeDefaults(oldProfile, defaults)
	end

	self.profile = nil
	self.keys["profile"] = name

	-- if the storage exists, save the new profile
	-- this won't exist on namespaces.
	if self.sv.profileKeys then
		self.sv.profileKeys[charKey] = name
	end

	-- populate to child namespaces
	if self.children then
		for _, db in pairs(self.children) do
			DBObjectLib.SetProfile(db, name)
		end
	end

	-- Callback: OnProfileChanged, database, newProfileKey
	self.callbacks:Fire("OnProfileChanged", 2, self, name)
end

--- Returns a table with the names of the existing profiles in the database.
-- You can optionally supply a table to re-use for this purpose.
-- @param tbl A table to store the profile names in (optional)
function DBObjectLib:GetProfiles(tbl)
	if tbl and type(tbl) ~= "table" then
		error("Usage: AceDBObject:GetProfiles(tbl): 'tbl' - table or nil expected.", 2)
	end

	-- Clear the container table
	if tbl then
		for k,v in pairs(tbl) do tbl[k] = nil end
	else
		tbl = {}
	end

	local curProfile = self.keys.profile

	local i = 0
	for profileKey in pairs(self.profiles) do
		i = i + 1
		tbl[i] = profileKey
		if curProfile and profileKey == curProfile then curProfile = nil end
	end

	-- Add the current profile, if it hasn't been created yet
	if curProfile then
		i = i + 1
		tbl[i] = curProfile
	end

	return tbl, i
end

--- Returns the current profile name used by the database
function DBObjectLib:GetCurrentProfile()
	return self.keys.profile
end

--- Deletes a named profile.  This profile must not be the active profile.
-- @param name The name of the profile to be deleted
-- @param silent If true, do not raise an error when the profile does not exist
function DBObjectLib:DeleteProfile(name, silent)
	if type(name) ~= "string" then
		error("Usage: AceDBObject:DeleteProfile(name): 'name' - string expected.", 2)
	end

	if self.keys.profile == name then
		error("Cannot delete the active profile in an AceDBObject.", 2)
	end

	if not rawget(self.profiles, name) and not silent then
		error("Cannot delete profile '" .. name .. "'. It does not exist.", 2)
	end

	self.profiles[name] = nil

	-- populate to child namespaces
	if self.children then
		for _, db in pairs(self.children) do
			DBObjectLib.DeleteProfile(db, name, true)
		end
	end

	-- switch all characters that use this profile back to the default
	if self.sv.profileKeys then
		for key, profile in pairs(self.sv.profileKeys) do
			if profile == name then
				self.sv.profileKeys[key] = nil
			end
		end
	end

	-- Callback: OnProfileDeleted, database, profileKey
	self.callbacks:Fire("OnProfileDeleted", 2, self, name)
end

--- Copies a named profile into the current profile, overwriting any conflicting
-- settings.
-- @param name The name of the profile to be copied into the current profile
-- @param silent If true, do not raise an error when the profile does not exist
function DBObjectLib:CopyProfile(name, silent)
	if type(name) ~= "string" then
		error("Usage: AceDBObject:CopyProfile(name): 'name' - string expected.", 2)
	end

	if name == self.keys.profile then
		error("Cannot have the same source and destination profiles.", 2)
	end

	if not rawget(self.profiles, name) and not silent then
		error("Cannot copy profile '" .. name .. "'. It does not exist.", 2)
	end

	-- Reset the profile before copying
	DBObjectLib.ResetProfile(self, nil, true)

	local profile = self.profile
	local source = self.profiles[name]

	copyTable(source, profile)

	-- populate to child namespaces
	if self.children then
		for _, db in pairs(self.children) do
			DBObjectLib.CopyProfile(db, name, true)
		end
	end

	-- Callback: OnProfileCopied, database, sourceProfileKey
	self.callbacks:Fire("OnProfileCopied", 2, self, name)
end

--- Resets the current profile to the default values (if specified).
-- @param noChildren if set to true, the reset will not be populated to the child namespaces of this DB object
-- @param noCallbacks if set to true, won't fire the OnProfileReset callback
function DBObjectLib:ResetProfile(noChildren, noCallbacks)
	local profile = self.profile

	for k,v in pairs(profile) do
		profile[k] = nil
	end

	local defaults = self.defaults and self.defaults.profile
	if defaults then
		copyDefaults(profile, defaults)
	end

	-- populate to child namespaces
	if self.children and not noChildren then
		for _, db in pairs(self.children) do
			DBObjectLib.ResetProfile(db, nil, noCallbacks)
		end
	end

	-- Callback: OnProfileReset, database
	if not noCallbacks then
		self.callbacks:Fire("OnProfileReset", 2, self, self.keys["profile"])
	end
end

--- Resets the entire database, using the string defaultProfile as the new default
-- profile.
-- @param defaultProfile The profile name to use as the default
function DBObjectLib:ResetDB(defaultProfile)
	if defaultProfile and type(defaultProfile) ~= "string" then
		error("Usage: AceDBObject:ResetDB(defaultProfile): 'defaultProfile' - string or nil expected.", 2)
	end

	local sv = self.sv
	for k,v in pairs(sv) do
		sv[k] = nil
	end

	local parent = self.parent

	initdb(sv, self.defaults, defaultProfile, self)

	-- fix the child namespaces
	if self.children then
		if not sv.namespaces then sv.namespaces = {} end
		for name, db in pairs(self.children) do
			if not sv.namespaces[name] then sv.namespaces[name] = {} end
			initdb(sv.namespaces[name], db.defaults, self.keys.profile, db, self)
		end
	end

	-- Callback: OnDatabaseReset, database
	self.callbacks:Fire("OnDatabaseReset", 1, self)
	-- Callback: OnProfileChanged, database, profileKey
	self.callbacks:Fire("OnProfileChanged", 2, self, self.keys["profile"])

	return self
end

--- Creates a new database namespace, directly tied to the database.  This
-- is a full scale database in it's own rights other than the fact that
-- it cannot control its profile individually
-- @param name The name of the new namespace
-- @param defaults A table of values to use as defaults
function DBObjectLib:RegisterNamespace(name, defaults)
	if type(name) ~= "string" then
		error("Usage: AceDBObject:RegisterNamespace(name, defaults): 'name' - string expected.", 2)
	end
	if defaults and type(defaults) ~= "table" then
		error("Usage: AceDBObject:RegisterNamespace(name, defaults): 'defaults' - table or nil expected.", 2)
	end
	if self.children and self.children[name] then
		error ("Usage: AceDBObject:RegisterNamespace(name, defaults): 'name' - a namespace with that name already exists.", 2)
	end

	local sv = self.sv
	if not sv.namespaces then sv.namespaces = {} end
	if not sv.namespaces[name] then
		sv.namespaces[name] = {}
	end

	local newDB = initdb(sv.namespaces[name], defaults, self.keys.profile, nil, self)

	if not self.children then self.children = {} end
	self.children[name] = newDB
	return newDB
end

--- Returns an already existing namespace from the database object.
-- @param name The name of the new namespace
-- @param silent if true, the addon is optional, silently return nil if its not found
-- @usage
-- local namespace = self.db:GetNamespace('namespace')
-- @return the namespace object if found
function DBObjectLib:GetNamespace(name, silent)
	if type(name) ~= "string" then
		error("Usage: AceDBObject:GetNamespace(name): 'name' - string expected.", 2)
	end
	if not silent and not (self.children and self.children[name]) then
		error ("Usage: AceDBObject:GetNamespace(name): 'name' - namespace does not exist.", 2)
	end
	if not self.children then self.children = {} end
	return self.children[name]
end

--[[-------------------------------------------------------------------------
	AceDB Exposed Methods
---------------------------------------------------------------------------]]

--- Creates a new database object that can be used to handle database settings and profiles.
-- By default, an empty DB is created, using a character specific profile.
--
-- You can override the default profile used by passing any profile name as the third argument,
-- or by passing //true// as the third argument to use a globally shared profile called "Default".
--
-- Note that there is no token replacement in the default profile name, passing a defaultProfile as "char"
-- will use a profile named "char", and not a character-specific profile.
-- @param tbl The name of variable, or table to use for the database
-- @param defaults A table of database defaults
-- @param defaultProfile The name of the default profile. If not set, a character specific profile will be used as the default.
-- You can also pass //true// to use a shared global profile called "Default".
-- @usage
-- -- Create an empty DB using a character-specific default profile.
-- self.db = LibStub("AceDB-3.0"):New("MyAddonDB")
-- @usage
-- -- Create a DB using defaults and using a shared default profile
-- self.db = LibStub("AceDB-3.0"):New("MyAddonDB", defaults, true)
function AceDB:New(tbl, defaults, defaultProfile)
	if type(tbl) == "string" then
		local name = tbl
		tbl = _G[name]
		if not tbl then
			tbl = {}
			_G[name] = tbl
		end
	end

	if type(tbl) ~= "table" then
		error("Usage: AceDB:New(tbl, defaults, defaultProfile): 'tbl' - table expected.", 2)
	end

	if defaults and type(defaults) ~= "table" then
		error("Usage: AceDB:New(tbl, defaults, defaultProfile): 'defaults' - table expected.", 2)
	end

	if defaultProfile and type(defaultProfile) ~= "string" and defaultProfile ~= true then
		error("Usage: AceDB:New(tbl, defaults, defaultProfile): 'defaultProfile' - string or true expected.", 2)
	end

	return initdb(tbl, defaults, defaultProfile)
end

-- upgrade existing databases
for db in pairs(AceDB.db_registry) do
	if not db.parent then
		for name,func in pairs(DBObjectLib) do
			db[name] = func
		end
	else
		db.RegisterDefaults = DBObjectLib.RegisterDefaults
		db.ResetProfile = DBObjectLib.ResetProfile
	end
end

================
File: Libs/vanilla/Ace3/AceDB-3.0/AceDB-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceDB-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceDBOptions-3.0/AceDBOptions-3.0.lua
================
--- AceDBOptions-3.0 provides a universal AceConfig options screen for managing AceDB-3.0 profiles.
-- @class file
-- @name AceDBOptions-3.0
-- @release $Id: AceDBOptions-3.0.lua 1140 2016-07-03 07:53:29Z nevcairiel $
local ACEDBO_MAJOR, ACEDBO_MINOR = "AceDBOptions-3.0", 15
local AceDBOptions, oldminor = LibStub:NewLibrary(ACEDBO_MAJOR, ACEDBO_MINOR)

if not AceDBOptions then return end -- No upgrade needed

local AceCore = LibStub("AceCore-3.0")
local new, del = AceCore.new, AceCore.del

-- Lua APIs
local pairs, next = pairs, next

-- WoW APIs
local UnitClass = UnitClass

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: NORMAL_FONT_COLOR_CODE, FONT_COLOR_CODE_CLOSE

AceDBOptions.optionTables = AceDBOptions.optionTables or {}
AceDBOptions.handlers = AceDBOptions.handlers or {}

--[[
	Localization of AceDBOptions-3.0
]]

local L = {
	choose = "Existing Profiles",
	choose_desc = "You can either create a new profile by entering a name in the editbox, or choose one of the already existing profiles.",
	choose_sub = "Select one of your currently available profiles.",
	copy = "Copy From",
	copy_desc = "Copy the settings from one existing profile into the currently active profile.",
	current = "Current Profile:",
	default = "Default",
	delete = "Delete a Profile",
	delete_confirm = "Are you sure you want to delete the selected profile?",
	delete_desc = "Delete existing and unused profiles from the database to save space, and cleanup the SavedVariables file.",
	delete_sub = "Deletes a profile from the database.",
	intro = "You can change the active database profile, so you can have different settings for every character.",
	new = "New",
	new_sub = "Create a new empty profile.",
	profiles = "Profiles",
	profiles_sub = "Manage Profiles",
	reset = "Reset Profile",
	reset_desc = "Reset the current profile back to its default values, in case your configuration is broken, or you simply want to start over.",
	reset_sub = "Reset the current profile to the default",
}

local LOCALE = GetLocale()
if LOCALE == "deDE" then
	L["choose"] = "Vorhandene Profile"
	L["choose_desc"] = "Du kannst ein neues Profil erstellen, indem du einen neuen Namen in der Eingabebox 'Neu' eingibst, oder whle eines der vorhandenen Profile aus."
	L["choose_sub"] = "Whlt ein bereits vorhandenes Profil aus."
	L["copy"] = "Kopieren von..."
	L["copy_desc"] = "Kopiere die Einstellungen von einem vorhandenen Profil in das aktive Profil."
	L["current"] = "Aktuelles Profil:"
	L["default"] = "Standard"
	L["delete"] = "Profil lschen"
	L["delete_confirm"] = "Willst du das ausgewhlte Profil wirklich lschen?"
	L["delete_desc"] = "Lsche vorhandene oder unbenutzte Profile aus der Datenbank, um Platz zu sparen und die SavedVariables-Datei 'sauber' zu halten."
	L["delete_sub"] = "Lscht ein Profil aus der Datenbank."
	L["intro"] = "Hier kannst du das aktive Datenbankprofil ndern, damit du verschiedene Einstellungen fr jeden Charakter erstellen kannst, wodurch eine sehr flexible Konfiguration mglich wird."
	L["new"] = "Neu"
	L["new_sub"] = "Ein neues Profil erstellen."
	L["profiles"] = "Profile"
	L["profiles_sub"] = "Profile verwalten"
	L["reset"] = "Profil zurcksetzen"
	L["reset_desc"] = "Setzt das momentane Profil auf Standardwerte zurck, fr den Fall, dass mit der Konfiguration etwas schief lief oder weil du einfach neu starten willst."
	L["reset_sub"] = "Das aktuelle Profil auf Standard zurcksetzen."
elseif LOCALE == "frFR" then
	L["choose"] = "Profils existants"
	L["choose_desc"] = "Vous pouvez crer un nouveau profil en entrant un nouveau nom dans la bote de saisie, ou en choississant un des profils dj existants."
	L["choose_sub"] = "Permet de choisir un des profils dj disponibles."
	L["copy"] = "Copier  partir de"
	L["copy_desc"] = "Copie les paramtres d'un profil dj existant dans le profil actuellement actif."
	L["current"] = "Profil actuel :"
	L["default"] = "Dfaut"
	L["delete"] = "Supprimer un profil"
	L["delete_confirm"] = "Etes-vous sr de vouloir supprimer le profil slectionn ?"
	L["delete_desc"] = "Supprime les profils existants inutiliss de la base de donnes afin de gagner de la place et de nettoyer le fichier SavedVariables."
	L["delete_sub"] = "Supprime un profil de la base de donnes."
	L["intro"] = "Vous pouvez changer le profil actuel afin d'avoir des paramtres diffrents pour chaque personnage, permettant ainsi d'avoir une configuration trs flexible."
	L["new"] = "Nouveau"
	L["new_sub"] = "Cre un nouveau profil vierge."
	L["profiles"] = "Profils"
	L["profiles_sub"] = "Gestion des profils"
	L["reset"] = "Rinitialiser le profil"
	L["reset_desc"] = "Rinitialise le profil actuel au cas o votre configuration est corrompue ou si vous voulez tout simplement faire table rase."
	L["reset_sub"] = "Rinitialise le profil actuel avec les paramtres par dfaut."
elseif LOCALE == "koKR" then
	L["choose"] = "  "
	L["choose_desc"] = "              ."
	L["choose_sub"] = "       ."
	L["copy"] = ""
	L["copy_desc"] = "       ."
	L["current"] = " :"
	L["default"] = ""
	L["delete"] = " "
	L["delete_confirm"] = "   ?"
	L["delete_desc"] = "   SavedVariables        ."
	L["delete_sub"] = "  ."
	L["intro"] = "     ,        ."
	L["new"] = " "
	L["new_sub"] = "  ."
	L["profiles"] = ""
	L["profiles_sub"] = " "
	L["reset"] = " "
	L["reset_desc"] = "      ,    ."
	L["reset_sub"] = "   "
elseif LOCALE == "esES" or LOCALE == "esMX" then
	L["choose"] = "Perfiles existentes"
	L["choose_desc"] = "Puedes crear un nuevo perfil introduciendo un nombre en el recuadro o puedes seleccionar un perfil de los ya existentes."
	L["choose_sub"] = "Selecciona uno de los perfiles disponibles."
	L["copy"] = "Copiar de"
	L["copy_desc"] = "Copia los ajustes de un perfil existente al perfil actual."
	L["current"] = "Perfil actual:"
	L["default"] = "Por defecto"
	L["delete"] = "Borrar un Perfil"
	L["delete_confirm"] = "Estas seguro que quieres borrar el perfil seleccionado?"
	L["delete_desc"] = "Borra los perfiles existentes y sin uso de la base de datos para ganar espacio y limpiar el archivo SavedVariables."
	L["delete_sub"] = "Borra un perfil de la base de datos."
	L["intro"] = "Puedes cambiar el perfil activo de tal manera que cada personaje tenga diferentes configuraciones."
	L["new"] = "Nuevo"
	L["new_sub"] = "Crear un nuevo perfil vacio."
	L["profiles"] = "Perfiles"
	L["profiles_sub"] = "Manejar Perfiles"
	L["reset"] = "Reiniciar Perfil"
	L["reset_desc"] = "Reinicia el perfil actual a los valores por defectos, en caso de que se haya estropeado la configuracin o quieras volver a empezar de nuevo."
	L["reset_sub"] = "Reinicar el perfil actual al de por defecto"
elseif LOCALE == "zhTW" then
	L["choose"] = ""
	L["choose_desc"] = ""
	L["choose_sub"] = ""
	L["copy"] = ""
	L["copy_desc"] = ""
	L["current"] = ""
	L["default"] = ""
	L["delete"] = ""
	L["delete_confirm"] = ""
	L["delete_desc"] = " SavedVariables "
	L["delete_sub"] = ""
	L["intro"] = ""
	L["new"] = ""
	L["new_sub"] = ""
	L["profiles"] = ""
	L["profiles_sub"] = ""
	L["reset"] = ""
	L["reset_desc"] = ""
	L["reset_sub"] = ""
elseif LOCALE == "zhCN" then
	L["choose"] = ""
	L["choose_desc"] = ""
	L["choose_sub"] = ""
	L["copy"] = ""
	L["copy_desc"] = ""
	L["current"] = ""
	L["default"] = ""
	L["delete"] = ""
	L["delete_confirm"] = ""
	L["delete_desc"] = "SavedVariables"
	L["delete_sub"] = ""
	L["intro"] = ""
	L["new"] = ""
	L["new_sub"] = ""
	L["profiles"] = ""
	L["profiles_sub"] = ""
	L["reset"] = ""
	L["reset_desc"] = ""
	L["reset_sub"] = ""
elseif LOCALE == "ruRU" then
	L["choose"] = " "
	L["choose_desc"] = "    ,     ,       ."
	L["choose_sub"] = "     "
	L["copy"] = " "
	L["copy_desc"] = "      ."
	L["current"] = " :"
	L["default"] = " "
	L["delete"] = " "
	L["delete_confirm"] = " ,      ?"
	L["delete_desc"] = "         ,   SavedVariables ."
	L["delete_sub"] = "   "
	L["intro"] = "  ,         ."
	L["new"] = ""
	L["new_sub"] = "   "
	L["profiles"] = ""
	L["profiles_sub"] = " "
	L["reset"] = " "
	L["reset_desc"] = "     ,          ."
	L["reset_sub"] = "    "
elseif LOCALE == "itIT" then
	L["choose"] = "Profili Esistenti"
	L["choose_desc"] = "Puoi creare un nuovo profilo digitando il nome della casella di testo, oppure scegliendone uno tra i profili gi esistenti."
	L["choose_sub"] = "Seleziona uno dei profili attualmente disponibili."
	L["copy"] = "Copia Da"
	L["copy_desc"] = "Copia le impostazioni da un profilo esistente, nel profilo attivo in questo momento."
	L["current"] = "Profilo Attivo:"
	L["default"] = "Standard"
	L["delete"] = "Cancella un Profilo"
	L["delete_confirm"] = "Sei sicuro di voler cancellare il profilo selezionato?"
	L["delete_desc"] = "Cancella i profili non utilizzati dal database per risparmiare spazio e mantenere puliti i file di configurazione SavedVariables."
	L["delete_sub"] = "Cancella un profilo dal Database."
	L["intro"] = "Puoi cambiare il profilo attivo, in modo da usare impostazioni diverse per ogni personaggio."
	L["new"] = "Nuovo"
	L["new_sub"] = "Crea un nuovo profilo vuoto."
	L["profiles"] = "Profili"
	L["profiles_sub"] = "Gestisci Profili"
	L["reset"] = "Reimposta Profilo"
	L["reset_desc"] = "Riporta il tuo profilo attivo alle sue impostazioni predefinite, nel caso in cui la tua configurazione si sia corrotta, o semplicemente tu voglia re-inizializzarla."
	L["reset_sub"] = "Reimposta il profilo ai suoi valori predefiniti."
elseif LOCALE == "ptBR" then
	L["choose"] = "Perfis Existentes"
	L["choose_desc"] = "Voc pode tanto criar um perfil novo tanto digitando um nome na caixa de texto, quanto escolher um dos perfis j existentes."
	L["choose_sub"] = "Selecione um de seus perfis atualmente disponveis."
	L["copy"] = "Copiar De"
	L["copy_desc"] = "Copia as definies de um perfil existente no perfil atualmente ativo."
	L["current"] = "Perfil Autal:"
	L["default"] = "Padro"
	L["delete"] = "Remover um Perfil"
	L["delete_confirm"] = "Tem certeza que deseja remover o perfil selecionado?"
	L["delete_desc"] = "Remove perfis existentes e inutilizados do banco de dados para economizar espao, e limpar o arquivo SavedVariables."
	L["delete_sub"] = "Remove um perfil do banco de dados."
	L["intro"] = "Voc pode alterar o perfil do banco de dados ativo, para que possa ter definies diferentes para cada personagem."
	L["new"] = "Novo"
	L["new_sub"] = "Cria um novo perfil vazio."
	L["profiles"] = "Perfis"
	L["profiles_sub"] = "Gerenciar Perfis"
	L["reset"] = "Resetar Perfil"
	L["reset_desc"] = "Reseta o perfil atual para os valores padres, no caso de sua configurao estar quebrada, ou simplesmente se deseja comear novamente."
	L["reset_sub"] = "Resetar o perfil atual ao padro"
end

local defaultProfiles

-- Get a list of available profiles for the specified database.
-- You can specify which profiles to include/exclude in the list using the two boolean parameters listed below.
-- @param db The db object to retrieve the profiles from
-- @param common If true, getProfileList will add the default profiles to the return list, even if they have not been created yet
-- @param nocurrent If true, then getProfileList will not display the current profile in the list
-- @return Hashtable of all profiles with the internal name as keys and the display name as value.
local function getProfileList(db, common, nocurrent)
	local profiles = new()
	local tmpprofiles = new()
	-- copy existing profiles into the table
	local currentProfile = db:GetCurrentProfile()
	for i,v in pairs(db:GetProfiles(tmpprofiles)) do 
		if not (nocurrent and v == currentProfile) then 
			profiles[v] = v 
		end 
	end
	del(tmpprofiles)
	
	-- add our default profiles to choose from ( or rename existing profiles)
	for k,v in pairs(defaultProfiles) do
		if (common or profiles[k]) and not (nocurrent and k == currentProfile) then
			profiles[k] = v
		end
	end
	
	return profiles
end

--[[
	OptionsHandlerPrototype
	prototype class for handling the options in a sane way
]]
local OptionsHandlerPrototype = {}

--[[ Reset the profile ]]
function OptionsHandlerPrototype:Reset()
	self.db:ResetProfile()
end

--[[ Set the profile to value ]]
function OptionsHandlerPrototype:SetProfile(info, value)
	self.db:SetProfile(value)
end

--[[ returns the currently active profile ]]
function OptionsHandlerPrototype:GetCurrentProfile()
	return self.db:GetCurrentProfile()
end

--[[ 
	List all active profiles
	you can control the output with the .arg variable
	currently four modes are supported
	
	(empty) - return all available profiles
	"nocurrent" - returns all available profiles except the currently active profile
	"common" - returns all avaialble profiles + some commonly used profiles ("char - realm", "realm", "class", "Default")
	"both" - common except the active profile
]]
-- Ace3v: It is recommanded to destroy the returned table by AceCore.del
--        if it is no longer needed
function OptionsHandlerPrototype:ListProfiles(info)
	local arg = info.arg
	local profiles
	if arg == "common" and not self.noDefaultProfiles then
		profiles = getProfileList(self.db, true, nil)
	elseif arg == "nocurrent" then
		profiles = getProfileList(self.db, nil, true)
	elseif arg == "both" then -- currently not used
		profiles = getProfileList(self.db, (not self.noDefaultProfiles) and true, true)
	else
		profiles = getProfileList(self.db)
	end
	
	return profiles
end

function OptionsHandlerPrototype:HasNoProfiles(info)
	local profiles = self:ListProfiles(info)
	local r = (not next(profiles)) and true or false
	del(profiles)
	return r
end

--[[ Copy a profile ]]
function OptionsHandlerPrototype:CopyProfile(info, value)
	self.db:CopyProfile(value)
end

--[[ Delete a profile from the db ]]
function OptionsHandlerPrototype:DeleteProfile(info, value)
	self.db:DeleteProfile(value)
end

--[[ fill defaultProfiles with some generic values ]]
local function generateDefaultProfiles(db)
	defaultProfiles = {
		["Default"] = L["default"],
		[db.keys.char] = db.keys.char,
		[db.keys.realm] = db.keys.realm,
		[db.keys.class] = UnitClass("player")
	}
end

--[[ create and return a handler object for the db, or upgrade it if it already existed ]]
local function getOptionsHandler(db, noDefaultProfiles)
	if not defaultProfiles then
		generateDefaultProfiles(db)
	end
	
	local handler = AceDBOptions.handlers[db] or { db = db, noDefaultProfiles = noDefaultProfiles }
	
	for k,v in pairs(OptionsHandlerPrototype) do
		handler[k] = v
	end
	
	AceDBOptions.handlers[db] = handler
	return handler
end

--[[
	the real options table 
]]
local optionsTable = {
	desc = {
		order = 1,
		type = "description",
		name = L["intro"] .. "\n",
	},
	descreset = {
		order = 9,
		type = "description",
		name = L["reset_desc"],
	},
	reset = {
		order = 10,
		type = "execute",
		name = L["reset"],
		desc = L["reset_sub"],
		func = "Reset",
	},
	current = {
		order = 11,
		type = "description",
		name = function(info) return L["current"] .. " " .. NORMAL_FONT_COLOR_CODE .. info.handler:GetCurrentProfile() .. FONT_COLOR_CODE_CLOSE end,
		width = "default",
	},
	choosedesc = {
		order = 20,
		type = "description",
		name = "\n" .. L["choose_desc"],
	},
	new = {
		name = L["new"],
		desc = L["new_sub"],
		type = "input",
		order = 30,
		get = false,
		set = "SetProfile",
		nullable = false,	-- Ace3v: we do not want a null or empty value
	},
	choose = {
		name = L["choose"],
		desc = L["choose_sub"],
		type = "select",
		order = 40,
		get = "GetCurrentProfile",
		set = "SetProfile",
		values = "ListProfiles",
		valuesTableDestroyable = true,
		arg = "common",
	},
	copydesc = {
		order = 50,
		type = "description",
		name = "\n" .. L["copy_desc"],
	},
	copyfrom = {
		order = 60,
		type = "select",
		name = L["copy"],
		desc = L["copy_desc"],
		get = false,
		set = "CopyProfile",
		values = "ListProfiles",
		valuesTableDestroyable = true,
		disabled = "HasNoProfiles",
		arg = "nocurrent",
	},
	deldesc = {
		order = 70,
		type = "description",
		name = "\n" .. L["delete_desc"],
	},
	delete = {
		order = 80,
		type = "select",
		name = L["delete"],
		desc = L["delete_sub"],
		get = false,
		set = "DeleteProfile",
		values = "ListProfiles",
		valuesTableDestroyable = true,
		disabled = "HasNoProfiles",
		arg = "nocurrent",
		confirm = true,
		confirmText = L["delete_confirm"],
	},
}

--- Get/Create a option table that you can use in your addon to control the profiles of AceDB-3.0.
-- @param db The database object to create the options table for.
-- @return The options table to be used in AceConfig-3.0
-- @usage 
-- -- Assuming `options` is your top-level options table and `self.db` is your database:
-- options.args.profiles = LibStub("AceDBOptions-3.0"):GetOptionsTable(self.db)
function AceDBOptions:GetOptionsTable(db, noDefaultProfiles)
	local tbl = AceDBOptions.optionTables[db] or {
			type = "group",
			name = L["profiles"],
			desc = L["profiles_sub"],
		}
	
	tbl.handler = getOptionsHandler(db, noDefaultProfiles)
	tbl.args = optionsTable

	AceDBOptions.optionTables[db] = tbl
	return tbl
end

-- upgrade existing tables
for db,tbl in pairs(AceDBOptions.optionTables) do
	tbl.handler = getOptionsHandler(db)
	tbl.args = optionsTable
end

================
File: Libs/vanilla/Ace3/AceDBOptions-3.0/AceDBOptions-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceDBOptions-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceEvent-3.0/AceEvent-3.0.lua
================
--- AceEvent-3.0 provides event registration and secure dispatching.
-- All dispatching is done using **CallbackHandler-1.0**. AceEvent is a simple wrapper around
-- CallbackHandler, and dispatches all game events or addon message to the registrees.
--
-- **AceEvent-3.0** can be embeded into your addon, either explicitly by calling AceEvent:Embed(MyAddon) or by 
-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
-- and can be accessed directly, without having to explicitly call AceEvent itself.\\
-- It is recommended to embed AceEvent, otherwise you'll have to specify a custom `self` on all calls you
-- make into AceEvent.
-- @class file
-- @name AceEvent-3.0
-- @release $Id: AceEvent-3.0.lua 975 2010-10-23 11:26:18Z nevcairiel $
local MAJOR, MINOR = "AceEvent-3.0", 3
local AceEvent = LibStub:NewLibrary(MAJOR, MINOR)

if not AceEvent then return end

-- Lua APIs
local pairs = pairs

local CallbackHandler = LibStub:GetLibrary("CallbackHandler-1.0")

AceEvent.frame = AceEvent.frame or CreateFrame("Frame", "AceEvent30Frame") -- our event frame
AceEvent.embeds = AceEvent.embeds or {} -- what objects embed this lib

-- APIs and registry for blizzard events, using CallbackHandler lib
if not AceEvent.events then
	AceEvent.events = CallbackHandler:New(AceEvent, 
		"RegisterEvent", "UnregisterEvent", "UnregisterAllEvents")
end

function AceEvent.events:OnUsed(target, eventname) 
	AceEvent.frame:RegisterEvent(eventname)
end

function AceEvent.events:OnUnused(target, eventname) 
	AceEvent.frame:UnregisterEvent(eventname)
end


-- APIs and registry for IPC messages, using CallbackHandler lib
if not AceEvent.messages then
	AceEvent.messages = CallbackHandler:New(AceEvent, 
		"RegisterMessage", "UnregisterMessage", "UnregisterAllMessages"
	)
	AceEvent.SendMessage = AceEvent.messages.Fire
end

--- embedding and embed handling
local mixins = {
	"RegisterEvent", "UnregisterEvent",
	"RegisterMessage", "UnregisterMessage",
	"SendMessage",
	"UnregisterAllEvents", "UnregisterAllMessages",
}

--- Register for a Blizzard Event.
-- The callback will be called with the optional `arg` as the first argument (if supplied), and the event name as the second (or first, if no arg was supplied)
-- Any arguments to the event will be passed on after that.
-- @name AceEvent:RegisterEvent
-- @class function
-- @paramsig event[, callback [, arg]]
-- @param event The event to register for
-- @param callback The callback function to call when the event is triggered (funcref or method, defaults to a method with the event name)
-- @param arg An optional argument to pass to the callback function

--- Unregister an event.
-- @name AceEvent:UnregisterEvent
-- @class function
-- @paramsig event
-- @param event The event to unregister

--- Register for a custom AceEvent-internal message.
-- The callback will be called with the optional `arg` as the first argument (if supplied), and the event name as the second (or first, if no arg was supplied)
-- Any arguments to the event will be passed on after that.
-- @name AceEvent:RegisterMessage
-- @class function
-- @paramsig message[, callback [, arg]]
-- @param message The message to register for
-- @param callback The callback function to call when the message is triggered (funcref or method, defaults to a method with the event name)
-- @param arg An optional argument to pass to the callback function

--- Unregister a message
-- @name AceEvent:UnregisterMessage
-- @class function
-- @paramsig message
-- @param message The message to unregister

--- Send a message over the AceEvent-3.0 internal message system to other addons registered for this message.
-- @name AceEvent:SendMessage
-- @class function
-- @paramsig message, ...
-- @param message The message to send
-- @param ... Any arguments to the message


-- Embeds AceEvent into the target object making the functions from the mixins list available on target:..
-- @param target target object to embed AceEvent in
function AceEvent:Embed(target)
	for k, v in pairs(mixins) do
		target[v] = self[v]
	end
	self.embeds[target] = true
	return target
end

-- AceEvent:OnEmbedDisable( target )
-- target (object) - target object that is being disabled
--
-- Unregister all events messages etc when the target disables.
-- this method should be called by the target manually or by an addon framework
function AceEvent:OnEmbedDisable(target)
	target:UnregisterAllEvents()
	target:UnregisterAllMessages()
end

-- Script to fire blizzard events into the event listeners
-- Ace3v: in vanilla the arguments are set to global:
--        event, arg1, arg2, arg3 ...
--        the user have always access to them, so we save the table cost here
local events = AceEvent.events
AceEvent.frame:SetScript("OnEvent", function()
	events:Fire(event)
end)

--- Finally: upgrade our old embeds
for target, v in pairs(AceEvent.embeds) do
	AceEvent:Embed(target)
end

================
File: Libs/vanilla/Ace3/AceEvent-3.0/AceEvent-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceEvent-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/BackgroundWidget.lua
================
-- Widget is based on the AceGUIWidget-DropDown.lua supplied with AceGUI-3.0
-- Widget created by Yssaril

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

local AGSMW = LibStub("AceGUISharedMediaWidgets-1.0")

local fixlevels = AceGUI.fixlevels
local fixstrata = AceGUI.fixstrata
local getn = table.getn

do
	local widgetType = "LSM30_Background"
	local widgetVersion = 12

	local contentFrameCache = {}
	local function ReturnSelf(self)
		self:ClearAllPoints()
		self:Hide()
		self.check:Hide()
		table.insert(contentFrameCache, self)
	end

	local function ContentOnClick(button)
		local self = this.obj
		self:Fire("OnValueChanged", 1, this.text:GetText())
		self:SetValue(this.text:GetText())
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function ContentOnEnter(button)
		local self = this.obj
		local text = this.text:GetText()
		local background = self.list[text] ~= text and self.list[text] or Media:Fetch('background', text)
		self.dropdown.bgTex:SetTexture(background)
	end

	local function GetContentLine()
		local frame
		if next(contentFrameCache) then
			frame = table.remove(contentFrameCache)
		else
			frame = CreateFrame("Button", nil, UIParent)
			--frame:SetWidth(200)
			frame:SetHeight(18)
			frame:SetHighlightTexture([[Interface\QuestFrame\UI-QuestTitleHighlight]], "ADD")
			frame:SetScript("OnClick", ContentOnClick)
			frame:SetScript("OnEnter", ContentOnEnter)

			local check = frame:CreateTexture("OVERLAY")
			check:SetWidth(16)
			check:SetHeight(16)
			check:SetPoint("LEFT", frame, "LEFT", 1, -1)
			check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
			check:Hide()
			frame.check = check

			local text = frame:CreateFontString(nil, "OVERLAY", "GameFontWhite")
			local font, size = text:GetFont()
			text:SetFont(font, size, "OUTLINE")

			text:SetPoint("TOPLEFT", check, "TOPRIGHT", 1, 0)
			text:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -2, 0)
			text:SetJustifyH("LEFT")
			text:SetText("Test Test Test Test Test Test Test")
			frame.text = text

			frame.ReturnSelf = ReturnSelf
		end
		frame:Show()
		return frame
	end

	local function OnAcquire(self)
		self:SetHeight(44)
		self:SetWidth(200)
	end

	local function OnRelease(self)
		self:SetText("")
		self:SetLabel("")
		self:SetDisabled(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	local function SetValue(self, value) -- Set the value to an item in the List.
		if self.list then
			self:SetText(value or "")
		end
		self.value = value
	end

	local function GetValue(self)
		return self.value
	end

	local function SetList(self, list) -- Set the list of values for the dropdown (key => value pairs)
		self.list = list or Media:HashTable("background")
	end

	local function SetText(self, text) -- Set the text displayed in the box.
		self.frame.text:SetText(text or "")
		local background = self.list and self.list[text] ~= text and self.list[text] or Media:Fetch('background', text)

		self.frame.displayButton:SetBackdrop({ bgFile = background,
			edgeFile = "Interface/Tooltips/UI-Tooltip-Border",
			edgeSize = 16,
			insets = { left = 4, right = 4, top = 4, bottom = 4 } })
	end

	local function SetLabel(self, text) -- Set the text for the label.
		self.frame.label:SetText(text or "")
	end

	local function AddItem(self, key, value) -- Add an item to the list.
		self.list = self.list or {}
		self.list[key] = value
	end

	local SetItemValue = AddItem -- Set the value of a item in the list. <<same as adding a new item>>

	local function SetMultiselect(self, flag) end -- Toggle multi-selecting. <<Dummy function to stay inline with the dropdown API>>

	local function GetMultiselect() return false end -- Query the multi-select flag. <<Dummy function to stay inline with the dropdown API>>

	local function SetItemDisabled(self, key) end -- Disable one item in the list. <<Dummy function to stay inline with the dropdown API>>

	local function SetDisabled(self, disabled) -- Disable the widget.
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
			self.frame.displayButton:SetBackdropColor(.2, .2, .2, 1)
		else
			self.frame:Enable()
			self.frame.displayButton:SetBackdropColor(1, 1, 1, 1)
		end
	end

	local function textSort(a, b)
		return string.upper(a) < string.upper(b)
	end

	
	local function ToggleDrop()
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
			AceGUI:ClearFocus()
		else
			AceGUI:SetFocus(self)
			self.dropdown = AGSMW:GetDropDownFrame()
			local width = self.frame:GetWidth()
			self.dropdown:SetPoint("TOPLEFT", self.frame, "BOTTOMLEFT")
			self.dropdown:SetPoint("TOPRIGHT", self.frame, "BOTTOMRIGHT", width < 160 and (160 - width) or 0, 0)
			local sortedlist = {}
			for k, v in pairs(self.list) do
				sortedlist[getn(sortedlist) + 1] = k
			end
			table.sort(sortedlist, textSort)
			for i, k in ipairs(sortedlist) do
				local f = GetContentLine()
				f.text:SetText(k)
				--print(k)
				if k == self.value then
					f.check:Show()
				end
				f.obj = self
				f.dropdown = self.dropdown
				self.dropdown:AddFrame(f)
			end
			fixlevels(self.dropdown, self.dropdown:GetChildren())
		end
	end

	local function ClearFocus(self)
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function OnHide()
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function Drop_OnEnter()
		this.obj:Fire("OnEnter")
	end

	local function Drop_OnLeave()
		this.obj:Fire("OnLeave")
	end

	local function Constructor()
		local frame = AGSMW:GetBaseFrameWithWindow()
		local self = {}

		self.type = widgetType
		self.frame = frame
		frame.obj = self
		frame.dropButton.obj = self
		frame.dropButton:SetScript("OnEnter", Drop_OnEnter)
		frame.dropButton:SetScript("OnLeave", Drop_OnLeave)
		frame.dropButton:SetScript("OnClick", ToggleDrop)
		frame:SetScript("OnHide", OnHide)

		self.alignoffset = 31

		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.ClearFocus = ClearFocus
		self.SetText = SetText
		self.SetValue = SetValue
		self.GetValue = GetValue
		self.SetList = SetList
		self.SetLabel = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.ToggleDrop = ToggleDrop

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

end

================
File: Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/BorderWidget.lua
================
-- Widget is based on the AceGUIWidget-DropDown.lua supplied with AceGUI-3.0
-- Widget created by Yssaril

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

local AGSMW = LibStub("AceGUISharedMediaWidgets-1.0")

local fixlevels = AceGUI.fixlevels
local fixstrata = AceGUI.fixstrata
local getn = table.getn

do
	local widgetType = "LSM30_Border"
	local widgetVersion = 12

	local contentFrameCache = {}
	local function ReturnSelf(self)
		self:ClearAllPoints()
		self:Hide()
		self.check:Hide()
		table.insert(contentFrameCache, self)
	end

	local function ContentOnClick( button)
		local self = this.obj
		self:Fire("OnValueChanged", 1, this.text:GetText())
		self:SetValue(this.text:GetText())
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function ContentOnEnter( button)
		local self = this.obj
		local text = this.text:GetText()
		local border = self.list[text] ~= text and self.list[text] or Media:Fetch('border',text)
		this.dropdown:SetBackdrop({edgeFile = border,
			bgFile=[[Interface\DialogFrame\UI-DialogBox-Background]],
			tile = true, tileSize = 16, edgeSize = 16,
			insets = { left = 4, right = 4, top = 4, bottom = 4 }})
	end

	local function GetContentLine()
		local frame
		if next(contentFrameCache) then
			frame = table.remove(contentFrameCache)
		else
			frame = CreateFrame("Button", nil, UIParent)
				--frame:SetWidth(200)
				frame:SetHeight(18)
				frame:SetHighlightTexture([[Interface\QuestFrame\UI-QuestTitleHighlight]], "ADD")
				frame:SetScript("OnClick", ContentOnClick)
				frame:SetScript("OnEnter", ContentOnEnter)
			local check = frame:CreateTexture("OVERLAY")
				check:SetWidth(16)
				check:SetHeight(16)
				check:SetPoint("LEFT",frame,"LEFT",1,-1)
				check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
				check:Hide()
			frame.check = check
			local text = frame:CreateFontString(nil,"OVERLAY","GameFontWhite")
				text:SetPoint("TOPLEFT", check, "TOPRIGHT", 1, 0)
				text:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -2, 0)
				text:SetJustifyH("LEFT")
				text:SetText("Test Test Test Test Test Test Test")
			frame.text = text
			frame.ReturnSelf = ReturnSelf
		end
		frame:Show()
		return frame
	end

	local function OnAcquire(self)
		self:SetHeight(44)
		self:SetWidth(200)
	end

	local function OnRelease(self)
		self:SetText("")
		self:SetLabel("")
		self:SetDisabled(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	local function SetValue(self, value) -- Set the value to an item in the List.
		if self.list then
			self:SetText(value or "")
		end
		self.value = value
	end

	local function GetValue(self)
		return self.value
	end

	local function SetList(self, list) -- Set the list of values for the dropdown (key => value pairs)
		self.list = list or Media:HashTable("border")
	end


	local function SetText(self, text) -- Set the text displayed in the box.
		self.frame.text:SetText(text or "")
		local border = self.list and self.list[text] ~= text and self.list[text] or Media:Fetch('border',text)

		self.frame.displayButton:SetBackdrop({edgeFile = border,
			bgFile=[[Interface\DialogFrame\UI-DialogBox-Background]],
			tile = true, tileSize = 16, edgeSize = 16,
			insets = { left = 4, right = 4, top = 4, bottom = 4 }})
	end

	local function SetLabel(self, text) -- Set the text for the label.
		self.frame.label:SetText(text or "")
	end

	local function AddItem(self, key, value) -- Add an item to the list.
		self.list = self.list or {}
		self.list[key] = value
	end
	local SetItemValue = AddItem -- Set the value of a item in the list. <<same as adding a new item>>

	local function SetMultiselect(self, flag) end -- Toggle multi-selecting. <<Dummy function to stay inline with the dropdown API>>
	local function GetMultiselect() return false end-- Query the multi-select flag. <<Dummy function to stay inline with the dropdown API>>
	local function SetItemDisabled(self, key) end-- Disable one item in the list. <<Dummy function to stay inline with the dropdown API>>

	local function SetDisabled(self, disabled) -- Disable the widget.
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
		else
			self.frame:Enable()
		end
	end

	local function textSort(a,b)
		return string.upper(a) < string.upper(b)
	end

	
	local function ToggleDrop()
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
			AceGUI:ClearFocus()
		else
			AceGUI:SetFocus(self)
			self.dropdown = AGSMW:GetDropDownFrame()
			local width = self.frame:GetWidth()
			self.dropdown:SetPoint("TOPLEFT", self.frame, "BOTTOMLEFT")
			self.dropdown:SetPoint("TOPRIGHT", self.frame, "BOTTOMRIGHT", width < 160 and (160 - width) or 0, 0)
			local sortedlist = {}
			for k, v in pairs(self.list) do
				sortedlist[getn(sortedlist)+1] = k
			end
			table.sort(sortedlist, textSort)
			for i, k in ipairs(sortedlist) do
				local f = GetContentLine()
				f.text:SetText(k)
				if k == self.value then
					f.check:Show()
				end
				f.obj = self
				f.dropdown = self.dropdown
				self.dropdown:AddFrame(f)
			end
			fixlevels(self.dropdown, self.dropdown:GetChildren())
		end
	end

	local function ClearFocus(self)
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function OnHide()
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function Drop_OnEnter()
		this.obj:Fire("OnEnter")
	end

	local function Drop_OnLeave()
		this.obj:Fire("OnLeave")
	end

	local function Constructor()
		local frame = AGSMW:GetBaseFrameWithWindow()
		local self = {}

		self.type = widgetType
		self.frame = frame
		frame.obj = self
		frame.dropButton.obj = self
		frame.dropButton:SetScript("OnEnter", Drop_OnEnter)
		frame.dropButton:SetScript("OnLeave", Drop_OnLeave)
		frame.dropButton:SetScript("OnClick",ToggleDrop)
		frame:SetScript("OnHide", OnHide)

		self.alignoffset = 31

		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.ClearFocus = ClearFocus
		self.SetText = SetText
		self.SetValue = SetValue
		self.GetValue = GetValue
		self.SetList = SetList
		self.SetLabel = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.ToggleDrop = ToggleDrop

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

end

================
File: Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/FontWidget.lua
================
-- Widget is based on the AceGUIWidget-DropDown.lua supplied with AceGUI-3.0
-- Widget created by Yssaril

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

local AGSMW = LibStub("AceGUISharedMediaWidgets-1.0")

local fixlevels = AceGUI.fixlevels
local fixstrata = AceGUI.fixstrata
local getn = table.getn

do
	local widgetType = "LSM30_Font"
	local widgetVersion = 12

	local contentFrameCache = {}
	local function ReturnSelf(self)
		self:ClearAllPoints()
		self:Hide()
		self.check:Hide()
		table.insert(contentFrameCache, self)
	end

	local function ContentOnClick(button)
		local self = this.obj
		self:Fire("OnValueChanged", 1, this.text:GetText())
		self:SetValue(this.text:GetText())
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function GetContentLine()
		local frame
		if next(contentFrameCache) then
			frame = table.remove(contentFrameCache)
		else
			frame = CreateFrame("Button", nil, UIParent)
				--frame:SetWidth(200)
				frame:SetHeight(18)
				frame:SetHighlightTexture([[Interface\QuestFrame\UI-QuestTitleHighlight]], "ADD")
				frame:SetScript("OnClick", ContentOnClick)
			local check = frame:CreateTexture("OVERLAY")
				check:SetWidth(16)
				check:SetHeight(16)
				check:SetPoint("LEFT",frame,"LEFT",1,-1)
				check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
				check:Hide()
			frame.check = check
			local text = frame:CreateFontString(nil,"OVERLAY","GameFontWhite")
				text:SetPoint("TOPLEFT", check, "TOPRIGHT", 1, 0)
				text:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -2, 0)
				text:SetJustifyH("LEFT")
				text:SetText("Test Test Test Test Test Test Test")
			frame.text = text
			frame.ReturnSelf = ReturnSelf
		end
		frame:Show()
		return frame
	end

	local function OnAcquire(self)
		self:SetHeight(44)
		self:SetWidth(200)
	end

	local function OnRelease(self)
		self:SetText("")
		self:SetLabel("")
		self:SetDisabled(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	local function SetValue(self, value) -- Set the value to an item in the List.
		if self.list then
			self:SetText(value or "")
		end
		self.value = value
	end

	local function GetValue(self)
		return self.value
	end

	local function SetList(self, list) -- Set the list of values for the dropdown (key => value pairs)
		self.list = list or Media:HashTable("font")
	end

	local function SetText(self, text) -- Set the text displayed in the box.
		self.frame.text:SetText(text or "")
		local font = self.list and self.list[text] ~= text and self.list[text] or Media:Fetch('font',text)
		local _, size, outline= self.frame.text:GetFont()
		self.frame.text:SetFont(font,size,outline)
	end

	local function SetLabel(self, text) -- Set the text for the label.
		self.frame.label:SetText(text or "")
	end

	local function AddItem(self, key, value) -- Add an item to the list.
		self.list = self.list or {}
		self.list[key] = value
	end
	local SetItemValue = AddItem -- Set the value of a item in the list. <<same as adding a new item>>

	local function SetMultiselect(self, flag) end -- Toggle multi-selecting. <<Dummy function to stay inline with the dropdown API>>
	local function GetMultiselect() return false end-- Query the multi-select flag. <<Dummy function to stay inline with the dropdown API>>
	local function SetItemDisabled(self, key) end-- Disable one item in the list. <<Dummy function to stay inline with the dropdown API>>

	local function SetDisabled(self, disabled) -- Disable the widget.
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
		else
			self.frame:Enable()
		end
	end

	local function textSort(a,b)
		return string.upper(a) < string.upper(b)
	end

	
	local function ToggleDrop()
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
			AceGUI:ClearFocus()
		else
			AceGUI:SetFocus(self)
			self.dropdown = AGSMW:GetDropDownFrame()
			local width = self.frame:GetWidth()
			self.dropdown:SetPoint("TOPLEFT", self.frame, "BOTTOMLEFT")
			self.dropdown:SetPoint("TOPRIGHT", self.frame, "BOTTOMRIGHT", width < 160 and (160 - width) or 0, 0)
			local sortedlist = {}
			for k, v in pairs(self.list) do
				sortedlist[getn(sortedlist)+1] = k
			end
			table.sort(sortedlist, textSort)
			for i, k in ipairs(sortedlist) do
				local f = GetContentLine()
				local _, size, outline= f.text:GetFont()
				local font = self.list[k] ~= k and self.list[k] or Media:Fetch('font',k)
				f.text:SetFont(font,size,outline)
				f.text:SetText(k)
				if k == self.value then
					f.check:Show()
				end
				f.obj = self
				self.dropdown:AddFrame(f)
			end
			fixlevels(self.dropdown, self.dropdown:GetChildren())
		end
	end

	local function ClearFocus(self)
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function OnHide()
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function Drop_OnEnter()
		this.obj:Fire("OnEnter")
	end

	local function Drop_OnLeave()
		this.obj:Fire("OnLeave")
	end

	local function Constructor()
		local frame = AGSMW:GetBaseFrame()
		local self = {}

		self.type = widgetType
		self.frame = frame
		frame.obj = self
		frame.dropButton.obj = self
		frame.dropButton:SetScript("OnEnter", Drop_OnEnter)
		frame.dropButton:SetScript("OnLeave", Drop_OnLeave)
		frame.dropButton:SetScript("OnClick",ToggleDrop)
		frame:SetScript("OnHide", OnHide)

		self.alignoffset = 31

		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.ClearFocus = ClearFocus
		self.SetText = SetText
		self.SetValue = SetValue
		self.GetValue = GetValue
		self.SetList = SetList
		self.SetLabel = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.ToggleDrop = ToggleDrop

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

end

================
File: Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/prototypes.lua
================
-- Widget created by Yssaril
local DataVersion = 9003
local AGSMW = LibStub:NewLibrary("AceGUISharedMediaWidgets-1.0", DataVersion)

if not AGSMW then
	return -- already loaded and no upgrade necessary
end

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

local getn = table.getn

AGSMW = AGSMW or {}

AceGUIWidgetLSMlists = {
	['font'] = Media:HashTable("font"),
	['sound'] = Media:HashTable("sound"),
	['statusbar'] = Media:HashTable("statusbar"),
	['border'] = Media:HashTable("border"),
	['background'] = Media:HashTable("background"),
}

do
	local function disable(frame)
		frame.label:SetTextColor(.5, .5, .5)
		frame.text:SetTextColor(.5, .5, .5)
		frame.dropButton:Disable()
		if frame.displayButtonFont then
			frame.displayButtonFont:SetTextColor(.5, .5, .5)
			frame.displayButton:Disable()
		end
	end

	local function enable(frame)
		frame.label:SetTextColor(1, .82, 0)
		frame.text:SetTextColor(1, 1, 1)
		frame.dropButton:Enable()
		if frame.displayButtonFont then
			frame.displayButtonFont:SetTextColor(1, 1, 1)
			frame.displayButton:Enable()
		end
	end

	local displayButtonBackdrop = {
		edgeFile = "Interface/Tooltips/UI-Tooltip-Border",
		tile = true, tileSize = 16, edgeSize = 16,
		insets = { left = 4, right = 4, top = 4, bottom = 4 },
	}

	-- create or retrieve BaseFrame
	function AGSMW:GetBaseFrame()
		local frame = CreateFrame("Frame", nil, UIParent)
		frame:SetHeight(44)
		frame:SetWidth(200)

		local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
		label:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, 0)
		label:SetPoint("TOPRIGHT", frame, "TOPRIGHT", 0, 0)
		label:SetJustifyH("LEFT")
		label:SetHeight(18)
		label:SetText("")
		frame.label = label

		local DLeft = frame:CreateTexture(nil, "ARTWORK")
		DLeft:SetWidth(25)
		DLeft:SetHeight(64)
		DLeft:SetPoint("BOTTOMLEFT", frame, "BOTTOMLEFT", -17, -21)
		DLeft:SetTexture([[Interface\Glues\CharacterCreate\CharacterCreate-LabelFrame]])
		DLeft:SetTexCoord(0, 0.1953125, 0, 1)
		frame.DLeft = DLeft

		local DRight = frame:CreateTexture(nil, "ARTWORK")
		DRight:SetWidth(25)
		DRight:SetHeight(64)
		DRight:SetPoint("TOP", DLeft, "TOP")
		DRight:SetPoint("RIGHT", frame, "RIGHT", 17, 0)
		DRight:SetTexture([[Interface\Glues\CharacterCreate\CharacterCreate-LabelFrame]])
		DRight:SetTexCoord(0.8046875, 1, 0, 1)
		frame.DRight = DRight

		local DMiddle = frame:CreateTexture(nil, "ARTWORK")
		DMiddle:SetHeight(64)
		DMiddle:SetPoint("TOP", DLeft, "TOP")
		DMiddle:SetPoint("LEFT", DLeft, "RIGHT")
		DMiddle:SetPoint("RIGHT", DRight, "LEFT")
		DMiddle:SetTexture([[Interface\Glues\CharacterCreate\CharacterCreate-LabelFrame]])
		DMiddle:SetTexCoord(0.1953125, 0.8046875, 0, 1)
		frame.DMiddle = DMiddle

		local text = frame:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
		text:SetPoint("RIGHT", DRight, "RIGHT", -43, 1)
		text:SetPoint("LEFT", DLeft, "LEFT", 26, 1)
		text:SetJustifyH("RIGHT")
		text:SetHeight(18)
		text:SetText("")
		frame.text = text

		local dropButton = CreateFrame("Button", nil, frame)
		dropButton:SetWidth(24)
		dropButton:SetHeight(24)
		dropButton:SetPoint("TOPRIGHT", DRight, "TOPRIGHT", -16, -18)
		dropButton:SetNormalTexture([[Interface\ChatFrame\UI-ChatIcon-ScrollDown-Up]])
		dropButton:SetPushedTexture([[Interface\ChatFrame\UI-ChatIcon-ScrollDown-Down]])
		dropButton:SetDisabledTexture([[Interface\ChatFrame\UI-ChatIcon-ScrollDown-Disabled]])
		dropButton:SetHighlightTexture([[Interface\Buttons\UI-Common-MouseHilight]], "ADD")
		frame.dropButton = dropButton

		frame.Disable = disable
		frame.Enable = enable
		return frame
	end

	function AGSMW:GetBaseFrameWithWindow()
		local frame = self:GetBaseFrame()

		local displayButton = CreateFrame("Button", nil, frame)
		displayButton:SetHeight(42)
		displayButton:SetWidth(42)
		displayButton:SetPoint("TOPLEFT", frame, "TOPLEFT", 1, -2)
		displayButton:SetBackdrop(displayButtonBackdrop)
		displayButton:SetBackdropBorderColor(.5, .5, .5)
		frame.displayButton = displayButton

		frame.label:SetPoint("TOPLEFT", displayButton, "TOPRIGHT", 1, 2)

		frame.DLeft:SetPoint("BOTTOMLEFT", displayButton, "BOTTOMRIGHT", -17, -20)

		return frame
	end

end

do

	local sliderBackdrop = {
		["bgFile"] = [[Interface\Buttons\UI-SliderBar-Background]],
		["edgeFile"] = [[Interface\Buttons\UI-SliderBar-Border]],
		["tile"] = true,
		["edgeSize"] = 8,
		["tileSize"] = 8,
		["insets"] = {
			["left"] = 3,
			["right"] = 3,
			["top"] = 3,
			["bottom"] = 3,
		},
	}
	local frameBackdrop = {
		bgFile = [[Interface\DialogFrame\UI-DialogBox-Background]],
		edgeFile = [[Interface\DialogFrame\UI-DialogBox-Border]],
		tile = true, tileSize = 32, edgeSize = 32,
		insets = { left = 11, right = 12, top = 12, bottom = 9 },
	}

	local function OnMouseWheel()

		this.slider:SetValue(this.slider:GetValue() + (15 * arg1 * -1))
	end

	local function AddFrame(self, frame)
		frame:SetParent(self.contentframe)
		frame:SetFrameStrata(self:GetFrameStrata())
		frame:SetFrameLevel(self:GetFrameLevel() + 100)

		if next(self.contentRepo) then
			frame:SetPoint("TOPLEFT", self.contentRepo[getn(self.contentRepo)], "BOTTOMLEFT", 0, 0)
			frame:SetPoint("RIGHT", self.contentframe, "RIGHT", 0, 0)
			self.contentframe:SetHeight(self.contentframe:GetHeight() + frame:GetHeight())
			self.contentRepo[getn(self.contentRepo) + 1] = frame
		else
			self.contentframe:SetHeight(frame:GetHeight())
			frame:SetPoint("TOPLEFT", self.contentframe, "TOPLEFT", 0, 0)
			frame:SetPoint("RIGHT", self.contentframe, "RIGHT", 0, 0)
			self.contentRepo[1] = frame
		end

		if self.contentframe:GetHeight() > UIParent:GetHeight() * 2 / 5 - 20 then
			self.scrollframe:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -28, 12)
			self:SetHeight(UIParent:GetHeight() * 2 / 5)
			self.slider:Show()
			self:SetScript("OnMouseWheel", OnMouseWheel)
			self.slider:SetMinMaxValues(0, self.contentframe:GetHeight() - self.scrollframe:GetHeight())
		else
			self.scrollframe:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -14, 12)
			self:SetHeight(self.contentframe:GetHeight() + 25)
			self.slider:Hide()
			self:SetScript("OnMouseWheel", nil)
			self.slider:SetMinMaxValues(0, 0)
		end
		self.contentframe:SetWidth(self.scrollframe:GetWidth())
	end

	local function ClearFrames(self)
		for i, frame in ipairs(self.contentRepo) do
			frame:ReturnSelf()
			self.contentRepo[i] = nil
		end
	end

	local function slider_OnValueChanged()
		this.frame.scrollframe:SetVerticalScroll(arg1)
	end

	local DropDownCache = {}
	function AGSMW:GetDropDownFrame()
		local frame
		if next(DropDownCache) then
			frame = table.remove(DropDownCache)
		else
			frame = CreateFrame("Frame", nil, UIParent)
			frame:SetClampedToScreen(true)
			frame:SetWidth(188)
			frame:SetBackdrop(frameBackdrop)
			frame:SetFrameStrata("TOOLTIP")
			frame:EnableMouseWheel(true)

			local contentframe = CreateFrame("Frame", nil, frame)
			contentframe:SetWidth(160)
			contentframe:SetHeight(0)
			frame.contentframe = contentframe

			local scrollframe = CreateFrame("ScrollFrame", nil, frame)
			scrollframe:SetWidth(160)
			scrollframe:SetPoint("TOPLEFT", frame, "TOPLEFT", 14, -13)
			scrollframe:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -14, 12)
			scrollframe:SetScrollChild(contentframe)
			frame.scrollframe = scrollframe

			contentframe:SetPoint("TOPLEFT", scrollframe)
			contentframe:SetPoint("TOPRIGHT", scrollframe)

			local bgTex = frame:CreateTexture(nil, "ARTWORK")
			bgTex:SetAllPoints(scrollframe)
			frame.bgTex = bgTex

			frame.AddFrame = AddFrame
			frame.ClearFrames = ClearFrames
			frame.contentRepo = {} -- store all our frames in here so we can get rid of them later

			local slider = CreateFrame("Slider", nil, scrollframe)
			slider:SetOrientation("VERTICAL")
			slider:SetPoint("TOPRIGHT", frame, "TOPRIGHT", -14, -10)
			slider:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -14, 10)
			slider:SetBackdrop(sliderBackdrop)
			slider:SetThumbTexture([[Interface\Buttons\UI-SliderBar-Button-Vertical]])
			slider:SetMinMaxValues(0, 1)
			--slider:SetValueStep(1)
			--slider:SetValue(0)
			slider:SetWidth(12)
			slider.frame = frame
			slider:SetScript("OnValueChanged", slider_OnValueChanged)
			frame.slider = slider
		end
		frame:SetHeight(UIParent:GetHeight() * 2 / 5)
		frame.slider:SetValue(0)
		frame:Show()
		return frame
	end

	function AGSMW:ReturnDropDownFrame(frame)
		ClearFrames(frame)
		frame:ClearAllPoints()
		frame:Hide()
		frame:SetBackdrop(frameBackdrop)
		frame.bgTex:SetTexture(nil)
		table.insert(DropDownCache, frame)
		return nil
	end
end

================
File: Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/SoundWidget.lua
================
-- Widget is based on the AceGUIWidget-DropDown.lua supplied with AceGUI-3.0
-- Widget created by Yssaril

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

local AGSMW = LibStub("AceGUISharedMediaWidgets-1.0")

local getn = table.getn

local fixlevels = AceGUI.fixlevels
local fixstrata = AceGUI.fixstrata

do
	local widgetType = "LSM30_Sound"
	local widgetVersion = 12

	local contentFrameCache = {}
	local function ReturnSelf(self)
		self:ClearAllPoints()
		self:Hide()
		self.check:Hide()
		table.insert(contentFrameCache, self)
	end

	local function ContentOnClick(button)
		local self = this.obj
		self:Fire("OnValueChanged", 1, this.text:GetText())
		self:SetValue(this.text:GetText())
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function ContentSpeakerOnClick(button)
		local self = this.frame.obj
		local sound = this.frame.text:GetText()
		PlaySoundFile(self.list[sound] ~= sound and self.list[sound] or Media:Fetch('sound', sound), "Master")
	end

	local function GetContentLine()
		local frame
		if next(contentFrameCache) then
			frame = table.remove(contentFrameCache)
		else
			frame = CreateFrame("Button", nil, UIParent)
			--frame:SetWidth(200)
			frame:SetHeight(18)
			frame:SetHighlightTexture([[Interface\QuestFrame\UI-QuestTitleHighlight]], "ADD")
			frame:SetScript("OnClick", ContentOnClick)
			local frmlvl = frame:GetFrameLevel()
			
			local check = frame:CreateTexture("OVERLAY")
			check:SetWidth(16)
			check:SetHeight(16)
			check:SetPoint("LEFT", frame, "LEFT", 1, -1)
			check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
			check:Hide()
			frame.check = check

			local soundbutton = CreateFrame("Button", nil, frame)
			soundbutton:SetWidth(16)
			soundbutton:SetHeight(16)
			soundbutton:SetPoint("RIGHT", frame, "RIGHT", -1, 0)
			soundbutton:SetFrameLevel(frmlvl+10)
			soundbutton.frame = frame
			soundbutton:SetScript("OnClick", ContentSpeakerOnClick)
			frame.soundbutton = soundbutton

			local speaker = soundbutton:CreateTexture(nil, "BACKGROUND")
			speaker:SetTexture("Interface\\ChatFrame\\ChatFrameExpandArrow")
			speaker:SetAllPoints(soundbutton)
			frame.speaker = speaker
			local speakeron = soundbutton:CreateTexture(nil, "HIGHLIGHT")
			speakeron:SetTexture("Interface\\Buttons\\UI-GuildButton-MOTD-Up")
			speakeron:SetAllPoints(soundbutton)
			frame.speakeron = speakeron
			
			local text = frame:CreateFontString(nil, "OVERLAY", "GameFontWhite")
			text:SetPoint("TOPLEFT", check, "TOPRIGHT", 1, 0)
			text:SetPoint("BOTTOMRIGHT", soundbutton, "BOTTOMLEFT", -2, 0)
			text:SetJustifyH("LEFT")
			text:SetText("Test Test Test Test Test Test Test")
			frame.text = text
			
			frame.ReturnSelf = ReturnSelf
		end
		frame:Show()
		return frame
	end

	local function OnAcquire(self)
		self:SetHeight(44)
		self:SetWidth(200)
	end

	local function OnRelease(self)
		self:SetText("")
		self:SetLabel("")
		self:SetDisabled(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	local function SetValue(self, value) -- Set the value to an item in the List.
		if self.list then
			self:SetText(value or "")
		end
		self.value = value
	end

	local function GetValue(self)
		return self.value
	end

	local function SetList(self, list) -- Set the list of values for the dropdown (key => value pairs)
		self.list = list or Media:HashTable("sound")
	end

	local function SetText(self, text) -- Set the text displayed in the box.
		self.frame.text:SetText(text or "")
	end

	local function SetLabel(self, text) -- Set the text for the label.
		self.frame.label:SetText(text or "")
	end

	local function AddItem(self, key, value) -- Add an item to the list.
		self.list = self.list or {}
		self.list[key] = value
	end

	local SetItemValue = AddItem -- Set the value of a item in the list. <<same as adding a new item>>

	local function SetMultiselect(self, flag) end -- Toggle multi-selecting. <<Dummy function to stay inline with the dropdown API>>

	local function GetMultiselect() return false end -- Query the multi-select flag. <<Dummy function to stay inline with the dropdown API>>

	local function SetItemDisabled(self, key) end -- Disable one item in the list. <<Dummy function to stay inline with the dropdown API>>

	local function SetDisabled(self, disabled) -- Disable the widget.
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
			self.speaker:SetDesaturated(true)
			self.speakeron:SetDesaturated(true)
		else
			self.frame:Enable()
			self.speaker:SetDesaturated(false)
			self.speakeron:SetDesaturated(false)
		end
	end

	local function textSort(a, b)
		return string.upper(a) < string.upper(b)
	end

	
	local function ToggleDrop()
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
			AceGUI:ClearFocus()
		else
			AceGUI:SetFocus(self)
			self.dropdown = AGSMW:GetDropDownFrame()
			local width = self.frame:GetWidth()
			self.dropdown:SetPoint("TOPLEFT", self.frame, "BOTTOMLEFT")
			self.dropdown:SetPoint("TOPRIGHT", self.frame, "BOTTOMRIGHT", width < 160 and (160 - width) or 0, 0)
			local sortedlist = {}
			for k, v in pairs(self.list) do
				sortedlist[getn(sortedlist) + 1] = k
			end
			table.sort(sortedlist, textSort)
			for i, k in ipairs(sortedlist) do
				local f = GetContentLine()
				f.text:SetText(k)
				if k == self.value then
					f.check:Show()
				end
				f.obj = self
				self.dropdown:AddFrame(f)
			end
			fixlevels(self.dropdown, self.dropdown:GetChildren())
		end
	end

	local function ClearFocus(self)
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function OnHide()
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function Drop_OnEnter()
		this.obj:Fire("OnEnter")
	end

	local function Drop_OnLeave()
		this.obj:Fire("OnLeave")
	end

	local function WidgetPlaySound()
		
		local self = this.obj
		local sound = self.frame.text:GetText()
		PlaySoundFile(self.list[sound] ~= sound and self.list[sound] or Media:Fetch('sound', sound), "Master")
	end

	local function Constructor()
		local frame = AGSMW:GetBaseFrame()
		local self = {}

		self.type = widgetType
		self.frame = frame
		frame.obj = self
		frame.dropButton.obj = self
		frame.dropButton:SetScript("OnEnter", Drop_OnEnter)
		frame.dropButton:SetScript("OnLeave", Drop_OnLeave)
		frame.dropButton:SetScript("OnClick", ToggleDrop)
		frame:SetScript("OnHide", OnHide)


		local soundbutton = CreateFrame("Button", nil, frame)
		soundbutton:SetWidth(16)
		soundbutton:SetHeight(16)
		soundbutton:SetPoint("LEFT", frame.DLeft, "LEFT", 26, 1)
		soundbutton:SetScript("OnClick", WidgetPlaySound)
		soundbutton.obj = self
		self.soundbutton = soundbutton
		frame.text:SetPoint("LEFT", soundbutton, "RIGHT", 2, 0)


		local speaker = soundbutton:CreateTexture(nil, "BACKGROUND")
		speaker:SetTexture("Interface\\ChatFrame\\ChatFrameExpandArrow")
		speaker:SetAllPoints(soundbutton)
		self.speaker = speaker
		local speakeron = soundbutton:CreateTexture(nil, "HIGHLIGHT")
		speakeron:SetTexture("Interface\\Buttons\\UI-GuildButton-MOTD-Up")
		speakeron:SetAllPoints(soundbutton)
		self.speakeron = speakeron

		self.alignoffset = 31

		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.ClearFocus = ClearFocus
		self.SetText = SetText
		self.SetValue = SetValue
		self.GetValue = GetValue
		self.SetList = SetList
		self.SetLabel = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.ToggleDrop = ToggleDrop

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

end

================
File: Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/StatusbarWidget.lua
================
-- Widget is based on the AceGUIWidget-DropDown.lua supplied with AceGUI-3.0
-- Widget created by Yssaril

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

local AGSMW = LibStub("AceGUISharedMediaWidgets-1.0")

local fixlevels = AceGUI.fixlevels
local fixstrata = AceGUI.fixstrata
local getn = table.getn

do
	local widgetType = "LSM30_Statusbar"
	local widgetVersion = 12

	local contentFrameCache = {}
	local function ReturnSelf(self)
		self:ClearAllPoints()
		self:Hide()
		self.check:Hide()
		table.insert(contentFrameCache, self)
	end

	local function ContentOnClick( button)
		local self = this.obj
		self:Fire("OnValueChanged", 1, this.text:GetText())
		self:SetValue(this.text:GetText())
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function GetContentLine()
		local frame
		if next(contentFrameCache) then
			frame = table.remove(contentFrameCache)
		else
			frame = CreateFrame("Button", nil, UIParent)
				--frame:SetWidth(200)
				frame:SetHeight(18)
				frame:SetHighlightTexture([[Interface\QuestFrame\UI-QuestTitleHighlight]], "ADD")
				frame:SetScript("OnClick", ContentOnClick)
			local check = frame:CreateTexture("OVERLAY")
				check:SetWidth(16)
				check:SetHeight(16)
				check:SetPoint("LEFT",frame,"LEFT",1,-1)
				check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
				check:Hide()
			frame.check = check
			local bar = frame:CreateTexture("ARTWORK")
				bar:SetHeight(16)
				bar:SetPoint("LEFT",check,"RIGHT",1,0)
				bar:SetPoint("RIGHT",frame,"RIGHT",-1,0)
			frame.bar = bar
			local text = frame:CreateFontString(nil,"OVERLAY","GameFontWhite")

				local font, size = text:GetFont()
				text:SetFont(font,size,"OUTLINE")

				text:SetPoint("TOPLEFT", check, "TOPRIGHT", 3, 0)
				text:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -2, 0)
				text:SetJustifyH("LEFT")
				text:SetText("Test Test Test Test Test Test Test")
			frame.text = text
			frame.ReturnSelf = ReturnSelf
		end
		frame:Show()
		return frame
	end

	local function OnAcquire(self)
		self:SetHeight(44)
		self:SetWidth(200)
	end

	local function OnRelease(self)
		self:SetText("")
		self:SetLabel("")
		self:SetDisabled(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	local function SetValue(self, value) -- Set the value to an item in the List.
		if self.list then
			self:SetText(value or "")
		end
		self.value = value
	end

	local function GetValue(self)
		return self.value
	end

	local function SetList(self, list) -- Set the list of values for the dropdown (key => value pairs)
		self.list = list or Media:HashTable("statusbar")
	end


	local function SetText(self, text) -- Set the text displayed in the box.
		self.frame.text:SetText(text or "")
		local statusbar = self.list and self.list[text] ~= text and self.list[text] or Media:Fetch('statusbar',text)
		self.bar:SetTexture(statusbar)
	end

	local function SetLabel(self, text) -- Set the text for the label.
		self.frame.label:SetText(text or "")
	end

	local function AddItem(self, key, value) -- Add an item to the list.
		self.list = self.list or {}
		self.list[key] = value
	end
	local SetItemValue = AddItem -- Set the value of a item in the list. <<same as adding a new item>>

	local function SetMultiselect(self, flag) end -- Toggle multi-selecting. <<Dummy function to stay inline with the dropdown API>>
	local function GetMultiselect() return false end-- Query the multi-select flag. <<Dummy function to stay inline with the dropdown API>>
	local function SetItemDisabled(self, key) end-- Disable one item in the list. <<Dummy function to stay inline with the dropdown API>>

	local function SetDisabled(self, disabled) -- Disable the widget.
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
		else
			self.frame:Enable()
		end
	end

	local function textSort(a,b)
		return string.upper(a) < string.upper(b)
	end

	
	local function ToggleDrop()
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
			AceGUI:ClearFocus()
		else
			AceGUI:SetFocus(self)
			self.dropdown = AGSMW:GetDropDownFrame()
			local width = self.frame:GetWidth()
			self.dropdown:SetPoint("TOPLEFT", self.frame, "BOTTOMLEFT")
			self.dropdown:SetPoint("TOPRIGHT", self.frame, "BOTTOMRIGHT", width < 160 and (160 - width) or 0, 0)
			local sortedlist = {}
			for k, v in pairs(self.list) do
				sortedlist[getn(sortedlist)+1] = k
			end
			table.sort(sortedlist, textSort)
			for i, k in ipairs(sortedlist) do
				local f = GetContentLine()
				f.text:SetText(k)
				--print(k)
				if k == self.value then
					f.check:Show()
				end

				local statusbar = self.list[k] ~= k and self.list[k] or Media:Fetch('statusbar',k)
				f.bar:SetTexture(statusbar)
				f.obj = self
				f.dropdown = self.dropdown
				self.dropdown:AddFrame(f)
			end
			fixlevels(self.dropdown, self.dropdown:GetChildren())
		end
	end

	local function ClearFocus(self)
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function OnHide()
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function Drop_OnEnter()
		this.obj:Fire("OnEnter")
	end

	local function Drop_OnLeave()
		this.obj:Fire("OnLeave")
	end

	local function Constructor()
		local frame = AGSMW:GetBaseFrame()
		local self = {}

		self.type = widgetType
		self.frame = frame
		frame.obj = self
		frame.dropButton.obj = self
		frame.dropButton:SetScript("OnEnter", Drop_OnEnter)
		frame.dropButton:SetScript("OnLeave", Drop_OnLeave)
		frame.dropButton:SetScript("OnClick",ToggleDrop)
		frame:SetScript("OnHide", OnHide)

		local bar = frame:CreateTexture(nil, "OVERLAY")
			bar:SetPoint("TOPLEFT", frame,"TOPLEFT",6,-25)
			bar:SetPoint("BOTTOMRIGHT", frame,"BOTTOMRIGHT", -21, 5)
			bar:SetAlpha(0.5)
		self.bar = bar

		self.alignoffset = 31

		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.ClearFocus = ClearFocus
		self.SetText = SetText
		self.SetValue = SetValue
		self.GetValue = GetValue
		self.SetList = SetList
		self.SetLabel = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.ToggleDrop = ToggleDrop

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

end

================
File: Libs/vanilla/Ace3/AceGUI-3.0-SharedMediaWidgets/widget.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="prototypes.lua" />
	<Script file="FontWidget.lua" />
	<Script file="SoundWidget.lua" />
	<Script file="StatusbarWidget.lua" />
	<Script file="BorderWidget.lua" />
	<Script file="BackgroundWidget.lua" />
</Ui>

================
File: Libs/vanilla/Ace3/AceGUI-3.0/AceGUI-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceGUI-3.0.lua"/>
	<Include file="widgets\widgets.xml"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-BlizOptionsGroup.lua
================
--[[-----------------------------------------------------------------------------
BlizOptionsGroup Container
Simple container widget for the integration of AceGUI into the Blizzard Interface Options
-------------------------------------------------------------------------------]]
local Type, Version = "BlizOptionsGroup", 22
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame = CreateFrame

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]

local function OnShow(frame)
	this.obj:Fire("OnShow")
end

local function OnHide(frame)
	this.obj:Fire("OnHide")
end

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]

local function okay(frame)
	frame.obj:Fire("okay")
end

local function cancel(frame)
	frame.obj:Fire("cancel")
end

local function default(frame)
	frame.obj:Fire("default")
end

local function refresh(frame)
	frame.obj:Fire("refresh")
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]

local methods = {
	["OnAcquire"] = function(self)
		self:SetName()
		self:SetTitle()
	end,

	-- ["OnRelease"] = nil,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local contentwidth = width - 63
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - 26
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end,

	["SetName"] = function(self, name, parent)
		self.frame.name = name
		self.frame.parent = parent
	end,

	["SetTitle"] = function(self, title)
		local content = self.content
		content:ClearAllPoints()
		if not title or title == "" then
			content:SetPoint("TOPLEFT", 10, -10)
			self.label:SetText("")
		else
			content:SetPoint("TOPLEFT", 10, -40)
			self.label:SetText(title)
		end
		content:SetPoint("BOTTOMRIGHT", -10, 10)
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Frame")
	frame:Hide()

	-- support functions for the Blizzard Interface Options
	frame.okay = okay
	frame.cancel = cancel
	frame.default = default
	frame.refresh = refresh

	frame:SetScript("OnHide", OnHide)
	frame:SetScript("OnShow", OnShow)

	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
	label:SetPoint("TOPLEFT", 10, -15)
	label:SetPoint("BOTTOMRIGHT", frame, "TOPRIGHT", 10, -45)
	label:SetJustifyH("LEFT")
	label:SetJustifyV("TOP")

	--Container Support
	local content = CreateFrame("Frame", nil, frame)
	content:SetPoint("TOPLEFT", 10, -10)
	content:SetPoint("BOTTOMRIGHT", -10, 10)

	local widget = {
		label   = label,
		frame   = frame,
		content = content,
		type    = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-DropDownGroup.lua
================
--[[-----------------------------------------------------------------------------
DropdownGroup Container
Container controlled by a dropdown on the top.
-------------------------------------------------------------------------------]]
local Type, Version = "DropdownGroup", 21
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local assert, pairs, type = assert, pairs, type

-- WoW APIs
local CreateFrame = CreateFrame

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function SelectedGroup(self, event, _, value)
	local group = self.parentgroup
	local status = group.status or group.localstatus
	status.selected = value
	self.parentgroup:Fire("OnGroupSelected", 1, value)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self.dropdown:SetText("")
		self:SetDropdownWidth(200)
		self:SetTitle("")
	end,

	["OnRelease"] = function(self)
		self.dropdown.list = nil
		self.status = nil
		for k in pairs(self.localstatus) do
			self.localstatus[k] = nil
		end
	end,

	["SetTitle"] = function(self, title)
		self.titletext:SetText(title)
		self.dropdown.frame:ClearAllPoints()
		if title and title ~= "" then
			self.dropdown.frame:SetPoint("TOPRIGHT", -2, 0)
		else
			self.dropdown.frame:SetPoint("TOPLEFT", -1, 0)
		end
	end,

	["SetGroupList"] = function(self,list,order)
		self.dropdown:SetList(list,order)
	end,

	["SetStatusTable"] = function(self, status)
		assert(type(status) == "table")
		self.status = status
	end,

	["SetGroup"] = function(self,group)
		self.dropdown:SetValue(group)
		local status = self.status or self.localstatus
		status.selected = group
		self:Fire("OnGroupSelected", 1, group)
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local contentwidth = width - 26
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - 63
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end,

	["LayoutFinished"] = function(self, width, height)
		self:SetHeight((height or 0) + 63)
	end,

	["SetDropdownWidth"] = function(self, width)
		self.dropdown:SetWidth(width)
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local PaneBackdrop  = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 5, bottom = 3 }
}

local function Constructor()
	local frame = CreateFrame("Frame")
	frame:SetHeight(100)
	frame:SetWidth(100)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")

	local titletext = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	titletext:SetPoint("TOPLEFT", 4, -5)
	titletext:SetPoint("TOPRIGHT", -4, -5)
	titletext:SetJustifyH("LEFT")
	titletext:SetHeight(18)

	local dropdown = AceGUI:Create("Dropdown")
	dropdown.frame:SetParent(frame)
	dropdown.frame:SetFrameLevel(dropdown.frame:GetFrameLevel() + 2)
	dropdown:SetCallback("OnValueChanged", SelectedGroup)
	dropdown.frame:SetPoint("TOPLEFT", -1, 0)
	dropdown.frame:Show()
	dropdown:SetLabel("")

	local border = CreateFrame("Frame", nil, frame)
	border:SetPoint("TOPLEFT", 0, -26)
	border:SetPoint("BOTTOMRIGHT", 0, 3)
	border:SetBackdrop(PaneBackdrop)
	border:SetBackdropColor(0.1,0.1,0.1,0.5)
	border:SetBackdropBorderColor(0.4,0.4,0.4)

	--Container Support
	local content = CreateFrame("Frame", nil, border)
	content:SetPoint("TOPLEFT", 10, -10)
	content:SetPoint("BOTTOMRIGHT", -10, 10)

	local widget = {
		frame       = frame,
		localstatus = {},
		titletext   = titletext,
		dropdown    = dropdown,
		border      = border,
		content     = content,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	dropdown.parentgroup = widget

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-Frame.lua
================
--[[-----------------------------------------------------------------------------
Frame Container
-------------------------------------------------------------------------------]]
local Type, Version = "Frame", 24
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local AceCore = LibStub("AceCore-3.0")
local wipe = AceCore.wipe

-- Lua APIs
local pairs, assert, type = pairs, assert, type

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame, UIParent = CreateFrame, UIParent

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: CLOSE

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Button_OnClick()
	PlaySound("gsTitleOptionExit")
	this.obj:Hide()
end

local function Frame_OnClose()
	this.obj:Fire("OnClose")
end

local function Frame_OnMouseDown()
	AceGUI:ClearFocus()
end

local function Title_OnMouseDown()
	this:GetParent():StartMoving()
	AceGUI:ClearFocus()
end

local function MoverSizer_OnMouseUp()
	local frame = this:GetParent()
	frame:StopMovingOrSizing()
	local self = frame.obj
	local status = self.status or self.localstatus
	status.width = frame:GetWidth()
	status.height = frame:GetHeight()
	status.top = frame:GetTop()
	status.left = frame:GetLeft()
end

local function SizerSE_OnMouseDown()
	this:GetParent():StartSizing("BOTTOMRIGHT")
	AceGUI:ClearFocus()
end

local function SizerS_OnMouseDown()
	this:GetParent():StartSizing("BOTTOM")
	AceGUI:ClearFocus()
end

local function SizerE_OnMouseDown()
	this:GetParent():StartSizing("RIGHT")
	AceGUI:ClearFocus()
end

local function StatusBar_OnEnter()
	this.obj:Fire("OnEnterStatusBar")
end

local function StatusBar_OnLeave()
	this.obj:Fire("OnLeaveStatusBar")
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self.frame:SetParent(UIParent)
		self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
		self:SetTitle()
		self:SetStatusText()
		self:ApplyStatus()
		self:Show()
		self:EnableResize(true)
	end,

	["OnRelease"] = function(self)
		self.status = nil
		wipe(self.localstatus)
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local contentwidth = width - 34
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - 57
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end,

	["SetTitle"] = function(self, title)
		self.titletext:SetText(title)
		self.titlebg:SetWidth((self.titletext:GetWidth() or 0) + 10)
	end,

	["SetStatusText"] = function(self, text)
		self.statustext:SetText(text)
	end,

	["Hide"] = function(self)
		self.frame:Hide()
	end,

	["Show"] = function(self)
		self.frame:Show()
	end,

	["EnableResize"] = function(self, state)
		local func = state and "Show" or "Hide"
		self.sizer_se[func](self.sizer_se)
		self.sizer_s[func](self.sizer_s)
		self.sizer_e[func](self.sizer_e)
	end,

	-- called to set an external table to store status in
	["SetStatusTable"] = function(self, status)
		assert(type(status) == "table")
		self.status = status
		self:ApplyStatus()
	end,

	["ApplyStatus"] = function(self)
		local status = self.status or self.localstatus
		local frame = self.frame
		self:SetWidth(status.width or 700)
		self:SetHeight(status.height or 500)
		frame:ClearAllPoints()
		if status.top and status.left then
			frame:SetPoint("TOP", UIParent, "BOTTOM", 0, status.top)
			frame:SetPoint("LEFT", UIParent, "LEFT", status.left, 0)
		else
			frame:SetPoint("CENTER", UIParent)
		end
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local FrameBackdrop = {
	bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background",
	edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
	tile = true, tileSize = 32, edgeSize = 32,
	insets = { left = 8, right = 8, top = 8, bottom = 8 }
}

local PaneBackdrop  = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 5, bottom = 3 }
}

local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:Hide()

	frame:EnableMouse(true)
	frame:SetMovable(true)
	frame:SetResizable(true)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")
	frame:SetBackdrop(FrameBackdrop)
	frame:SetBackdropColor(0, 0, 0, 1)
	frame:SetMinResize(400, 200)
	frame:SetToplevel(true)
	frame:SetScript("OnHide", Frame_OnClose)
	frame:SetScript("OnMouseDown", Frame_OnMouseDown)

	local closebutton = CreateFrame("Button", nil, frame, "UIPanelButtonTemplate")
	closebutton:SetScript("OnClick", Button_OnClick)
	closebutton:SetPoint("BOTTOMRIGHT", -27, 17)
	closebutton:SetHeight(20)
	closebutton:SetWidth(100)
	closebutton:SetText(CLOSE)

	local statusbg = CreateFrame("Button", nil, frame)
	statusbg:SetPoint("BOTTOMLEFT", 15, 15)
	statusbg:SetPoint("BOTTOMRIGHT", -132, 15)
	statusbg:SetHeight(24)
	statusbg:SetBackdrop(PaneBackdrop)
	statusbg:SetBackdropColor(0.1,0.1,0.1)
	statusbg:SetBackdropBorderColor(0.4,0.4,0.4)
	statusbg:SetScript("OnEnter", StatusBar_OnEnter)
	statusbg:SetScript("OnLeave", StatusBar_OnLeave)

	local statustext = statusbg:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	statustext:SetPoint("TOPLEFT", 7, -2)
	statustext:SetPoint("BOTTOMRIGHT", -7, 2)
	statustext:SetHeight(20)
	statustext:SetJustifyH("LEFT")
	statustext:SetText("")

	local titlebg = frame:CreateTexture(nil, "OVERLAY")
	titlebg:SetTexture("Interface\\DialogFrame\\UI-DialogBox-Header")
	titlebg:SetTexCoord(0.31, 0.67, 0, 0.63)
	titlebg:SetPoint("TOP", 0, 12)
	titlebg:SetWidth(100)
	titlebg:SetHeight(40)

	local title = CreateFrame("Frame", nil, frame)
	title:EnableMouse(true)
	title:SetScript("OnMouseDown", Title_OnMouseDown)
	title:SetScript("OnMouseUp", MoverSizer_OnMouseUp)
	title:SetAllPoints(titlebg)

	local titletext = title:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	titletext:SetPoint("TOP", titlebg, "TOP", 0, -14)

	local titlebg_l = frame:CreateTexture(nil, "OVERLAY")
	titlebg_l:SetTexture("Interface\\DialogFrame\\UI-DialogBox-Header")
	titlebg_l:SetTexCoord(0.21, 0.31, 0, 0.63)
	titlebg_l:SetPoint("RIGHT", titlebg, "LEFT")
	titlebg_l:SetWidth(30)
	titlebg_l:SetHeight(40)

	local titlebg_r = frame:CreateTexture(nil, "OVERLAY")
	titlebg_r:SetTexture("Interface\\DialogFrame\\UI-DialogBox-Header")
	titlebg_r:SetTexCoord(0.67, 0.77, 0, 0.63)
	titlebg_r:SetPoint("LEFT", titlebg, "RIGHT")
	titlebg_r:SetWidth(30)
	titlebg_r:SetHeight(40)

	-- bottom right sizer
	local sizer_se = CreateFrame("Frame", nil, frame)
	sizer_se:SetPoint("BOTTOMRIGHT", 0, 0)
	sizer_se:SetWidth(25)
	sizer_se:SetHeight(25)
	sizer_se:EnableMouse()
	sizer_se:SetScript("OnMouseDown",SizerSE_OnMouseDown)
	sizer_se:SetScript("OnMouseUp", MoverSizer_OnMouseUp)

	local line1 = sizer_se:CreateTexture(nil, "BACKGROUND")
	line1:SetPoint("BOTTOMRIGHT", -10, 10)
	line1:SetTexture("Interface\\Cursor\\Item")
	line1:SetTexCoord(1, 0, 1, 0)

	local sizer_s = CreateFrame("Frame", nil, frame)
	sizer_s:SetPoint("BOTTOMRIGHT", -25, 0)
	sizer_s:SetPoint("BOTTOMLEFT", 0, 0)
	sizer_s:SetHeight(25)
	sizer_s:EnableMouse(true)
	sizer_s:SetScript("OnMouseDown", SizerS_OnMouseDown)
	sizer_s:SetScript("OnMouseUp", MoverSizer_OnMouseUp)

	local sizer_e = CreateFrame("Frame", nil, frame)
	sizer_e:SetPoint("BOTTOMRIGHT", 0, 25)
	sizer_e:SetPoint("TOPRIGHT", 0, 0)
	sizer_e:SetWidth(25)
	sizer_e:EnableMouse(true)
	sizer_e:SetScript("OnMouseDown", SizerE_OnMouseDown)
	sizer_e:SetScript("OnMouseUp", MoverSizer_OnMouseUp)

	--Container Support
	local content = CreateFrame("Frame", nil, frame)
	content:SetPoint("TOPLEFT", 17, -27)
	content:SetPoint("BOTTOMRIGHT", -17, 40)

	local widget = {
		localstatus = {},
		titletext   = titletext,
		statustext  = statustext,
		titlebg     = titlebg,
		sizer_se    = sizer_se,
		sizer_s     = sizer_s,
		sizer_e     = sizer_e,
		content     = content,
		frame       = frame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	closebutton.obj, statusbg.obj = widget, widget

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-InlineGroup.lua
================
--[[-----------------------------------------------------------------------------
InlineGroup Container
Simple container widget that creates a visible "box" with an optional title.
-------------------------------------------------------------------------------]]
local Type, Version = "InlineGroup", 21
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetWidth(300)
		self:SetHeight(100)
		self:SetTitle("")
	end,

	-- ["OnRelease"] = nil,

	["SetTitle"] = function(self,title)
		self.titletext:SetText(title)
	end,


	["LayoutFinished"] = function(self, width, height)
		if self.noAutoHeight then return end
		self:SetHeight((height or 0) + 40)
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local contentwidth = width - 20
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - 20
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local PaneBackdrop  = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 5, bottom = 3 }
}

local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")

	local titletext = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	titletext:SetPoint("TOPLEFT", 14, 0)
	titletext:SetPoint("TOPRIGHT", -14, 0)
	titletext:SetJustifyH("LEFT")
	titletext:SetHeight(18)

	local border = CreateFrame("Frame", nil, frame)
	border:SetPoint("TOPLEFT", 0, -17)
	border:SetPoint("BOTTOMRIGHT", -1, 3)
	border:SetBackdrop(PaneBackdrop)
	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
	border:SetBackdropBorderColor(0.4, 0.4, 0.4)

	--Container Support
	local content = CreateFrame("Frame", nil, border)
	content:SetPoint("TOPLEFT", 10, -10)
	content:SetPoint("BOTTOMRIGHT", -10, 10)

	local widget = {
		frame     = frame,
		content   = content,
		titletext = titletext,
		type      = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-SimpleGroup.lua
================
--[[-----------------------------------------------------------------------------
SimpleGroup Container
Simple container widget that just groups widgets.
-------------------------------------------------------------------------------]]
local Type, Version = "SimpleGroup", 21
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent


--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetWidth(300)
		self:SetHeight(100)
	end,

	-- ["OnRelease"] = nil,

	["LayoutFinished"] = function(self, width, height)
		if self.noAutoHeight then return end
		self:SetHeight(height or 0)
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		content:SetWidth(width)
		content.width = width
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		content:SetHeight(height)
		content.height = height
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")

	--Container Support
	local content = CreateFrame("Frame", nil, frame)
	content:SetPoint("TOPLEFT",0,0)
	content:SetPoint("BOTTOMRIGHT",0,0)

	local widget = {
		frame     = frame,
		content   = content,
		type      = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-TabGroup.lua
================
--[[-----------------------------------------------------------------------------
TabGroup Container
Container that uses tabs on top to switch between groups.
-------------------------------------------------------------------------------]]
local Type, Version = "TabGroup", 36
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local AceCore = LibStub("AceCore-3.0")
local wipe = AceCore.wipe

-- Lua APIs
local pairs, ipairs, assert, type, wipe = pairs, ipairs, assert, type, wipe
local tgetn = table.getn
local strfmt = string.format

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame, UIParent = CreateFrame, UIParent
local _G = AceCore._G

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: PanelTemplates_TabResize, PanelTemplates_SetDisabledTabState, PanelTemplates_SelectTab, PanelTemplates_DeselectTab

-- local upvalue storage used by BuildTabs
local widths = {}
local rowwidths = {}
local rowends = {}

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function UpdateTabLook(frame)
	if frame.disabled then
		PanelTemplates_SetDisabledTabState(frame)
		frame:SetAlpha(0.5)
	elseif frame.selected then
		PanelTemplates_SelectTab(frame)
		frame:SetAlpha(1)
	else
		PanelTemplates_DeselectTab(frame)
		frame:SetAlpha(0.8)
	end
end

local function Tab_SetText(tab, text)
	tab:_SetText(text)
	local width = tab.obj.frame.width or tab.obj.frame:GetWidth() or 0
	PanelTemplates_TabResize(0, tab, nil, width)
end

local function Tab_SetSelected(tab, selected)
	tab.selected = selected
	UpdateTabLook(tab)
end

local function Tab_SetDisabled(tab, disabled)
	tab.disabled = disabled
	UpdateTabLook(tab)
end

local function BuildTabsOnUpdate()
	local self = this.obj
	self:BuildTabs()
	this:SetScript("OnUpdate", nil)
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Tab_OnClick()
	if not (this.selected or this.disabled) then
		PlaySound("igCharacterInfoTab")
		this.obj:SelectTab(this.value)
	end
end

local function Tab_OnEnter()
	local self = this.obj
	self:Fire("OnTabEnter", 2, self.tabs[this.id].value, this)
end

local function Tab_OnLeave()
	local self = this.obj
	self:Fire("OnTabLeave", 2, self.tabs[this.id].value, this)
end

local function Tab_OnShow()
	_G[this:GetName().."HighlightTexture"]:SetWidth(this:GetTextWidth() + 30)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetTitle()
	end,

	["OnRelease"] = function(self)
		self.status = nil
		for k in pairs(self.localstatus) do
			self.localstatus[k] = nil
		end
		self.tablist = nil
		for _, tab in pairs(self.tabs) do
			tab:Hide()
		end
	end,

	["CreateTab"] = function(self, id)
		local tabname = strfmt("AceGUITabGroup%dTab%d", self.num, id)
		local tab = CreateFrame("Button", tabname, self.border, "TabButtonTemplate")
		-- Normal texture
		local texture = getglobal(tabname.."Left")
		texture:SetTexture("Interface\\ChatFrame\\ChatFrameTab")
		texture:ClearAllPoints()
		texture:SetPoint("BOTTOMLEFT", tab,"BOTTOMLEFT")
		texture:SetPoint("TOPLEFT", tab,"TOPLEFT")
		texture = getglobal(tabname.."Middle")
		texture:SetTexture("Interface\\ChatFrame\\ChatFrameTab")
		texture = getglobal(tabname.."Right")
		texture:SetTexture("Interface\\ChatFrame\\ChatFrameTab")
		-- Disabled texture
		texture = getglobal(tabname.."LeftDisabled")
		texture:SetTexture("Interface\\ChatFrame\\ChatFrameTab")
		texture:SetPoint("BOTTOMLEFT", tab,"BOTTOMLEFT")
		texture:SetPoint("TOPLEFT", tab,"TOPLEFT")
		texture = getglobal(tabname.."MiddleDisabled")
		texture:SetTexture("Interface\\ChatFrame\\ChatFrameTab")
		texture = getglobal(tabname.."RightDisabled")
		texture:SetTexture("Interface\\ChatFrame\\ChatFrameTab")

		tab.obj = self
		tab.id = id

		tab:SetScript("OnClick", Tab_OnClick)
		tab:SetScript("OnEnter", Tab_OnEnter)
		tab:SetScript("OnLeave", Tab_OnLeave)
		tab:SetScript("OnShow", Tab_OnShow)

		tab._SetText = tab.SetText
		tab.SetText = Tab_SetText
		tab.SetSelected = Tab_SetSelected
		tab.SetDisabled = Tab_SetDisabled

		return tab
	end,

	["SetTitle"] = function(self, text)
		self.titletext:SetText(text or "")
		if text and text ~= "" then
			self.alignoffset = 25
		else
			self.alignoffset = 18
		end
		self:BuildTabs()
	end,

	["SetStatusTable"] = function(self, status)
		assert(type(status) == "table")
		self.status = status
	end,

	["SelectTab"] = function(self, value)
		local status = self.status or self.localstatus
		local found
		for i, v in ipairs(self.tabs) do
			if v.value == value then
				v:SetSelected(true)
				found = true
			else
				v:SetSelected(false)
			end
		end
		status.selected = value
		if found then
			self:Fire("OnGroupSelected",1,value)
		end
	end,

	["SetTabs"] = function(self, tabs)
		self.tablist = tabs
		self:BuildTabs()
	end,


	["BuildTabs"] = function(self)
		local hastitle = (self.titletext:GetText() and self.titletext:GetText() ~= "")
		local status = self.status or self.localstatus
		local tablist = self.tablist
		local tabs = self.tabs

		if not tablist then return end

		local width = self.frame.width or self.frame:GetWidth() or 0

		wipe(widths)
		wipe(rowwidths)
		wipe(rowends)

		--Place Text into tabs and get thier initial width
		for i, v in ipairs(tablist) do
			local tab = tabs[i]
			if not tab then
				tab = self:CreateTab(i)
				tabs[i] = tab
			end

			tab:Show()
			if type(v) == "table" then
				tab:SetText(v.text)
				tab:SetDisabled(v.disabled)
				tab.value = v.value
			elseif type(v) == "string" then
				tab:SetText(v)
				tab.value = v
			end

			widths[i] = tab:GetWidth() - 6 --tabs are anchored 10 pixels from the right side of the previous one to reduce spacing, but add a fixed 4px padding for the text
		end

		for i = tgetn(tablist)+1, tgetn(tabs), 1 do
			tabs[i]:Hide()
		end

		--First pass, find the minimum number of rows needed to hold all tabs and the initial tab layout
		local numtabs = tgetn(tablist)
		local numrows = 1
		local usedwidth = 0

		for i = 1, tgetn(tablist) do
			--If this is not the first tab of a row and there isn't room for it
			if usedwidth ~= 0 and (width - usedwidth - widths[i]) < 0 then
				rowwidths[numrows] = usedwidth + 10 --first tab in each row takes up an extra 10px
				rowends[numrows] = i - 1
				numrows = numrows + 1
				usedwidth = 0
			end
			usedwidth = usedwidth + widths[i]
		end
		rowwidths[numrows] = usedwidth + 10 --first tab in each row takes up an extra 10px
		rowends[numrows] = tgetn(tablist)

		--Fix for single tabs being left on the last row, move a tab from the row above if applicable
		if numrows > 1 then
			--if the last row has only one tab
			if rowends[numrows-1] == numtabs-1 then
				--if there are more than 2 tabs in the 2nd last row
				if (numrows == 2 and rowends[numrows-1] > 2) or (rowends[numrows] - rowends[numrows-1] > 2) then
					--move 1 tab from the second last row to the last, if there is enough space
					if (rowwidths[numrows] + widths[numtabs-1]) <= width then
						rowends[numrows-1] = rowends[numrows-1] - 1
						rowwidths[numrows] = rowwidths[numrows] + widths[numtabs-1]
						rowwidths[numrows-1] = rowwidths[numrows-1] - widths[numtabs-1]
					end
				end
			end
		end

		--anchor the rows as defined and resize tabs to fill thier row
		local starttab = 1
		for row, endtab in ipairs(rowends) do
			local first = true
			for tabno = starttab, endtab do
				local tab = tabs[tabno]
				tab:ClearAllPoints()
				if first then
					tab:SetPoint("TOPLEFT", self.frame, "TOPLEFT", 0, -(hastitle and 14 or 7)-(row-1)*20 )
					first = false
				else
					tab:SetPoint("LEFT", tabs[tabno-1], "RIGHT", -10, 0)
				end
			end

			-- equal padding for each tab to fill the available width,
			-- if the used space is above 75% already
			-- the 18 pixel is the typical width of a scrollbar, so we can have a tab group inside a scrolling frame,
			-- and not have the tabs jump around funny when switching between tabs that need scrolling and those that don't
			local padding = 0
			if not (numrows == 1 and rowwidths[1] < width*0.75 - 18) then
				padding = (width - rowwidths[row]) / (endtab - starttab+1)
			end

			for i = starttab, endtab do
				PanelTemplates_TabResize(padding + 4, tabs[i], nil, width)
			end
			starttab = endtab + 1
		end

		self.borderoffset = (hastitle and 17 or 10)+((numrows)*20)+7
		self.border:SetPoint("TOPLEFT", 1, -self.borderoffset)
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local contentwidth = width - 60
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth
		self:BuildTabs(self)
		self.frame:SetScript("OnUpdate", BuildTabsOnUpdate)
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - (self.borderoffset + 23)
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end,

	["LayoutFinished"] = function(self, width, height)
		if self.noAutoHeight then return end
		self:SetHeight((height or 0) + (self.borderoffset + 23))
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local PaneBackdrop  = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 5, bottom = 3 }
}

local function Constructor()
	local num = AceGUI:GetNextWidgetNum(Type)
	local frame = CreateFrame("Frame",nil,UIParent)
	frame:SetHeight(100)
	frame:SetWidth(100)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")

	local titletext = frame:CreateFontString(nil,"OVERLAY","GameFontNormal")
	titletext:SetPoint("TOPLEFT", 14, 0)
	titletext:SetPoint("TOPRIGHT", -14, 0)
	titletext:SetJustifyH("LEFT")
	titletext:SetHeight(18)
	titletext:SetText("")

	local border = CreateFrame("Frame", nil, frame)
	border:SetPoint("TOPLEFT", 1, -27)
	border:SetPoint("BOTTOMRIGHT", -1, 3)
	border:SetBackdrop(PaneBackdrop)
	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
	border:SetBackdropBorderColor(0.4, 0.4, 0.4)

	local content = CreateFrame("Frame", nil, border)
	content:SetPoint("TOPLEFT", 10, -7)
	content:SetPoint("BOTTOMRIGHT", -10, 7)

	local widget = {
		num          = num,
		frame        = frame,
		localstatus  = {},
		alignoffset  = 18,
		titletext    = titletext,
		border       = border,
		borderoffset = 27,
		tabs         = {},
		content      = content,
		type         = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-Button.lua
================
--[[-----------------------------------------------------------------------------
Button Widget
Graphical Button.
-------------------------------------------------------------------------------]]
local Type, Version = "Button", 23
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local AceCore = LibStub("AceCore-3.0")

-- Lua APIs
local pairs = pairs

-- WoW APIs
local _G = AceCore._G
local PlaySound, CreateFrame, UIParent = PlaySound, CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
-- arg1 is the button for OnClick event
local function Button_OnClick()
	AceGUI:ClearFocus()
	PlaySound("igMainMenuOption")
	this.obj:Fire("OnClick", 1, arg1)
end

local function Control_OnEnter()
	this.obj:Fire("OnEnter")
end

local function Control_OnLeave()
	this.obj:Fire("OnLeave")
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		-- restore default values
		self:SetHeight(24)
		self:SetWidth(200)
		self:SetDisabled(false)
		self:SetAutoWidth(false)
		self:SetText()
	end,

	-- ["OnRelease"] = nil,

	["SetText"] = function(self, text)
		self.text:SetText(text)
		if self.autoWidth then
			self:SetWidth(self.text:GetStringWidth() + 30)
		end
	end,
	
	["SetAutoWidth"] = function(self, autoWidth)
		self.autoWidth = autoWidth
		if self.autoWidth then
			self:SetWidth(self.text:GetStringWidth() + 30)
		end
	end,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
		else
			self.frame:Enable()
		end
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local name = "AceGUI30Button" .. AceGUI:GetNextWidgetNum(Type)
	local frame = CreateFrame("Button", name, UIParent, "UIPanelButtonTemplate2")
	frame:Hide()

	frame:EnableMouse(true)
	frame:SetScript("OnClick", Button_OnClick)
	frame:SetScript("OnEnter", Control_OnEnter)
	frame:SetScript("OnLeave", Control_OnLeave)

	local text = frame:GetFontString()
	text:ClearAllPoints()
	text:SetPoint("TOPLEFT", 15, -1)
	text:SetPoint("BOTTOMRIGHT", -15, 1)
	text:SetJustifyV("MIDDLE")

	local widget = {
		text  = text,
		frame = frame,
		type  = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-CheckBox.lua
================
--[[-----------------------------------------------------------------------------
Checkbox Widget
-------------------------------------------------------------------------------]]
local Type, Version = "CheckBox", 22
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame, UIParent = CreateFrame, UIParent

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: SetDesaturation, GameFontHighlight

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function AlignImage(self)
	local img = self.image:GetTexture()
	self.text:ClearAllPoints()
	if not img then
		self.text:SetPoint("LEFT", self.checkbg, "RIGHT")
		self.text:SetPoint("RIGHT",0,0)
	else
		self.text:SetPoint("LEFT", self.image,"RIGHT", 1, 0)
		self.text:SetPoint("RIGHT",0,0)
	end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter()
	this.obj:Fire("OnEnter")
end

local function Control_OnLeave()
	this.obj:Fire("OnLeave")
end

local function CheckBox_OnMouseDown()
	local self = this.obj
	if not self.disabled then
		if self.image:GetTexture() then
			self.text:SetPoint("LEFT", self.image,"RIGHT", 2, -1)
		else
			self.text:SetPoint("LEFT", self.checkbg, "RIGHT", 1, -1)
		end
	end
	AceGUI:ClearFocus()
end

local function CheckBox_OnMouseUp()

	local self = this.obj
	if not self.disabled then
		self:ToggleChecked()

		if self.checked then
			PlaySound("igMainMenuOptionCheckBoxOn")
		else -- for both nil and false (tristate)
			PlaySound("igMainMenuOptionCheckBoxOff")
		end

		self:Fire("OnValueChanged", 1, self.checked)
		AlignImage(self)
	end
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetType()
		self:SetValue(false)
		self:SetTriState(nil)
		-- height is calculated from the width and required space for the description
		self:SetWidth(200)
		self:SetImage()
		self:SetDisabled(nil)
		self:SetDescription(nil)
	end,

	-- ["OnRelease"] = nil,

	["OnWidthSet"] = function(self, width)
		if self.desc then
			self.desc:SetWidth(width - 30)
			if self.desc:GetText() and self.desc:GetText() ~= "" then
				self:SetHeight(28 + self.desc:GetHeight())
			end
		end
	end,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
			self.text:SetTextColor(0.5, 0.5, 0.5)
			SetDesaturation(self.check, true)
			if self.desc then
				self.desc:SetTextColor(0.5, 0.5, 0.5)
			end
		else
			self.frame:Enable()
			self.text:SetTextColor(1, 1, 1)
			if self.tristate and self.checked == nil then
				SetDesaturation(self.check, true)
			else
				SetDesaturation(self.check, false)
			end
			if self.desc then
				self.desc:SetTextColor(1, 1, 1)
			end
		end
	end,

	["SetValue"] = function(self,value)
		local check = self.check
		self.checked = value
		if value then
			SetDesaturation(self.check, false)
			self.check:Show()
		else
			--Nil is the unknown tristate value
			if self.tristate and value == nil then
				SetDesaturation(self.check, true)
				self.check:Show()
			else
				SetDesaturation(self.check, false)
				self.check:Hide()
			end
		end
		self:SetDisabled(self.disabled)
	end,

	["GetValue"] = function(self)
		return self.checked
	end,

	["SetTriState"] = function(self, enabled)
		self.tristate = enabled
		self:SetValue(self:GetValue())
	end,

	["SetType"] = function(self, type)
		local checkbg = self.checkbg
		local check = self.check
		local highlight = self.highlight

		local size
		if type == "radio" then
			size = 16
			checkbg:SetTexture("Interface\\Buttons\\UI-RadioButton")
			checkbg:SetTexCoord(0, 0.25, 0, 1)
			check:SetTexture("Interface\\Buttons\\UI-RadioButton")
			check:SetTexCoord(0.25, 0.5, 0, 1)
			check:SetBlendMode("ADD")
			highlight:SetTexture("Interface\\Buttons\\UI-RadioButton")
			highlight:SetTexCoord(0.5, 0.75, 0, 1)
		else
			size = 24
			checkbg:SetTexture("Interface\\Buttons\\UI-CheckBox-Up")
			checkbg:SetTexCoord(0, 1, 0, 1)
			check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
			check:SetTexCoord(0, 1, 0, 1)
			check:SetBlendMode("BLEND")
			highlight:SetTexture("Interface\\Buttons\\UI-CheckBox-Highlight")
			highlight:SetTexCoord(0, 1, 0, 1)
		end

		checkbg:SetHeight(size)
		checkbg:SetWidth(size)
	end,

	["ToggleChecked"] = function(self)
		local value = self:GetValue()
		if self.tristate then
			--cycle in true, nil, false order
			if value then
				self:SetValue(nil)
			elseif value == nil then
				self:SetValue(false)
			else
				self:SetValue(true)
			end
		else
			self:SetValue(not self:GetValue())
		end
	end,

	["SetLabel"] = function(self, label)
		self.text:SetText(label)
	end,

	["SetDescription"] = function(self, desc)
		if desc then
			if not self.desc then
				local desc = self.frame:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
				desc:ClearAllPoints()
				desc:SetPoint("TOPLEFT", self.checkbg, "TOPRIGHT", 5, -21)
				desc:SetWidth(self.frame.width - 30)
				desc:SetJustifyH("LEFT")
				desc:SetJustifyV("TOP")
				self.desc = desc
			end
			self.desc:Show()
			--self.text:SetFontObject(GameFontNormal)
			self.desc:SetText(desc)
			self:SetHeight(28 + self.desc:GetHeight())
		else
			if self.desc then
				self.desc:SetText("")
				self.desc:Hide()
			end
			--self.text:SetFontObject(GameFontHighlight)
			self:SetHeight(24)
		end
	end,

	["SetImage"] = function(self, path, a1,a2,a3,a4,a5,a6,a7,a8)
		local image = self.image
		image:SetTexture(path)

		if image:GetTexture() then
			if a4 or a8 then
				image:SetTexCoord(a1,a2,a3,a4,a5,a6,a7,a8)
			else
				image:SetTexCoord(0, 1, 0, 1)
			end
		end
		AlignImage(self)
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Button", nil, UIParent)
	frame:Hide()

	frame:EnableMouse(true)
	frame:SetScript("OnEnter", Control_OnEnter)
	frame:SetScript("OnLeave", Control_OnLeave)
	frame:SetScript("OnMouseDown", CheckBox_OnMouseDown)
	frame:SetScript("OnMouseUp", CheckBox_OnMouseUp)

	local checkbg = frame:CreateTexture(nil, "ARTWORK")
	checkbg:SetWidth(24)
	checkbg:SetHeight(24)
	checkbg:SetPoint("TOPLEFT",0,0)
	checkbg:SetTexture("Interface\\Buttons\\UI-CheckBox-Up")

	local check = frame:CreateTexture(nil, "OVERLAY")
	check:SetAllPoints(checkbg)
	check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")

	local text = frame:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
	text:SetJustifyH("LEFT")
	text:SetHeight(18)
	text:SetPoint("LEFT", checkbg, "RIGHT")
	text:SetPoint("RIGHT",0,0)

	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
	highlight:SetTexture("Interface\\Buttons\\UI-CheckBox-Highlight")
	highlight:SetBlendMode("ADD")
	highlight:SetAllPoints(checkbg)

	local image = frame:CreateTexture(nil, "OVERLAY")
	image:SetHeight(16)
	image:SetWidth(16)
	image:SetPoint("LEFT", checkbg, "RIGHT", 1, 0)

	local widget = {
		checkbg   = checkbg,
		check     = check,
		text      = text,
		highlight = highlight,
		image     = image,
		frame     = frame,
		type      = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-ColorPicker.lua
================
--[[-----------------------------------------------------------------------------
ColorPicker Widget
-------------------------------------------------------------------------------]]
local Type, Version = "ColorPicker", 23
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: ShowUIPanel, HideUIPanel, ColorPickerFrame, OpacitySliderFrame

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function ColorCallback(self, r, g, b, a, isAlpha)
	if not self.HasAlpha then
		a = 1
	end
	self:SetColor(r, g, b, a)
	if ColorPickerFrame:IsVisible() then
		--colorpicker is still open
		self:Fire("OnValueChanged", 4, r, g, b, a)
	else
		--colorpicker is closed, color callback is first, ignore it,
		--alpha callback is the final call after it closes so confirm now
		if isAlpha then
			self:Fire("OnValueConfirmed", 4, r, g, b, a)
		end
	end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter()
	this.obj:Fire("OnEnter")
end

local function Control_OnLeave()
	this.obj:Fire("OnLeave")
end

local function ColorSwatch_OnClick()
	HideUIPanel(ColorPickerFrame)
	local self = this.obj
	if not self.disabled then
		ColorPickerFrame:SetFrameStrata("FULLSCREEN_DIALOG")
		ColorPickerFrame:SetClampedToScreen(true)

		ColorPickerFrame.func = function()
			local r, g, b = ColorPickerFrame:GetColorRGB()
			local a = 1 - OpacitySliderFrame:GetValue()
			ColorCallback(self, r, g, b, a)
		end

		ColorPickerFrame.hasOpacity = self.HasAlpha
		ColorPickerFrame.opacityFunc = function()
			local r, g, b = ColorPickerFrame:GetColorRGB()
			local a = 1 - OpacitySliderFrame:GetValue()
			ColorCallback(self, r, g, b, a, true)
		end

		local r, g, b, a = self.r, self.g, self.b, self.a
		if self.HasAlpha then
			ColorPickerFrame.opacity = 1 - (a or 0)
		end
		ColorPickerFrame:SetColorRGB(r, g, b)

		ColorPickerFrame.cancelFunc = function()
			ColorCallback(self, r, g, b, a, true)
		end

		ShowUIPanel(ColorPickerFrame)
	end
	AceGUI:ClearFocus()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetHeight(24)
		self:SetWidth(200)
		self:SetHasAlpha(false)
		self:SetColor(0, 0, 0, 1)
		self:SetDisabled(nil)
		self:SetLabel(nil)
	end,

	-- ["OnRelease"] = nil,

	["SetLabel"] = function(self, text)
		self.text:SetText(text)
	end,

	["SetColor"] = function(self, r, g, b, a)
		self.r = r
		self.g = g
		self.b = b
		self.a = a or 1
		self.colorSwatch:SetVertexColor(r, g, b, a)
	end,

	["SetHasAlpha"] = function(self, HasAlpha)
		self.HasAlpha = HasAlpha
	end,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if self.disabled then
			self.frame:Disable()
			self.text:SetTextColor(0.5, 0.5, 0.5)
		else
			self.frame:Enable()
			self.text:SetTextColor(1, 1, 1)
		end
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Button", nil, UIParent)
	frame:Hide()

	frame:EnableMouse(true)
	frame:SetScript("OnEnter", Control_OnEnter)
	frame:SetScript("OnLeave", Control_OnLeave)
	frame:SetScript("OnClick", ColorSwatch_OnClick)

	local colorSwatch = frame:CreateTexture(nil, "OVERLAY")
	colorSwatch:SetWidth(19)
	colorSwatch:SetHeight(19)
	colorSwatch:SetTexture("Interface\\ChatFrame\\ChatFrameColorSwatch")
	colorSwatch:SetPoint("LEFT",0,0)

	local texture = frame:CreateTexture(nil, "BACKGROUND")
	texture:SetWidth(16)
	texture:SetHeight(16)
	texture:SetTexture(1, 1, 1)
	texture:SetPoint("CENTER", colorSwatch)
	texture:Show()

	local checkers = frame:CreateTexture(nil, "BACKGROUND")
	checkers:SetWidth(14)
	checkers:SetHeight(14)
	checkers:SetTexture("Tileset\\Generic\\Checkers")
	checkers:SetTexCoord(.25, 0, 0.5, .25)
	checkers:SetDesaturated(true)
	checkers:SetVertexColor(1, 1, 1, 0.75)
	checkers:SetPoint("CENTER", colorSwatch)
	checkers:Show()

	local text = frame:CreateFontString(nil,"OVERLAY","GameFontHighlight")
	text:SetHeight(24)
	text:SetJustifyH("LEFT")
	text:SetTextColor(1, 1, 1)
	text:SetPoint("LEFT", colorSwatch, "RIGHT", 2, 0)
	text:SetPoint("RIGHT",0,0)

	--local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
	--highlight:SetTexture("Interface\\QuestFrame\\UI-QuestTitleHighlight")
	--highlight:SetBlendMode("ADD")
	--highlight:SetAllPoints(frame)

	local widget = {
		colorSwatch = colorSwatch,
		text        = text,
		frame       = frame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-DropDown-Items.lua
================
--[[ $Id: AceGUIWidget-DropDown-Items.lua 1137 2016-05-15 10:57:36Z nevcairiel $ ]]--

local AceGUI = LibStub("AceGUI-3.0")

local IsLegion = false

-- Lua APIs
local assert = assert
local tgetn = table.getn

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame = CreateFrame

local fixlevels = AceGUI.fixlevels
local fixstrata = AceGUI.fixstrata

-- ItemBase is the base "class" for all dropdown items.
-- Each item has to use ItemBase.Create(widgetType) to
-- create an initial 'self' value.
-- ItemBase will add common functions and ui event handlers.
-- Be sure to keep basic usage when you override functions.

local ItemBase = {
	-- NOTE: The ItemBase version is added to each item's version number
	--       to ensure proper updates on ItemBase changes.
	--       Use at least 1000er steps.
	version = 1000,
	counter = 0,
}

function ItemBase.Frame_OnEnter()
	local self = this.obj

	if self.useHighlight then
		self.highlight:Show()
	end
	self:Fire("OnEnter")

	if self.specialOnEnter then
		self.specialOnEnter(self)
	end
end

function ItemBase.Frame_OnLeave()
	local self = this.obj

	self.highlight:Hide()
	self:Fire("OnLeave")

	if self.specialOnLeave then
		self.specialOnLeave(self)
	end
end

-- exported, AceGUI callback
function ItemBase.OnAcquire(self)
	self.frame:SetToplevel(true)
	self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
end

-- exported, AceGUI callback
function ItemBase.OnRelease(self)
	self:SetDisabled(false)
	self.pullout = nil
	self.frame:SetParent(nil)
	self.frame:ClearAllPoints()
	self.frame:Hide()
end

-- exported
-- NOTE: this is called by a Dropdown-Pullout.
--       Do not call this method directly
function ItemBase.SetPullout(self, pullout)
	self.pullout = pullout

	self.frame:SetParent(nil)
	local itemFrame = pullout.itemFrame
	self.frame:SetParent(itemFrame)
	self.parent = itemFrame
	fixlevels(itemFrame)
end

-- exported
function ItemBase.SetText(self, text)
	self.text:SetText(text or "")
end

-- exported
function ItemBase.GetText(self)
	return self.text:GetText()
end

-- exported
function ItemBase.SetPoint(self, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	self.frame:SetPoint(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
end

-- exported
function ItemBase.Show(self)
	self.frame:Show()
end

-- exported
function ItemBase.Hide(self)
	self.frame:Hide()
end

-- exported
function ItemBase.SetDisabled(self, disabled)
	self.disabled = disabled
	if disabled then
		self.useHighlight = false
		self.text:SetTextColor(.5, .5, .5)
	else
		self.useHighlight = true
		self.text:SetTextColor(1, 1, 1)
	end
end

-- exported
-- NOTE: this is called by a Dropdown-Pullout.
--       Do not call this method directly
function ItemBase.SetOnLeave(self, func)
	self.specialOnLeave = func
end

-- exported
-- NOTE: this is called by a Dropdown-Pullout.
--       Do not call this method directly
function ItemBase.SetOnEnter(self, func)
	self.specialOnEnter = func
end

function ItemBase.Create(type)
	-- NOTE: Most of the following code is copied from AceGUI-3.0/Dropdown widget
	local count = AceGUI:GetNextWidgetNum(type)
	local frame = CreateFrame("Button", "AceGUI30DropDownItem"..count)
	local self = {}
	self.frame = frame
	frame.obj = self
	self.type = type

	self.useHighlight = true

	frame:SetHeight(17)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")

	local text = frame:CreateFontString(nil,"OVERLAY","GameFontNormalSmall")
	text:SetTextColor(1,1,1)
	text:SetJustifyH("LEFT")
	text:SetPoint("TOPLEFT",frame,"TOPLEFT",18,0)
	text:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",-8,0)
	self.text = text

	local highlight = frame:CreateTexture(nil, "OVERLAY")
	highlight:SetTexture("Interface\\QuestFrame\\UI-QuestTitleHighlight")
	highlight:SetBlendMode("ADD")
	highlight:SetHeight(14)
	highlight:ClearAllPoints()
	highlight:SetPoint("RIGHT",frame,"RIGHT",-3,0)
	highlight:SetPoint("LEFT",frame,"LEFT",5,0)
	highlight:Hide()
	self.highlight = highlight

	local check = frame:CreateTexture("OVERLAY")
	check:SetWidth(16)
	check:SetHeight(16)
	check:SetPoint("LEFT",frame,"LEFT",3,-1)
	check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
	check:Hide()
	self.check = check

	local sub = frame:CreateTexture("OVERLAY")
	sub:SetWidth(16)
	sub:SetHeight(16)
	sub:SetPoint("RIGHT",frame,"RIGHT",-3,-1)
	sub:SetTexture("Interface\\ChatFrame\\ChatFrameExpandArrow")
	sub:Hide()
	self.sub = sub

	frame:SetScript("OnEnter", ItemBase.Frame_OnEnter)
	frame:SetScript("OnLeave", ItemBase.Frame_OnLeave)

	self.OnAcquire = ItemBase.OnAcquire
	self.OnRelease = ItemBase.OnRelease

	self.SetPullout = ItemBase.SetPullout
	self.GetText    = ItemBase.GetText
	self.SetText    = ItemBase.SetText
	self.SetDisabled = ItemBase.SetDisabled

	self.SetPoint   = ItemBase.SetPoint
	self.Show       = ItemBase.Show
	self.Hide       = ItemBase.Hide

	self.SetOnLeave = ItemBase.SetOnLeave
	self.SetOnEnter = ItemBase.SetOnEnter

	return self
end

-- Register a dummy LibStub library to retrieve the ItemBase, so other addons can use it.
local IBLib = LibStub:NewLibrary("AceGUI-3.0-DropDown-ItemBase", ItemBase.version)
if IBLib then
	IBLib.GetItemBase = function() return ItemBase end
end

--[[
	Template for items:

-- Item:
--
do
	local widgetType = "Dropdown-Item-"
	local widgetVersion = 1

	local function Constructor()
		local self = ItemBase.Create(widgetType)

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
end
--]]

-- Item: Header
-- A single text entry.
-- Special: Different text color and no highlight
do
	local widgetType = "Dropdown-Item-Header"
	local widgetVersion = 1

	local function OnEnter(this)
		local self = this.obj
		self:Fire("OnEnter")

		if self.specialOnEnter then
			self.specialOnEnter(self)
		end
	end

	local function OnLeave()
		local self = this.obj
		self:Fire("OnLeave")

		if self.specialOnLeave then
			self.specialOnLeave(self)
		end
	end

	-- exported, override
	local function SetDisabled(self, disabled)
		ItemBase.SetDisabled(self, disabled)
		if not disabled then
			self.text:SetTextColor(1, 1, 0)
		end
	end

	local function Constructor()
		local self = ItemBase.Create(widgetType)

		self.SetDisabled = SetDisabled

		self.frame:SetScript("OnEnter", OnEnter)
		self.frame:SetScript("OnLeave", OnLeave)

		self.text:SetTextColor(1, 1, 0)

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
end

-- Item: Execute
-- A simple button
do
	local widgetType = "Dropdown-Item-Execute"
	local widgetVersion = 1

	local function Frame_OnClick(this, button)
		local self = this.obj
		if self.disabled then return end
		self:Fire("OnClick")
		if self.pullout then
			self.pullout:Close()
		end
	end

	local function Constructor()
		local self = ItemBase.Create(widgetType)

		self.frame:SetScript("OnClick", Frame_OnClick)

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
end

-- Item: Toggle
-- Some sort of checkbox for dropdown menus.
-- Does not close the pullout on click.
do
	local widgetType = "Dropdown-Item-Toggle"
	local widgetVersion = 3

	local function UpdateToggle(self)
		if self.value then
			self.check:Show()
		else
			self.check:Hide()
		end
	end

	local function OnRelease(self)
		ItemBase.OnRelease(self)
		self:SetValue(nil)
	end

	local function Frame_OnClick()
		local self = this.obj
		if self.disabled then return end
		self.value = not self.value
		if self.value then
			PlaySound("igMainMenuOptionCheckBoxOn")
		else
			PlaySound("igMainMenuOptionCheckBoxOff")
		end
		UpdateToggle(self)
		self:Fire("OnValueChanged", 1, self.value)
	end

	-- exported
	local function SetValue(self, value)
		self.value = value
		UpdateToggle(self)
	end

	-- exported
	local function GetValue(self)
		return self.value
	end

	local function Constructor()
		local self = ItemBase.Create(widgetType)

		self.frame:SetScript("OnClick", Frame_OnClick)

		self.SetValue = SetValue
		self.GetValue = GetValue
		self.OnRelease = OnRelease

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
end

-- Item: Menu
-- Shows a submenu on mouse over
-- Does not close the pullout on click
do
	local widgetType = "Dropdown-Item-Menu"
	local widgetVersion = 2

	local function OnEnter()
		local self = this.obj
		self:Fire("OnEnter")

		if self.specialOnEnter then
			self.specialOnEnter(self)
		end

		self.highlight:Show()

		if not self.disabled and self.submenu then
			self.submenu:Open("TOPLEFT", self.frame, "TOPRIGHT", self.pullout:GetRightBorderWidth(), 0, self.frame:GetFrameLevel() + 100)
		end
	end

	local function OnHide()
		local self = this.obj
		if self.submenu then
			self.submenu:Close()
		end
	end

	-- exported
	local function SetMenu(self, menu)
		assert(menu.type == "Dropdown-Pullout")
		self.submenu = menu
	end

	-- exported
	local function CloseMenu(self)
		self.submenu:Close()
	end

	local function Constructor()
		local self = ItemBase.Create(widgetType)

		self.sub:Show()

		self.frame:SetScript("OnEnter", OnEnter)
		self.frame:SetScript("OnHide", OnHide)

		self.SetMenu   = SetMenu
		self.CloseMenu = CloseMenu

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
end

-- Item: Separator
-- A single line to separate items
do
	local widgetType = "Dropdown-Item-Separator"
	local widgetVersion = 2

	-- exported, override
	local function SetDisabled(self, disabled)
		ItemBase.SetDisabled(self, disabled)
		self.useHighlight = false
	end

	local function Constructor()
		local self = ItemBase.Create(widgetType)

		self.SetDisabled = SetDisabled

		local line = self.frame:CreateTexture(nil, "OVERLAY")
		line:SetHeight(1)
		line:SetTexture(.5, .5, .5)

		line:SetPoint("LEFT", self.frame, "LEFT", 10, 0)
		line:SetPoint("RIGHT", self.frame, "RIGHT", -10, 0)

		self.text:Hide()

		self.useHighlight = false

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
end

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-DropDown.lua
================
--[[ $Id: AceGUIWidget-DropDown.lua 1116 2014-10-12 08:15:46Z nevcairiel $ ]]--
local AceGUI = LibStub("AceGUI-3.0")

local AceCore = LibStub("AceCore-3.0")

-- Lua APIs
local min, max, floor = math.min, math.max, math.floor
local pairs, ipairs, type = pairs, ipairs, type
local tsort, tinsert, tgetn, tsetn = table.sort, table.insert, table.getn, table.setn

-- WoW APIs
local PlaySound = PlaySound
local UIParent, CreateFrame = UIParent, CreateFrame
local _G = AceCore._G

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: CLOSE

local fixlevels = AceGUI.fixlevels
local fixstrata = AceGUI.fixstrata

do
	local widgetType = "Dropdown-Pullout"
	local widgetVersion = 3

	--[[ Static data ]]--

	local backdrop = {
		bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
		edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
		edgeSize = 32,
		tileSize = 32,
		tile = true,
		insets = { left = 11, right = 12, top = 12, bottom = 11 },
	}
	local sliderBackdrop  = {
		bgFile = "Interface\\Buttons\\UI-SliderBar-Background",
		edgeFile = "Interface\\Buttons\\UI-SliderBar-Border",
		tile = true, tileSize = 8, edgeSize = 8,
		insets = { left = 3, right = 3, top = 3, bottom = 3 }
	}

	local defaultWidth = 200
	local defaultMaxHeight = 600

	--[[ UI Event Handlers ]]--

	-- HACK: This should be no part of the pullout, but there
	--       is no other 'clean' way to response to any item-OnEnter
	--       Used to close Submenus when an other item is entered
	local function OnEnter(item)
		local self = item.pullout
		for k, v in ipairs(self.items) do
			if v.CloseMenu and v ~= item then
				v:CloseMenu()
			end
		end
	end

	-- See the note in Constructor() for each scroll related function
	local function OnMouseWheel()
		this.obj:MoveScroll(arg1)
	end

	local function OnScrollValueChanged()
		this.obj:SetScroll(arg1)
	end

	local function OnSizeChanged()
		this.obj:FixScroll()
	end

	--[[ Exported methods ]]--

	-- exported
	local function SetScroll(self, value)
		local status = self.scrollStatus
		local frame, child = self.scrollFrame, self.itemFrame
		local height, viewheight = frame:GetHeight(), child:GetHeight()

		local offset
		if height > viewheight then
			offset = 0
		else
			offset = floor((viewheight - height) / 1000 * value)
		end
		child:ClearAllPoints()
		child:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, offset)
		child:SetPoint("TOPRIGHT", frame, "TOPRIGHT", self.slider:IsShown() and -12 or 0, offset)
		status.offset = offset
		status.scrollvalue = value
	end

	-- exported
	local function MoveScroll(self, value)
		local status = self.scrollStatus
		local frame, child = self.scrollFrame, self.itemFrame
		local height, viewheight = frame:GetHeight(), child:GetHeight()

		if height > viewheight then
			self.slider:Hide()
		else
			self.slider:Show()
			local diff = height - viewheight
			local delta = 1
			if value < 0 then
				delta = -1
			end
			self.slider:SetValue(min(max(status.scrollvalue + delta*(1000/(diff/45)),0), 1000))
		end
	end

	-- exported
	local function FixScroll(self)
		local status = self.scrollStatus
		local frame, child = self.scrollFrame, self.itemFrame
		local height, viewheight = frame:GetHeight(), child:GetHeight()
		local offset = status.offset or 0

		if viewheight < height then
			self.slider:Hide()
			child:SetPoint("TOPRIGHT", frame, "TOPRIGHT", 0, offset)
			self.slider:SetValue(0)
		else
			self.slider:Show()
			local value = (offset / (viewheight - height) * 1000)
			if value > 1000 then value = 1000 end
			self.slider:SetValue(value)
			self:SetScroll(value)
			if value < 1000 then
				child:ClearAllPoints()
				child:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, offset)
				child:SetPoint("TOPRIGHT", frame, "TOPRIGHT", -12, offset)
				status.offset = offset
			end
		end
	end

	-- exported, AceGUI callback
	local function OnAcquire(self)
		self.frame:SetParent(UIParent)
		--self.itemFrame:SetToplevel(true)
	end

	-- exported, AceGUI callback
	local function OnRelease(self)
		self:Clear()
		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	-- exported
	local function AddItem(self, item)
		tinsert(self.items, item)

		local h = tgetn(self.items) * 16
		self.itemFrame:SetHeight(h)
		self.frame:SetHeight(min(h + 34, self.maxHeight)) -- +34: 20 for scrollFrame placement (10 offset) and +14 for item placement

		item.frame:SetPoint("LEFT", self.itemFrame, "LEFT")
		item.frame:SetPoint("RIGHT", self.itemFrame, "RIGHT")

		item:SetPullout(self)
		item:SetOnEnter(OnEnter)
	end

	-- exported
	local function Open(self, point, relFrame, relPoint, x, y)
		local items = self.items
		local frame = self.frame
		local itemFrame = self.itemFrame

		frame:SetPoint(point, relFrame, relPoint, x, y)


		local height = 8
		for i, item in pairs(items) do
			if i == 1 then
				item:SetPoint("TOP", itemFrame, "TOP", 0, -2)
			else
				item:SetPoint("TOP", items[i-1].frame, "BOTTOM", 0, 1)
			end

			item:Show()

			height = height + 16
		end
		itemFrame:SetHeight(height)
		fixstrata("TOOLTIP", frame)
		frame:Show()
		self:Fire("OnOpen")
	end

	-- exported
	local function Close(self)
		self.frame:Hide()
		self:Fire("OnClose")
	end

	-- exported
	local function Clear(self)
		local items = self.items
		for i, item in pairs(items) do
			AceGUI:Release(item)
			items[i] = nil
		end
		tsetn(items,0)
	end

	-- exported
	local function IterateItems(self)
		return ipairs(self.items)
	end

	-- exported
	local function SetHideOnLeave(self, val)
		self.hideOnLeave = val
	end

	-- exported
	local function SetMaxHeight(self, height)
		self.maxHeight = height or defaultMaxHeight
		if self.frame:GetHeight() > height then
			self.frame:SetHeight(height)
		elseif (self.itemFrame:GetHeight() + 34) < height then
			self.frame:SetHeight(self.itemFrame:GetHeight() + 34) -- see :AddItem
		end
	end

	-- exported
	local function GetRightBorderWidth(self)
		return 6 + (self.slider:IsShown() and 12 or 0)
	end

	-- exported
	local function GetLeftBorderWidth(self)
		return 6
	end

	--[[ Constructor ]]--

	local function Constructor()
		local count = AceGUI:GetNextWidgetNum(widgetType)
		local frame = CreateFrame("Frame", "AceGUI30Pullout"..count, UIParent)
		local self = {}
		self.count = count
		self.type = widgetType
		self.frame = frame
		frame.obj = self

		self.OnAcquire = OnAcquire
		self.OnRelease = OnRelease

		self.AddItem = AddItem
		self.Open    = Open
		self.Close   = Close
		self.Clear   = Clear
		self.IterateItems = IterateItems
		self.SetHideOnLeave = SetHideOnLeave

		self.SetScroll  = SetScroll
		self.MoveScroll = MoveScroll
		self.FixScroll  = FixScroll

		self.SetMaxHeight = SetMaxHeight
		self.GetRightBorderWidth = GetRightBorderWidth
		self.GetLeftBorderWidth = GetLeftBorderWidth

		self.items = {}

		self.scrollStatus = {
			scrollvalue = 0,
		}

		self.maxHeight = defaultMaxHeight

		frame:SetBackdrop(backdrop)
		frame:SetBackdropColor(0, 0, 0)
		frame:SetFrameStrata("FULLSCREEN_DIALOG")
		frame:SetClampedToScreen(true)
		frame:SetWidth(defaultWidth)
		frame:SetHeight(self.maxHeight)
		--frame:SetToplevel(true)

		-- NOTE: The whole scroll frame code is copied from the AceGUI-3.0 widget ScrollFrame
		local scrollFrame = CreateFrame("ScrollFrame", nil, frame)
		local itemFrame = CreateFrame("Frame", nil, scrollFrame)

		self.scrollFrame = scrollFrame
		self.itemFrame = itemFrame

		scrollFrame.obj = self
		itemFrame.obj = self

		local slider = CreateFrame("Slider", "AceGUI30PulloutScrollbar"..count, scrollFrame)
		slider:SetOrientation("VERTICAL")
		slider:SetHitRectInsets(0, 0, -10, 0)
		slider:SetBackdrop(sliderBackdrop)
		slider:SetWidth(8)
		slider:SetThumbTexture("Interface\\Buttons\\UI-SliderBar-Button-Vertical")
		slider:SetFrameStrata("FULLSCREEN_DIALOG")
		self.slider = slider
		slider.obj = self

		scrollFrame:SetScrollChild(itemFrame)
		scrollFrame:SetPoint("TOPLEFT", frame, "TOPLEFT", 6, -12)
		scrollFrame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -6, 12)
		scrollFrame:EnableMouseWheel(true)
		scrollFrame:SetScript("OnMouseWheel", OnMouseWheel)
		scrollFrame:SetScript("OnSizeChanged", OnSizeChanged)
		scrollFrame:SetToplevel(true)
		scrollFrame:SetFrameStrata("FULLSCREEN_DIALOG")

		itemFrame:SetPoint("TOPLEFT", scrollFrame, "TOPLEFT", 0, 0)
		itemFrame:SetPoint("TOPRIGHT", scrollFrame, "TOPRIGHT", -12, 0)
		itemFrame:SetHeight(400)
		itemFrame:SetToplevel(true)
		itemFrame:SetFrameStrata("FULLSCREEN_DIALOG")

		slider:SetPoint("TOPLEFT", scrollFrame, "TOPRIGHT", -16, 0)
		slider:SetPoint("BOTTOMLEFT", scrollFrame, "BOTTOMRIGHT", -16, 0)
		slider:SetScript("OnValueChanged", OnScrollValueChanged)
		slider:SetMinMaxValues(0, 1000)
		slider:SetValueStep(1)
		slider:SetValue(0)

		scrollFrame:Show()
		itemFrame:Show()
		slider:Hide()

		self:FixScroll()

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)
end

do
	local widgetType = "Dropdown"
	local widgetVersion = 30

	--[[ Static data ]]--

	--[[ UI event handler ]]--

	local function Control_OnEnter()
		this.obj.button:LockHighlight()
		this.obj:Fire("OnEnter")
	end

	local function Control_OnLeave()
		this.obj.button:UnlockHighlight()
		this.obj:Fire("OnLeave")
	end

	local function Dropdown_OnHide()
		local self = this.obj
		if self.open then
			self.pullout:Close()
		end
	end

	local function Dropdown_TogglePullout()
		local self = this.obj
		PlaySound("igMainMenuOptionCheckBoxOn") -- missleading name, but the Blizzard code uses this sound
		if self.open then
			self.open = nil
			self.pullout:Close()
			AceGUI:ClearFocus()
		else
			self.open = true
			self.pullout:SetWidth(self.pulloutWidth or self.frame:GetWidth())
			self.pullout:Open("TOPLEFT", self.frame, "BOTTOMLEFT", 0, self.label:IsShown() and -2 or 0)
			AceGUI:SetFocus(self)
		end
	end

	local function OnPulloutOpen(this)
		local self = this.userdata.obj
		local value = self.value

		if not self.multiselect then
			for i, item in this:IterateItems() do
				item:SetValue(item.userdata.value == value)
			end
		end

		self.open = true
		self:Fire("OnOpened")
	end

	local function OnPulloutClose(this)
		local self = this.userdata.obj
		self.open = nil
		self:Fire("OnClosed")
	end

	local function ShowMultiText(self)
		local text
		for i, widget in self.pullout:IterateItems() do
			if widget.type == "Dropdown-Item-Toggle" then
				if widget:GetValue() then
					if text then
						text = text..", "..widget:GetText()
					else
						text = widget:GetText()
					end
				end
			end
		end
		self:SetText(text)
	end

	local function OnItemValueChanged(this, event, _, checked)
		local self = this.userdata.obj

		if self.multiselect then
			self:Fire("OnValueChanged", 2, this.userdata.value, checked)
			ShowMultiText(self)
		else
			if checked then
				self:SetValue(this.userdata.value)
				self:Fire("OnValueChanged", 1, this.userdata.value)
				this:SetValue(false)
			else
				self:SetValue(nil)
				self:Fire("OnValueChanged", 1, nil)
				this:SetValue(true)
			end
			if self.open then
				self.pullout:Close()
			end
		end
	end

	--[[ Exported methods ]]--

	-- exported, AceGUI callback
	local function OnAcquire(self)
		local pullout = AceGUI:Create("Dropdown-Pullout")
		self.pullout = pullout
		pullout.userdata.obj = self
		pullout:SetCallback("OnClose", OnPulloutClose)
		pullout:SetCallback("OnOpen", OnPulloutOpen)
		self.pullout.frame:SetFrameLevel(self.frame:GetFrameLevel() + 1)
		local frame = self.pullout.frame
		fixlevels(frame)

		self:SetHeight(44)
		self:SetWidth(200)
		self:SetLabel()
		self:SetPulloutWidth(nil)
	end

	-- exported, AceGUI callback
	local function OnRelease(self)
		if self.open then
			self.pullout:Close()
		end
		AceGUI:Release(self.pullout)
		self.pullout = nil

		self:SetText("")
		self:SetDisabled(false)
		self:SetMultiselect(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	-- exported
	local function SetDisabled(self, disabled)
		self.disabled = disabled
		if disabled then
			self.text:SetTextColor(0.5,0.5,0.5)
			self.button:Disable()
			self.button_cover:Disable()
			self.label:SetTextColor(0.5,0.5,0.5)
		else
			self.button:Enable()
			self.button_cover:Enable()
			self.label:SetTextColor(1,.82,0)
			self.text:SetTextColor(1,1,1)
		end
	end

	-- exported
	local function ClearFocus(self)
		if self.open then
			self.pullout:Close()
		end
	end

	-- exported
	local function SetText(self, text)
		self.text:SetText(text or "")
	end

	-- exported
	local function SetLabel(self, text)
		if text and text ~= "" then
			self.label:SetText(text)
			self.label:Show()
			self.dropdown:SetPoint("TOPLEFT",self.frame,"TOPLEFT",-15,-14)
			self:SetHeight(40)
			self.alignoffset = 26
		else
			self.label:SetText("")
			self.label:Hide()
			self.dropdown:SetPoint("TOPLEFT",self.frame,"TOPLEFT",-15,0)
			self:SetHeight(26)
			self.alignoffset = 12
		end
	end

	-- exported
	local function SetValue(self, value)
		if self.list then
			self:SetText(self.list[value] or "")
		end
		self.value = value
	end

	-- exported
	local function GetValue(self)
		return self.value
	end

	-- exported
	local function SetItemValue(self, item, value)
		if not self.multiselect then return end
		for i, widget in self.pullout:IterateItems() do
			if widget.userdata.value == item then
				if widget.SetValue then
					widget:SetValue(value)
				end
			end
		end
		ShowMultiText(self)
	end

	-- exported
	local function SetItemDisabled(self, item, disabled)
		for i, widget in self.pullout:IterateItems() do
			if widget.userdata.value == item then
				widget:SetDisabled(disabled)
			end
		end
	end

	local function AddListItem(self, value, text, itemType)
		if not itemType then itemType = "Dropdown-Item-Toggle" end
		local exists = AceGUI:GetWidgetVersion(itemType)
		if not exists then error(("The given item type, %q, does not exist within AceGUI-3.0"):format(tostring(itemType)), 2) end

		local item = AceGUI:Create(itemType)
		item:SetText(text)
		item.userdata.obj = self
		item.userdata.value = value
		item:SetCallback("OnValueChanged", OnItemValueChanged)
		self.pullout:AddItem(item)
	end

	local function AddCloseButton(self)
		if not self.hasClose then
			local close = AceGUI:Create("Dropdown-Item-Execute")
			close:SetText(CLOSE)
			self.pullout:AddItem(close)
			self.hasClose = true
		end
	end

	-- exported
	local sortlist = {}
	local function SetList(self, list, order, itemType)
		self.list = list
		self.pullout:Clear()
		self.hasClose = nil
		if not list then return end

		if type(order) ~= "table" then
			for v in pairs(list) do
				tinsert(sortlist, v)
			end
			tsort(sortlist)

			for i, key in ipairs(sortlist) do
				AddListItem(self, key, list[key], itemType)
				sortlist[i] = nil
			end
			tsetn(sortlist,0)
		else
			for i, key in ipairs(order) do
				AddListItem(self, key, list[key], itemType)
			end
		end
		if self.multiselect then
			ShowMultiText(self)
			AddCloseButton(self)
		end
	end

	-- exported
	local function AddItem(self, value, text, itemType)
		if self.list then
			self.list[value] = text
			AddListItem(self, value, text, itemType)
		end
	end

	-- exported
	local function SetMultiselect(self, multi)
		self.multiselect = multi
		if multi then
			ShowMultiText(self)
			AddCloseButton(self)
		end
	end

	-- exported
	local function GetMultiselect(self)
		return self.multiselect
	end

	local function SetPulloutWidth(self, width)
		self.pulloutWidth = width
	end

	--[[ Constructor ]]--

	local function Constructor()
		local count = AceGUI:GetNextWidgetNum(widgetType)
		local frame = CreateFrame("Frame", nil, UIParent)
		local dropdown = CreateFrame("Frame", "AceGUI30DropDown"..count, frame, "UIDropDownMenuTemplate")

		local self = {}
		self.type = widgetType
		self.frame = frame
		self.dropdown = dropdown
		self.count = count
		frame.obj = self
		dropdown.obj = self

		self.OnRelease   = OnRelease
		self.OnAcquire   = OnAcquire

		self.ClearFocus  = ClearFocus

		self.SetText     = SetText
		self.SetValue    = SetValue
		self.GetValue    = GetValue
		self.SetList     = SetList
		self.SetLabel    = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem     = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.SetPulloutWidth = SetPulloutWidth

		self.alignoffset = 26

		frame:SetScript("OnHide",Dropdown_OnHide)

		dropdown:ClearAllPoints()
		dropdown:SetPoint("TOPLEFT",frame,"TOPLEFT",-15,0)
		dropdown:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",17,0)
		dropdown:SetScript("OnHide", nil)

		local left = _G[dropdown:GetName() .. "Left"]
		local middle = _G[dropdown:GetName() .. "Middle"]
		local right = _G[dropdown:GetName() .. "Right"]

		middle:ClearAllPoints()
		right:ClearAllPoints()

		middle:SetPoint("LEFT", left, "RIGHT", 0, 0)
		middle:SetPoint("RIGHT", right, "LEFT", 0, 0)
		right:SetPoint("TOPRIGHT", dropdown, "TOPRIGHT", 0, 17)

		local button = _G[dropdown:GetName() .. "Button"]
		self.button = button
		button.obj = self
		button:SetScript("OnEnter",Control_OnEnter)
		button:SetScript("OnLeave",Control_OnLeave)
		button:SetScript("OnClick",Dropdown_TogglePullout)

		local button_cover = CreateFrame("BUTTON",nil,self.frame)
		self.button_cover = button_cover
		button_cover.obj = self
		button_cover:SetPoint("TOPLEFT",self.frame,"BOTTOMLEFT",0,25)
		button_cover:SetPoint("BOTTOMRIGHT",self.frame,"BOTTOMRIGHT")
		button_cover:SetScript("OnEnter",Control_OnEnter)
		button_cover:SetScript("OnLeave",Control_OnLeave)
		button_cover:SetScript("OnClick",Dropdown_TogglePullout)

		local text = _G[dropdown:GetName() .. "Text"]
		self.text = text
		text.obj = self
		text:ClearAllPoints()
		text:SetPoint("RIGHT", right, "RIGHT" ,-43, 2)
		text:SetPoint("LEFT", left, "LEFT", 25, 2)

		local label = frame:CreateFontString(nil,"OVERLAY","GameFontNormalSmall")
		label:SetPoint("TOPLEFT",frame,"TOPLEFT",0,0)
		label:SetPoint("TOPRIGHT",frame,"TOPRIGHT",0,0)
		label:SetJustifyH("LEFT")
		label:SetHeight(18)
		label:Hide()
		self.label = label

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)
end

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-EditBox.lua
================
--[[-----------------------------------------------------------------------------
EditBox Widget
-------------------------------------------------------------------------------]]
local Type, Version = "EditBox", 26
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local AceCore = LibStub("AceCore-3.0")
local hooksecurefunc = AceCore.hooksecurefunc
local _G = AceCore._G
local GetCursorInfo = _G.GetCursorInfo

-- Lua APIs
local tostring, pairs = tostring, pairs

-- WoW APIs
local PlaySound = PlaySound
local GetCursorInfo, ClearCursor, GetSpellInfo = GetCursorInfo, ClearCursor, GetSpellInfo
local CreateFrame, UIParent = CreateFrame, UIParent
local strlen = string.len

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: AceGUIEditBoxInsertLink, ChatFontNormal, OKAY

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
if not AceGUIEditBoxInsertLink then
	-- upgradeable hook
	hooksecurefunc("BankFrameItemButtonGeneric_OnClick",
		function(button)
			if button == "LeftButton" and IsShiftKeyDown() and not this.isBag then
				return _G.AceGUIEditBoxInsertLink(GetContainerItemLink(BANK_CONTAINER, this:GetID()))
			end
		end)
	hooksecurefunc("ContainerFrameItemButton_OnClick",
		function(button, ignoreModifiers)
			if button == "LeftButton" and IsShiftKeyDown() and not ignoreModifiers then
				return _G.AceGUIEditBoxInsertLink(GetContainerItemLink(this:GetParent():GetID(), this:GetID()))
			end
		end)

	hooksecurefunc("KeyRingItemButton_OnClick",
		function(button)
			if button == "LeftButton" and IsShiftKeyDown() and not this.isBag then
				return _G.AceGUIEditBoxInsertLink(GetContainerItemLink(KEYRING_CONTAINER, this:GetID()))
			end
		end)
	hooksecurefunc("LootFrameItem_OnClick",
		function(button)
			if button == "LeftButton" and IsShiftKeyDown() then
				return _G.AceGUIEditBoxInsertLink(GetLootSlotLink(this.slot))
			end
		end)
	hooksecurefunc("SetItemRef",
		function(link, text, button)
			if IsShiftKeyDown() then
				if strsub(link,1,6) == "player" then
					local name = strsub(link,8)
					if name and (strlen(name) > 0) then
						return _G.AceGUIEditBoxInsertLink(name)
					end
				else
					return _G.AceGUIEditBoxInsertLink(text)
				end
			end
		end)
	hooksecurefunc("MerchantItemButton_OnClick",
		function(button, ignoreModifiers)
			if MerchantFrame.selectedTab == 1 and button == "LeftButton" and IsShiftKeyDown() and not ignoreModifiers then
				return _G.AceGUIEditBoxInsertLink(GetMerchantItemLink(this:GetID()))
			end
		end)
	hooksecurefunc("PaperDollItemSlotButton_OnClick",
		function(button, ignoreModifiers)
			if button == "LeftButton" and IsShiftKeyDown() and not ignoreModifiers then
				return _G.AceGUIEditBoxInsertLink(GetInventoryItemLink("player", this:GetID()))
			end
		end)
	hooksecurefunc("QuestItem_OnClick",
		function()
			if IsShiftKeyDown() and this.rewardType ~= "spell" then
				return _G.AceGUIEditBoxInsertLink(GetQuestItemLink(this.type, this:GetID()))
			end
		end)
	hooksecurefunc("QuestRewardItem_OnClick",
		function()
			if IsShiftKeyDown() and this.rewardType ~= "spell" then
				return _G.AceGUIEditBoxInsertLink(GetQuestItemLink(this.type, this:GetID()))
			end
		end)
	hooksecurefunc("QuestLogTitleButton_OnClick",
		function(button)
			if IsShiftKeyDown() and (not this.isHeader) then
				return _G.AceGUIEditBoxInsertLink(gsub(this:GetText(), " *(.*)", "%1"))
			end
		end)
	hooksecurefunc("QuestLogRewardItem_OnClick",
		function()
			if IsShiftKeyDown() and this.rewardType ~= "spell" then
				return _G.AceGUIEditBoxInsertLink(GetQuestLogItemLink(this.type, this:GetID()))
			end
		end)
	hooksecurefunc("SpellButton_OnClick",
		function(drag)
			local id = SpellBook_GetSpellID(this:GetID())
			if id <= MAX_SPELLS and (not drag) and IsShiftKeyDown() then
				local spellName, subSpellName = GetSpellName(id, SpellBookFrame.bookType)
				if spellName and not IsSpellPassive(id, SpellBookFrame.bookType) then
					if subSpellName and (strlen(subSpellName) > 0) then
						_G.AceGUIEditBoxInsertLink(spellName.."("..subSpellName..")");
					else
						_G.AceGUIEditBoxInsertLink(spellName);
					end
				end
			end
		end)
end

function _G.AceGUIEditBoxInsertLink(text)
	for i = 1, AceGUI:GetWidgetCount(Type) do
		local editbox = _G["AceGUI-3.0EditBox"..i]
		if editbox and editbox:IsVisible() and editbox.hasfocus then
			editbox:Insert(text)
			return true
		end
	end
end

local function ShowButton(self)
	if not self.disablebutton then
		self.button:Show()
		self.editbox:SetTextInsets(0, 20, 3, 3)
	end
end

local function HideButton(self)
	self.button:Hide()
	self.editbox:SetTextInsets(0, 0, 3, 3)
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter()
	this.obj:Fire("OnEnter")
end

local function Control_OnLeave()
	this.obj:Fire("OnLeave")
end

local function Frame_OnShowFocus()
	this.obj.editbox:SetFocus()
	this:SetScript("OnShow", nil)
end

local function EditBox_OnEscapePressed()
	AceGUI:ClearFocus()
end

local function EditBox_OnEnterPressed()
	local self = this.obj
	local value = this:GetText()
	local cancel = self:Fire("OnEnterPressed", 1, value)
	if not cancel then
		PlaySound("igMainMenuOptionCheckBoxOn")
		HideButton(self)
	end
end

local function EditBox_OnReceiveDrag()
	if not GetCursorInfo then return end
	local self = this.obj
	local type, id, info = GetCursorInfo()
	if type == "item" then
		self:SetText(info)
		self:Fire("OnEnterPressed", 1, info)
		ClearCursor()
	elseif type == "spell" then
		local spell, rank = GetSpellName(id, info)
		if rank ~= "" then spell = spell.."("..rank..")" end
		self:SetText(spell)
		self:Fire("OnEnterPressed", 1, spell)
		ClearCursor()
	elseif type == "macro" then
		local name = GetMacroInfo(id)
		self:SetText(name)
		self:Fire("OnEnterPressed", 1, name)
		ClearCursor()
	end
	HideButton(self)
	AceGUI:ClearFocus()
end


local function EditBox_OnTextChanged()
	local self = this.obj
	local value = this:GetText()
	if tostring(value) ~= tostring(self.lasttext) then
		self:Fire("OnTextChanged", 1, value)
		self.lasttext = value
		ShowButton(self)
	end
end

local function EditBox_OnFocusGained()
	this.hasfocus = true
	AceGUI:SetFocus(this.obj)
end

local function EditBox_OnFocusLost()
	this.hasfocus = nil
end

local function Button_OnClick()
	local editbox = this.obj.editbox
	editbox:ClearFocus()
	this = editbox	-- Ace3v: this is kinda hack here
	EditBox_OnEnterPressed()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		-- height is controlled by SetLabel
		self:SetWidth(200)
		self:SetDisabled(false)
		self:SetLabel()
		self:SetText()
		self:DisableButton(false)
		self:SetMaxLetters(0)
	end,

	["OnRelease"] = function(self)
		self:ClearFocus()
	end,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.editbox:EnableMouse(false)
			self.editbox:ClearFocus()
			self.editbox:SetTextColor(0.5,0.5,0.5)
			self.label:SetTextColor(0.5,0.5,0.5)
		else
			self.editbox:EnableMouse(true)
			self.editbox:SetTextColor(1,1,1)
			self.label:SetTextColor(1,.82,0)
		end
	end,

	["SetText"] = function(self, text)
		self.lasttext = text or ""
		self.editbox:SetText(text or "")
		self.editbox:HighlightText(0)
		HideButton(self)
	end,

	["GetText"] = function(self, text)
		return self.editbox:GetText()
	end,

	["SetLabel"] = function(self, text)
		if text and text ~= "" then
			self.label:SetText(text)
			self.label:Show()
			self.editbox:SetPoint("TOPLEFT",self.frame,"TOPLEFT",7,-18)
			self:SetHeight(44)
			self.alignoffset = 30
		else
			self.label:SetText("")
			self.label:Hide()
			self.editbox:SetPoint("TOPLEFT",self.frame,"TOPLEFT",7,0)
			self:SetHeight(26)
			self.alignoffset = 12
		end
	end,

	["DisableButton"] = function(self, disabled)
		self.disablebutton = disabled
		if disabled then
			HideButton(self)
		end
	end,

	["SetMaxLetters"] = function (self, num)
		self.editbox:SetMaxLetters(num or 0)
	end,

	["ClearFocus"] = function(self)
		self.editbox:ClearFocus()
		self.frame:SetScript("OnShow", nil)
	end,

	["SetFocus"] = function(self)
		self.editbox:SetFocus()
		if not self.frame:IsShown() then
			self.frame:SetScript("OnShow", Frame_OnShowFocus)
		end
	end,

	["HighlightText"] = function(self, from, to)
		self.editbox:HighlightText(from, to)
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local num  = AceGUI:GetNextWidgetNum(Type)
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:Hide()

	local editbox = CreateFrame("EditBox", "AceGUI-3.0EditBox"..num, frame, "InputBoxTemplate")
	editbox:SetAutoFocus(false)
	editbox:SetFontObject(ChatFontNormal)
	editbox:SetScript("OnEnter", Control_OnEnter)
	editbox:SetScript("OnLeave", Control_OnLeave)
	editbox:SetScript("OnEscapePressed", EditBox_OnEscapePressed)
	editbox:SetScript("OnEnterPressed", EditBox_OnEnterPressed)
	editbox:SetScript("OnTextChanged", EditBox_OnTextChanged)
	editbox:SetScript("OnReceiveDrag", EditBox_OnReceiveDrag)
	editbox:SetScript("OnMouseDown", EditBox_OnReceiveDrag)
	editbox:SetScript("OnEditFocusGained", EditBox_OnFocusGained)
	editbox:SetScript("OnEditFocusLost", EditBox_OnFocusLost)
	editbox:SetTextInsets(0, 0, 3, 3)
	editbox:SetMaxLetters(256)
	editbox:SetPoint("BOTTOMLEFT", 6, 0)
	editbox:SetPoint("BOTTOMRIGHT", 0, 0)
	editbox:SetHeight(19)

	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
	label:SetPoint("TOPLEFT", 0, -2)
	label:SetPoint("TOPRIGHT", 0, -2)
	label:SetJustifyH("LEFT")
	label:SetHeight(18)

	local button = CreateFrame("Button", nil, editbox, "UIPanelButtonTemplate")
	button:SetWidth(40)
	button:SetHeight(20)
	button:SetPoint("RIGHT", -2, 0)
	button:SetText(OKAY)
	button:SetScript("OnClick", Button_OnClick)
	button:Hide()

	local widget = {
		alignoffset = 30,
		editbox     = editbox,
		label       = label,
		button      = button,
		frame       = frame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	editbox.obj, button.obj = widget, widget

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-Heading.lua
================
--[[-----------------------------------------------------------------------------
Heading Widget
-------------------------------------------------------------------------------]]
local Type, Version = "Heading", 20
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetText()
		self:SetFullWidth()
		self:SetHeight(18)
	end,

	-- ["OnRelease"] = nil,

	["SetText"] = function(self, text)
		self.label:SetText(text or "")
		if text and text ~= "" then
			self.left:SetPoint("RIGHT", self.label, "LEFT", -5, 0)
			self.right:Show()
		else
			self.left:SetPoint("RIGHT", -3, 0)
			self.right:Hide()
		end
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:Hide()

	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontNormal")
	label:SetPoint("TOP",0,0)
	label:SetPoint("BOTTOM",0,0)
	label:SetJustifyH("CENTER")

	local left = frame:CreateTexture(nil, "BACKGROUND")
	left:SetHeight(8)
	left:SetPoint("LEFT", 3, 0)
	left:SetPoint("RIGHT", label, "LEFT", -5, 0)
	left:SetTexture("Interface\\Tooltips\\UI-Tooltip-Border")
	left:SetTexCoord(0.81, 0.94, 0.5, 1)

	local right = frame:CreateTexture(nil, "BACKGROUND")
	right:SetHeight(8)
	right:SetPoint("RIGHT", -3, 0)
	right:SetPoint("LEFT", label, "RIGHT", 5, 0)
	right:SetTexture("Interface\\Tooltips\\UI-Tooltip-Border")
	right:SetTexCoord(0.81, 0.94, 0.5, 1)

	local widget = {
		label = label,
		left  = left,
		right = right,
		frame = frame,
		type  = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-Icon.lua
================
--[[-----------------------------------------------------------------------------
Icon Widget
-------------------------------------------------------------------------------]]
local Type, Version = "Icon", 22
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs, print = pairs, print

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter()
	this.obj:Fire("OnEnter")
end

local function Control_OnLeave()
	this.obj:Fire("OnLeave")
end

local function Button_OnClick()
	this.obj:Fire("OnClick", 1, arg1)
	AceGUI:ClearFocus()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetHeight(110)
		self:SetWidth(110)
		self:SetLabel()
		self:SetImage(nil)
		self:SetImageSize(64, 64)
		self:SetDisabled(false)
	end,

	-- ["OnRelease"] = nil,

	["SetLabel"] = function(self, text)
		if text and text ~= "" then
			self.label:Show()
			self.label:SetText(text)
			self:SetHeight(self.image:GetHeight() + 25)
		else
			self.label:Hide()
			self:SetHeight(self.image:GetHeight() + 10)
		end
	end,

	["SetImage"] = function(self, path, a1,a2,a3,a4,a5,a6,a7,a8)
		local image = self.image
		image:SetTexture(path)

		if image:GetTexture() then
			if a4 or a8 then
				image:SetTexCoord(a1,a2,a3,a4,a5,a6,a7,a8)
			else
				image:SetTexCoord(0, 1, 0, 1)
			end
		end
	end,

	["SetImageSize"] = function(self, width, height)
		self.image:SetWidth(width)
		self.image:SetHeight(height)
		--self.frame:SetWidth(width + 30)
		if self.label:IsShown() then
			self:SetHeight(height + 25)
		else
			self:SetHeight(height + 10)
		end
	end,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
			self.label:SetTextColor(0.5, 0.5, 0.5)
			self.image:SetVertexColor(0.5, 0.5, 0.5, 0.5)
		else
			self.frame:Enable()
			self.label:SetTextColor(1, 1, 1)
			self.image:SetVertexColor(1, 1, 1, 1)
		end
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Button", nil, UIParent)
	frame:Hide()

	frame:EnableMouse(true)
	frame:SetScript("OnEnter", Control_OnEnter)
	frame:SetScript("OnLeave", Control_OnLeave)
	frame:SetScript("OnClick", Button_OnClick)

	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontHighlight")
	label:SetPoint("BOTTOMLEFT",0,0)
	label:SetPoint("BOTTOMRIGHT",0,0)
	label:SetJustifyH("CENTER")
	label:SetJustifyV("TOP")
	label:SetHeight(18)

	local image = frame:CreateTexture(nil, "BACKGROUND")
	image:SetWidth(64)
	image:SetHeight(64)
	image:SetPoint("TOP", 0, -5)

	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
	highlight:SetAllPoints(image)
	highlight:SetTexture("Interface\\PaperDollInfoFrame\\UI-Character-Tab-Highlight")
	highlight:SetTexCoord(0, 1, 0.23, 0.77)
	highlight:SetBlendMode("ADD")

	local widget = {
		label = label,
		image = image,
		frame = frame,
		type  = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	widget.SetText = function(self,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) print("AceGUI-3.0-Icon: SetText is deprecated! Use SetLabel instead!"); self:SetLabel(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-InteractiveLabel.lua
================
--[[-----------------------------------------------------------------------------
InteractiveLabel Widget
-------------------------------------------------------------------------------]]
local Type, Version = "InteractiveLabel", 20
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: GameFontHighlightSmall

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter()
	this.obj:Fire("OnEnter")
end

local function Control_OnLeave()
	this.obj:Fire("OnLeave")
end

local function Label_OnClick()
	this.obj:Fire("OnClick", 1, arg1)
	AceGUI:ClearFocus()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:LabelOnAcquire()
		self:SetHighlight()
		self:SetHighlightTexCoord()
		self:SetDisabled(false)
	end,

	-- ["OnRelease"] = nil,

	["SetHighlight"] = function(self, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
		self.highlight:SetTexture(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	end,

	["SetHighlightTexCoord"] = function(self, a1,a2,a3,a4,a5,a6,a7,a8)
		if a4 or a8 then
			self.highlight:SetTexCoord(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
		else
			self.highlight:SetTexCoord(0, 1, 0, 1)
		end
	end,

	["SetDisabled"] = function(self,disabled)
		self.disabled = disabled
		if disabled then
			self.frame:EnableMouse(false)
			self.label:SetTextColor(0.5, 0.5, 0.5)
		else
			self.frame:EnableMouse(true)
			self.label:SetTextColor(1, 1, 1)
		end
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	-- create a Label type that we will hijack
	local label = AceGUI:Create("Label")

	local frame = label.frame
	frame:EnableMouse(true)
	frame:SetScript("OnEnter", Control_OnEnter)
	frame:SetScript("OnLeave", Control_OnLeave)
	frame:SetScript("OnMouseDown", Label_OnClick)

	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
	highlight:SetTexture(nil)
	highlight:SetAllPoints()
	highlight:SetBlendMode("ADD")

	label.highlight = highlight
	label.type = Type
	label.LabelOnAcquire = label.OnAcquire
	for method, func in pairs(methods) do
		label[method] = func
	end

	return label
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-Keybinding.lua
================
--[[-----------------------------------------------------------------------------
Keybinding Widget
Set Keybindings in the Config UI.
-------------------------------------------------------------------------------]]
local Type, Version = "Keybinding", 25
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local IsShiftKeyDown, IsControlKeyDown, IsAltKeyDown = IsShiftKeyDown, IsControlKeyDown, IsAltKeyDown
local CreateFrame, UIParent = CreateFrame, UIParent

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: NOT_BOUND

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]

local function Control_OnEnter()
	this.obj:Fire("OnEnter")
end

local function Control_OnLeave()
	this.obj:Fire("OnLeave")
end

local function Keybinding_OnHide()
	local self = this.obj
	this:EnableKeyboard(false)
	this:EnableMouseWheel(false)
	self.msgframe:Hide()
	this:UnlockHighlight()
	self.waitingForKey = nil
end

local ignoreKeys = {
	["BUTTON1"] = true, ["BUTTON2"] = true,
	["UNKNOWN"] = true,
	["SHIFT"] = true, ["CTRL"] = true, ["ALT"] = true,
}
local function Keybinding_OnKeyDown()
	local self = this.obj
	if self.waitingForKey then
		local keyPressed = arg1
		if keyPressed == "ESCAPE" then
			keyPressed = ""
		else
			if ignoreKeys[keyPressed] then return end
			if IsShiftKeyDown() then
				keyPressed = "SHIFT-"..keyPressed
			end
			if IsControlKeyDown() then
				keyPressed = "CTRL-"..keyPressed
			end
			if IsAltKeyDown() then
				keyPressed = "ALT-"..keyPressed
			end
		end

		this:EnableKeyboard(false)
		this:EnableMouseWheel(false)
		self.msgframe:Hide()
		this:UnlockHighlight()
		self.waitingForKey = nil

		if not self.disabled then
			self:SetKey(keyPressed)
			self:Fire("OnKeyChanged", 1, keyPressed)
		end
	end
end

local function Keybinding_OnMouseDown()
	getglobal(this:GetName().."Left"):SetTexture("Interface\\Buttons\\UI-Panel-Button-Down");
	getglobal(this:GetName().."Middle"):SetTexture("Interface\\Buttons\\UI-Panel-Button-Down");
	getglobal(this:GetName().."Right"):SetTexture("Interface\\Buttons\\UI-Panel-Button-Down");
end

local function Keybinding_OnMouseUp()
	getglobal(this:GetName().."Left"):SetTexture("Interface\\Buttons\\UI-Panel-Button-Up");
	getglobal(this:GetName().."Middle"):SetTexture("Interface\\Buttons\\UI-Panel-Button-Up");
	getglobal(this:GetName().."Right"):SetTexture("Interface\\Buttons\\UI-Panel-Button-Up");
	local self = this.obj
	if MouseIsOver(this) and not self.disabled then
		if self.waitingForKey then
			if arg1 ~= "LeftButton" and arg1 ~= "RightButton" then
				Keybinding_OnKeyDown()
			end
			this:EnableKeyboard(false)
			this:EnableMouseWheel(false)
			self.msgframe:Hide()
			this:UnlockHighlight()
			self.waitingForKey = nil
		else
			this:EnableKeyboard(true)
			this:EnableMouseWheel(true)
			self.msgframe:Show()
			this:LockHighlight()
			self.waitingForKey = true
		end
	end
	AceGUI:ClearFocus()
end

local function Keybinding_OnMouseWheel()
	if arg1 >= 0 then
		arg1 = "MOUSEWHEELUP"
	else
		arg1 = "MOUSEWHEELDOWN"
	end
	Keybinding_OnKeyDown()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetWidth(200)
		self:SetLabel("")
		self:SetKey("")
		self.waitingForKey = nil
		self.msgframe:Hide()
		self:SetDisabled(false)
		self.button:EnableKeyboard(false)
		self.button:EnableMouseWheel(false)
	end,

	-- ["OnRelease"] = nil,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.button:Disable()
			self.label:SetTextColor(0.5,0.5,0.5)
		else
			self.button:Enable()
			self.label:SetTextColor(1,1,1)
		end
	end,

	["SetKey"] = function(self, key)
		if (key or "") == "" then
			self.button:SetText(NOT_BOUND)
			self.text:SetFontObject("GameFontNormal")
		else
			self.button:SetText(key)
			self.text:SetFontObject("GameFontHighlight")
		end
	end,

	["GetKey"] = function(self)
		local key = self.button:GetText()
		if key == NOT_BOUND then
			key = nil
		end
		return key
	end,

	["SetLabel"] = function(self, label)
		self.label:SetText(label or "")
		if (label or "") == "" then
			self.alignoffset = nil
			self:SetHeight(24)
		else
			self.alignoffset = 30
			self:SetHeight(44)
		end
	end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local ControlBackdrop  = {
	bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 3, bottom = 3 }
}

local function keybindingMsgFixWidth()
	this:SetWidth(this.msg:GetWidth() + 10)
	this:SetScript("OnUpdate", nil)
end

local function Constructor()
	local name = "AceGUI30KeybindingButton" .. AceGUI:GetNextWidgetNum(Type)

	local frame = CreateFrame("Frame", nil, UIParent)
	local button = CreateFrame("Button", name, frame, "UIPanelButtonTemplate2")

	button:EnableMouse(true)
	button:EnableMouseWheel(false)
	button:SetScript("OnEnter", Control_OnEnter)
	button:SetScript("OnLeave", Control_OnLeave)

	button:SetScript("OnKeyDown", Keybinding_OnKeyDown)
	button:RegisterForClicks("AnyDown","AnyUp")
	-- Ace3v: RegisterForClicks means OnClick will not be triggered, so use OnKeyDown and OnKeyUp
	button:SetScript("OnMouseDown", Keybinding_OnMouseDown)
	button:SetScript("OnMouseUp", Keybinding_OnMouseUp)
	button:SetScript("OnMouseWheel", Keybinding_OnMouseWheel)
	button:SetScript("OnHide", Keybinding_OnHide)
	button:SetPoint("BOTTOMLEFT",0,0)
	button:SetPoint("BOTTOMRIGHT",0,0)
	button:SetHeight(24)
	button:EnableKeyboard(false)

	local text = button:GetFontString()
	text:SetPoint("LEFT", 7, 0)
	text:SetPoint("RIGHT", -7, 0)

	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
	label:SetPoint("TOPLEFT",0,0)
	label:SetPoint("TOPRIGHT",0,0)
	label:SetJustifyH("CENTER")
	label:SetHeight(18)

	local msgframe = CreateFrame("Frame", nil, UIParent)
	msgframe:SetHeight(30)
	msgframe:SetBackdrop(ControlBackdrop)
	msgframe:SetBackdropColor(0,0,0)
	msgframe:SetFrameStrata("FULLSCREEN_DIALOG")
	msgframe:SetFrameLevel(1000)
	msgframe:SetToplevel(true)

	local msg = msgframe:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	msg:SetText("Press a key to bind, ESC to clear the binding or click the button again to cancel.")
	msgframe.msg = msg
	msg:SetPoint("TOPLEFT", 5, -5)
	msgframe:SetScript("OnUpdate", keybindingMsgFixWidth)
	msgframe:SetPoint("BOTTOM", button, "TOP")
	msgframe:Hide()

	local widget = {
		button      = button,
		label       = label,
		msgframe    = msgframe,
		frame       = frame,
		alignoffset = 30,
		type        = Type,
		text        = text
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	button.obj = widget

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-Label.lua
================
--[[-----------------------------------------------------------------------------
Label Widget
Displays text and optionally an icon.
-------------------------------------------------------------------------------]]
local Type, Version = "Label", 23
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local max, pairs = math.max, pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: GameFontHighlightSmall

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]

local function UpdateImageAnchor(self)
	if self.resizing then return end
	local frame = self.frame
	local width = frame.width or frame:GetWidth() or 0
	local image = self.image
	local label = self.label
	local height

	label:ClearAllPoints()
	image:ClearAllPoints()

	if self.imageshown then
		local imagewidth = image:GetWidth()
		if (width - imagewidth) < 200 or (label:GetText() or "") == "" then
			-- image goes on top centered when less than 200 width for the text, or if there is no text
			image:SetPoint("TOP",0,0)
			label:SetPoint("TOP", image, "BOTTOM")
			label:SetPoint("LEFT",0,0)
			label:SetWidth(width)
			height = image:GetHeight() + label:GetHeight()
		else
			-- image on the left
			image:SetPoint("TOPLEFT",0,0)
			if image:GetHeight() > label:GetHeight() then
				label:SetPoint("LEFT", image, "RIGHT", 4, 0)
			else
				label:SetPoint("TOPLEFT", image, "TOPRIGHT", 4, 0)
			end
			label:SetWidth(width - imagewidth - 4)
			height = max(image:GetHeight(), label:GetHeight())
		end
	else
		-- no image shown
		label:SetPoint("TOPLEFT",0,0)
		label:SetWidth(width)
		height = label:GetHeight()
	end
	
	self.resizing = true
	frame:SetHeight(height)
	frame.height = height
	self.resizing = nil
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		-- set the flag to stop constant size updates
		self.resizing = true
		-- height is set dynamically by the text and image size
		self:SetWidth(200)
		self:SetText()
		self:SetImage(nil)
		self:SetImageSize(16, 16)
		self:SetColor()
		self:SetFontObject()

		-- reset the flag
		self.resizing = nil
		-- run the update explicitly
		UpdateImageAnchor(self)
	end,

	-- ["OnRelease"] = nil,

	["OnWidthSet"] = function(self, width)
		UpdateImageAnchor(self)
	end,

	["SetText"] = function(self, text)
		self.label:SetText(text)
		UpdateImageAnchor(self)
	end,

	["SetColor"] = function(self, r, g, b)
		if not (r and g and b) then
			r, g, b = 1, 1, 1
		end
		self.label:SetVertexColor(r, g, b)
	end,

	["SetImage"] = function(self, path, a1,a2,a3,a4,a5,a6,a7,a8)
		local image = self.image
		image:SetTexture(path)
		
		if image:GetTexture() then
			self.imageshown = true
			if a4 or a8 then
				image:SetTexCoord(a1,a2,a3,a4,a5,a6,a7,a8)
			else
				image:SetTexCoord(0, 1, 0, 1)
			end
		else
			self.imageshown = nil
		end
		UpdateImageAnchor(self)
	end,

	["SetFont"] = function(self, font, height, flags)
		self.label:SetFont(font, height, flags)
	end,

	["SetFontObject"] = function(self, font)
		self:SetFont((font or GameFontHighlightSmall):GetFont())
	end,

	["SetImageSize"] = function(self, width, height)
		self.image:SetWidth(width)
		self.image:SetHeight(height)
		UpdateImageAnchor(self)
	end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:Hide()

	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontHighlightSmall")
	label:SetJustifyH("LEFT")
	label:SetJustifyV("TOP")

	local image = frame:CreateTexture(nil, "BACKGROUND")

	-- create widget
	local widget = {
		label = label,
		image = image,
		frame = frame,
		type  = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-MultiLineEditBox.lua
================
local Type, Version = "MultiLineEditBox", 28
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local AceCore = LibStub("AceCore-3.0")
local hooksecurefunc = AceCore.hooksecurefunc

-- Lua APIs
local strfmt = string.format
local pairs = pairs

-- WoW APIs
local GetCursorInfo, GetSpellInfo, ClearCursor = GetCursorInfo, GetSpellInfo, ClearCursor
local CreateFrame, UIParent = CreateFrame, UIParent
local _G = AceCore._G

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: ACCEPT, ChatFontNormal

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
if not AceGUIMultiLineEditBoxInsertLink then
	-- upgradeable hook
	hooksecurefunc("BankFrameItemButtonGeneric_OnClick",
		function(button)
			if button == "LeftButton" and IsShiftKeyDown() and not this.isBag then
				return _G.AceGUIMultiLineEditBoxInsertLink(GetContainerItemLink(BANK_CONTAINER, this:GetID()))
			end
		end)
	hooksecurefunc("ContainerFrameItemButton_OnClick",
		function(button, ignoreModifiers)
			if button == "LeftButton" and IsShiftKeyDown() and not ignoreModifiers then
				return _G.AceGUIMultiLineEditBoxInsertLink(GetContainerItemLink(this:GetParent():GetID(), this:GetID()))
			end
		end)

	hooksecurefunc("KeyRingItemButton_OnClick",
		function(button)
			if button == "LeftButton" and IsShiftKeyDown() and not this.isBag then
				return _G.AceGUIMultiLineEditBoxInsertLink(GetContainerItemLink(KEYRING_CONTAINER, this:GetID()))
			end
		end)
	hooksecurefunc("LootFrameItem_OnClick",
		function(button)
			if button == "LeftButton" and IsShiftKeyDown() then
				return _G.AceGUIMultiLineEditBoxInsertLink(GetLootSlotLink(this.slot))
			end
		end)
	hooksecurefunc("SetItemRef",
		function(link, text, button)
			if IsShiftKeyDown() then
				if strsub(link,1,6) == "player" then
					local name = strsub(link,8)
					if name and (strlen(name) > 0) then
						return _G.AceGUIMultiLineEditBoxInsertLink(name)
					end
				else
					return _G.AceGUIMultiLineEditBoxInsertLink(text)
				end
			end
		end)
	hooksecurefunc("MerchantItemButton_OnClick",
		function(button, ignoreModifiers)
			if MerchantFrame.selectedTab == 1 and button == "LeftButton" and IsShiftKeyDown() and not ignoreModifiers then
				return _G.AceGUIMultiLineEditBoxInsertLink(GetMerchantItemLink(this:GetID()))
			end
		end)
	hooksecurefunc("PaperDollItemSlotButton_OnClick",
		function(button, ignoreModifiers)
			if button == "LeftButton" and IsShiftKeyDown() and not ignoreModifiers then
				return _G.AceGUIMultiLineEditBoxInsertLink(GetInventoryItemLink("player", this:GetID()))
			end
		end)
	hooksecurefunc("QuestItem_OnClick",
		function()
			if IsShiftKeyDown() and this.rewardType ~= "spell" then
				return _G.AceGUIMultiLineEditBoxInsertLink(GetQuestItemLink(this.type, this:GetID()))
			end
		end)
	hooksecurefunc("QuestRewardItem_OnClick",
		function()
			if IsShiftKeyDown() and this.rewardType ~= "spell" then
				return _G.AceGUIMultiLineEditBoxInsertLink(GetQuestItemLink(this.type, this:GetID()))
			end
		end)
	hooksecurefunc("QuestLogTitleButton_OnClick",
		function(button)
			if IsShiftKeyDown() and (not this.isHeader) then
				return _G.AceGUIMultiLineEditBoxInsertLink(gsub(this:GetText(), " *(.*)", "%1"))
			end
		end)
	hooksecurefunc("QuestLogRewardItem_OnClick",
		function()
			if IsShiftKeyDown() and this.rewardType ~= "spell" then
				return _G.AceGUIMultiLineEditBoxInsertLink(GetQuestLogItemLink(this.type, this:GetID()))
			end
		end)
	hooksecurefunc("SpellButton_OnClick",
		function(drag)
			local id = SpellBook_GetSpellID(this:GetID())
			if id <= MAX_SPELLS and (not drag) and IsShiftKeyDown() then
				local spellName, subSpellName = GetSpellName(id, SpellBookFrame.bookType)
				if spellName and not IsSpellPassive(id, SpellBookFrame.bookType) then
					if subSpellName and (strlen(subSpellName) > 0) then
						_G.AceGUIMultiLineEditBoxInsertLink(spellName.."("..subSpellName..")");
					else
						_G.AceGUIMultiLineEditBoxInsertLink(spellName);
					end
				end
			end
		end)
end

function _G.AceGUIMultiLineEditBoxInsertLink(text)
	for i = 1, AceGUI:GetWidgetCount(Type) do
		local editbox = _G[strfmt("MultiLineEditBox%uEdit",i)]
		if editbox and editbox:IsVisible() and editbox.hasfocus then
			editbox:Insert(text)
			return true
		end
	end
end

local function Layout(self)
	self:SetHeight(self.numlines * 14 + (self.disablebutton and 19 or 41) + self.labelHeight)

	if self.labelHeight == 0 then
		self.scrollBar:SetPoint("TOP", self.frame, "TOP", 0, -23)
	else
		self.scrollBar:SetPoint("TOP", self.label, "BOTTOM", 0, -19)
	end

	if self.disablebutton then
		self.scrollBar:SetPoint("BOTTOM", self.frame, "BOTTOM", 0, 21)
		self.scrollBG:SetPoint("BOTTOMLEFT", 0, 4)
	else
		self.scrollBar:SetPoint("BOTTOM", self.button, "TOP", 0, 18)
		self.scrollBG:SetPoint("BOTTOMLEFT", self.button, "TOPLEFT")
	end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function OnClick()	-- Button
	local self = this.obj
	self.editBox:ClearFocus()
	if not self:Fire("OnEnterPressed", 1, self.editBox:GetText()) then
		self.button:Disable()
	end
end

local function OnCursorChanged()	-- EditBox

	local self, y = this.obj.scrollFrame, -arg2
	local offset = self:GetVerticalScroll()
	if y < offset then
		self:SetVerticalScroll(y)
	else
		y = y + arg4 - self:GetHeight()
		if y > offset then
			self:SetVerticalScroll(y)
		end
	end
end

local function OnEditFocusLost()	-- EditBox
	this.hasfocus = nil
	this:HighlightText(0, 0)
	this.obj:Fire("OnEditFocusLost")
end

local function OnEnter()	-- EditBox / ScrollFrame
	local self = this.obj
	if not self.entered then
		self.entered = true
		self:Fire("OnEnter")
	end
end

local function OnLeave()	-- EditBox / ScrollFrame
	local self = this.obj
	if self.entered then
		self.entered = nil
		self:Fire("OnLeave")
	end
end

local function OnMouseUp()	-- ScrollFrame
	local self = this.obj.editBox
	self:SetFocus()
	local n = self:GetNumLetters()
	self:HighlightText(n,n)
end

local function OnReceiveDrag()	-- EditBox / ScrollFrame
	if not GetCursorInfo then return end
	local type, id, info = GetCursorInfo()
	if type == "spell" then
		local spell, rank = GetSpellName(id, info)
		if rank ~= "" then spell = spell.."("..rank..")" end
		info = spell
	elseif type ~= "item" then
		return
	end
	ClearCursor()
	local self = this.obj
	local editBox = self.editBox
	if not this.hasfocus then
		this.hasfocus = true
		editBox:SetFocus()
		local n = editBox:GetNumLetters()
		editBox:HighlightText(n,n)
	end
	editBox:Insert(info)
	self.button:Enable()
end

local function OnSizeChanged()	-- ScrollFrame
	this.obj.editBox:SetWidth(arg1)
end

local function OnTextChanged()	-- EditBox
	local self = this.obj
	local value = this:GetText()
	if tostring(value) ~= tostring(self.lasttext) then
		self:Fire("OnTextChanged", 1, value)
		self.lasttext = value
		self.button:Enable()
	end
end

local function OnTextSet()	-- EditBox
	this:HighlightText(0, 0)
	this.obj.button:Disable()
end

local function OnVerticalScroll()	-- ScrollFrame
	local self = this.obj
	local editBox = self.editBox
	editBox:SetHitRectInsets(0, 0, arg1, editBox:GetHeight() - arg1 - this:GetHeight())

	self.scrollFrame:SetScrollChild(self.editBox)
	self.editBox:SetPoint("TOPLEFT",0,arg1)
	self.editBox:SetPoint("TOPRIGHT",0,arg1)
end

local function OnShowFocus()
	this.obj.editBox:SetFocus()
	this:SetScript("OnShow", nil)
end

local function OnEditFocusGained()
	this.hasfocus = true
	AceGUI:SetFocus(this.obj)
	this.obj:Fire("OnEditFocusGained")
end

local function OnEscapePressed()	-- EditBox
	AceGUI:ClearFocus()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self.editBox:SetText("")
		self:SetDisabled(false)
		self:SetWidth(200)
		self:DisableButton(false)
		self:SetNumLines()
		self.entered = nil
		self:SetMaxLetters(0)
	end,

	["OnRelease"] = function(self)
		self:ClearFocus()
	end,

	["SetDisabled"] = function(self, disabled)
		local editBox = self.editBox
		if disabled then
			editBox:ClearFocus()
			editBox:EnableMouse(false)
			editBox:SetTextColor(0.5, 0.5, 0.5)
			self.label:SetTextColor(0.5, 0.5, 0.5)
			self.scrollFrame:EnableMouse(false)
			self.button:Disable()
		else
			editBox:EnableMouse(true)
			editBox:SetTextColor(1, 1, 1)
			self.label:SetTextColor(1, 0.82, 0)
			self.scrollFrame:EnableMouse(true)
		end
	end,

	["SetLabel"] = function(self, text)
		if text and text ~= "" then
			self.label:SetText(text)
			if self.labelHeight ~= 10 then
				self.labelHeight = 10
				self.label:Show()
			end
		elseif self.labelHeight ~= 0 then
			self.labelHeight = 0
			self.label:Hide()
		end
		Layout(self)
	end,

	["SetNumLines"] = function(self, value)
		if not value or value < 4 then
			value = 4
		end
		self.numlines = value
		Layout(self)
	end,

	["SetText"] = function(self, text)
		self.lasttext = text or ""
		self.editBox:SetText(text or "")
		self.editBox:HighlightText(0)
		self.button:Disable()
	end,

	["GetText"] = function(self)
		return self.editBox:GetText()
	end,

	["SetMaxLetters"] = function (self, num)
		self.editBox:SetMaxLetters(num or 0)
	end,

	["DisableButton"] = function(self, disabled)
		self.disablebutton = disabled
		if disabled then
			self.button:Hide()
		else
			self.button:Show()
		end
		Layout(self)
	end,

	["ClearFocus"] = function(self)
		self.editBox:ClearFocus()
		self.frame:SetScript("OnShow", nil)
	end,

	["SetFocus"] = function(self)
		self.editBox:SetFocus()
		if not self.frame:IsShown() then
			self.frame:SetScript("OnShow", OnShowFocus)
		end
	end,

	["HighlightText"] = function(self, from, to)
		self.editBox:HighlightText(from, to)
	end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local backdrop = {
	bgFile = [[Interface\Tooltips\UI-Tooltip-Background]],
	edgeFile = [[Interface\Tooltips\UI-Tooltip-Border]], edgeSize = 16,
	insets = { left = 4, right = 3, top = 4, bottom = 3 }
}

local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:Hide()

	local widgetNum = AceGUI:GetNextWidgetNum(Type)

	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
	label:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, -4)
	label:SetPoint("TOPRIGHT", frame, "TOPRIGHT", 0, -4)
	label:SetJustifyH("LEFT")
	label:SetText(ACCEPT)
	label:SetHeight(10)

	local button = CreateFrame("Button", strfmt("%s%dButton", Type, widgetNum), frame, "UIPanelButtonTemplate")
	button:SetPoint("BOTTOMLEFT", 0, 4)
	button:SetHeight(22)
	button:SetWidth(label:GetStringWidth() + 24)
	button:SetText(ACCEPT)
	button:SetScript("OnClick", OnClick)
	button:Disable()

	local text = button:GetFontString()
	text:ClearAllPoints()
	text:SetPoint("TOPLEFT", button, "TOPLEFT", 5, -5)
	text:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT", -5, 1)
	text:SetJustifyV("MIDDLE")

	local scrollBG = CreateFrame("Frame", nil, frame)
	scrollBG:SetBackdrop(backdrop)
	scrollBG:SetBackdropColor(0, 0, 0)
	scrollBG:SetBackdropBorderColor(0.4, 0.4, 0.4)

	local scrollFrame = CreateFrame("ScrollFrame", strfmt("%s%dScrollFrame", Type, widgetNum), frame, "UIPanelScrollFrameTemplate")

	local scrollBar = _G[scrollFrame:GetName() .. "ScrollBar"]
	scrollBar:ClearAllPoints()
	scrollBar:SetPoint("TOP", label, "BOTTOM", 0, -19)
	scrollBar:SetPoint("BOTTOM", button, "TOP", 0, 18)
	scrollBar:SetPoint("RIGHT", frame, "RIGHT")

	scrollBG:SetPoint("TOPRIGHT", scrollBar, "TOPLEFT", 0, 19)
	scrollBG:SetPoint("BOTTOMLEFT", button, "TOPLEFT")

	scrollFrame:SetPoint("TOPLEFT", scrollBG, "TOPLEFT", 5, -6)
	scrollFrame:SetPoint("BOTTOMRIGHT", scrollBG, "BOTTOMRIGHT", -4, 4)
	scrollFrame:SetScript("OnEnter", OnEnter)
	scrollFrame:SetScript("OnLeave", OnLeave)
	scrollFrame:SetScript("OnMouseUp", OnMouseUp)
	scrollFrame:SetScript("OnReceiveDrag", OnReceiveDrag)
	scrollFrame:SetScript("OnSizeChanged", OnSizeChanged)
	local old = scrollFrame:GetScript("OnVerticalScroll");
	if old then
		scrollFrame:SetScript("OnVerticalScroll", function()
			old()
			OnVerticalScroll()
		end)
	else
		scrollFrame:SetScript("OnVerticalScroll", OnVerticalScroll)
	end

	local editBox = CreateFrame("EditBox", strfmt("%s%dEdit", Type, widgetNum), scrollFrame)
	editBox:SetFontObject(ChatFontNormal)
	editBox:SetMultiLine(true)
	editBox:EnableMouse(true)
	editBox:SetAutoFocus(false)
	--editBox:SetCountInvisibleLetters(false)
	editBox:SetScript("OnCursorChanged", OnCursorChanged)
	editBox:SetScript("OnEditFocusLost", OnEditFocusLost)
	editBox:SetScript("OnEnter", OnEnter)
	editBox:SetScript("OnEscapePressed", OnEscapePressed)
	editBox:SetScript("OnLeave", OnLeave)
	editBox:SetScript("OnMouseDown", OnReceiveDrag)
	editBox:SetScript("OnReceiveDrag", OnReceiveDrag)
	editBox:SetScript("OnTextChanged", OnTextChanged)
	editBox:SetScript("OnTextSet", OnTextSet)
	editBox:SetScript("OnEditFocusGained", OnEditFocusGained)

	-- Ace3v: the orders are important here
	scrollFrame:SetScrollChild(editBox)
	editBox:SetPoint("TOPLEFT",0,0)
	editBox:SetPoint("TOPRIGHT",0,0)

	local widget = {
		button      = button,
		editBox     = editBox,
		frame       = frame,
		label       = label,
		labelHeight = 10,
		numlines    = 4,
		scrollBar   = scrollBar,
		scrollBG    = scrollBG,
		scrollFrame = scrollFrame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	button.obj, editBox.obj, scrollFrame.obj = widget, widget, widget

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIWidget-Slider.lua
================
--[[-----------------------------------------------------------------------------
Slider Widget
Graphical Slider, like, for Range values.
-------------------------------------------------------------------------------]]
local Type, Version = "Slider", 23
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local min, max, floor = math.min, math.max, math.floor
local tonumber, pairs, format = tonumber, pairs, string.format

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame, UIParent = CreateFrame, UIParent

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: GameFontHighlightSmall

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function UpdateText(self)
	local value = self.value or 0
	if self.ispercent then
		self.editbox:SetText(format(("%s%%"),floor(value * 1000 + 0.5) / 10))
	else
		self.editbox:SetText(floor(value * 100 + 0.5) / 100)
	end
end

local function UpdateLabels(self)
	local min, max = (self.min or 0), (self.max or 100)
	if self.ispercent then
		self.lowtext:SetText(format("%s%%", (min * 100)))
		self.hightext:SetText(format("%s%%", (max * 100)))
	else
		self.lowtext:SetText(min)
		self.hightext:SetText(max)
	end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter()
	this.obj:Fire("OnEnter")
end

local function Control_OnLeave()
	this.obj:Fire("OnLeave")
end

local function Frame_OnMouseDown()
	this.obj.slider:EnableMouseWheel(true)
	AceGUI:ClearFocus()
end

local function Slider_OnValueChanged()
	local self = this.obj
	if not this.setup then
		local newvalue = this:GetValue()
		if self.step and self.step > 0 then
			local min_value = self.min or 0
			newvalue = floor((newvalue - min_value) / self.step + 0.5) * self.step + min_value
		end
		if newvalue ~= self.value and not self.disabled then
			self.value = newvalue
			self:Fire("OnValueChanged", 1, newvalue)
		end
		if self.value then
			UpdateText(self)
		end
	end
end

local function Slider_OnMouseUp()
	local self = this.obj
	self:Fire("OnMouseUp", 1, self.value)
end

local function Slider_OnMouseWheel()
	local self = this.obj
	if not self.disabled then
		local value = self.value
		if arg1 > 0 then
			value = min(value + (self.step or 1), self.max)
		else
			value = max(value - (self.step or 1), self.min)
		end
		self.slider:SetValue(value)
	end
end

local function EditBox_OnEscapePressed()
	this:ClearFocus()
end

local function EditBox_OnEnterPressed()
	local self = this.obj
	local value = this:GetText()
	if self.ispercent then
		value = string.gsub(value, '%%', '')
		value = tonumber(value) / 100
	else
		value = tonumber(value)
	end
	
	if value then
		PlaySound("igMainMenuOptionCheckBoxOn")
		self.slider:SetValue(value)
		self:Fire("OnMouseUp", 1, value)
	end
end

local function EditBox_OnEnter()
	this:SetBackdropBorderColor(0.5, 0.5, 0.5, 1)
end

local function EditBox_OnLeave()
	this:SetBackdropBorderColor(0.3, 0.3, 0.3, 0.8)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetWidth(200)
		self:SetHeight(44)
		self:SetDisabled(false)
		self:SetIsPercent(nil)
		self:SetSliderValues(0,100,1)
		self:SetValue(0)
		self.slider:EnableMouseWheel(false)
	end,

	-- ["OnRelease"] = nil,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.slider:EnableMouse(false)
			self.label:SetTextColor(.5, .5, .5)
			self.hightext:SetTextColor(.5, .5, .5)
			self.lowtext:SetTextColor(.5, .5, .5)
			--self.valuetext:SetTextColor(.5, .5, .5)
			self.editbox:SetTextColor(.5, .5, .5)
			self.editbox:EnableMouse(false)
			self.editbox:ClearFocus()
		else
			self.slider:EnableMouse(true)
			self.label:SetTextColor(1, .82, 0)
			self.hightext:SetTextColor(1, 1, 1)
			self.lowtext:SetTextColor(1, 1, 1)
			--self.valuetext:SetTextColor(1, 1, 1)
			self.editbox:SetTextColor(1, 1, 1)
			self.editbox:EnableMouse(true)
		end
	end,

	["SetValue"] = function(self, value)
		self.slider.setup = true
		self.slider:SetValue(value)
		self.value = value
		UpdateText(self)
		self.slider.setup = nil
	end,

	["GetValue"] = function(self)
		return self.value
	end,

	["SetLabel"] = function(self, text)
		self.label:SetText(text)
	end,

	["SetSliderValues"] = function(self, min, max, step)
		local frame = self.slider
		frame.setup = true
		self.min = min
		self.max = max
		self.step = step
		frame:SetMinMaxValues(min or 0,max or 100)
		UpdateLabels(self)
		frame:SetValueStep(step or 1)
		if self.value then
			frame:SetValue(self.value)
		end
		frame.setup = nil
	end,

	["SetIsPercent"] = function(self, value)
		self.ispercent = value
		UpdateLabels(self)
		UpdateText(self)
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local SliderBackdrop  = {
	bgFile = "Interface\\Buttons\\UI-SliderBar-Background",
	edgeFile = "Interface\\Buttons\\UI-SliderBar-Border",
	tile = true, tileSize = 8, edgeSize = 8,
	insets = { left = 3, right = 3, top = 6, bottom = 6 }
}

local ManualBackdrop = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\ChatFrame\\ChatFrameBackground",
	tile = true, edgeSize = 1, tileSize = 5,
}

local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)

	frame:EnableMouse(true)
	frame:SetScript("OnMouseDown", Frame_OnMouseDown)

	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	label:SetPoint("TOPLEFT",0,0)
	label:SetPoint("TOPRIGHT",0,0)
	label:SetJustifyH("CENTER",0,0)
	label:SetHeight(15)

	local slider = CreateFrame("Slider", nil, frame)
	slider:SetOrientation("HORIZONTAL")
	slider:SetHeight(15)
	slider:SetHitRectInsets(0, 0, -10, 0)
	slider:SetBackdrop(SliderBackdrop)
	slider:SetThumbTexture("Interface\\Buttons\\UI-SliderBar-Button-Horizontal")
	slider:SetPoint("TOP", label, "BOTTOM")
	slider:SetPoint("LEFT", 3, 0)
	slider:SetPoint("RIGHT", -3, 0)
	slider:SetValue(0)
	slider:SetScript("OnValueChanged",Slider_OnValueChanged)
	slider:SetScript("OnEnter", Control_OnEnter)
	slider:SetScript("OnLeave", Control_OnLeave)
	slider:SetScript("OnMouseUp", Slider_OnMouseUp)
	slider:SetScript("OnMouseWheel", Slider_OnMouseWheel)

	local lowtext = slider:CreateFontString(nil, "ARTWORK", "GameFontHighlightSmall")
	lowtext:SetPoint("TOPLEFT", slider, "BOTTOMLEFT", 2, 3)

	local hightext = slider:CreateFontString(nil, "ARTWORK", "GameFontHighlightSmall")
	hightext:SetPoint("TOPRIGHT", slider, "BOTTOMRIGHT", -2, 3)

	local editbox = CreateFrame("EditBox", nil, frame)
	editbox:SetAutoFocus(false)
	editbox:SetFontObject(GameFontHighlightSmall)
	editbox:SetPoint("TOP", slider, "BOTTOM")
	editbox:SetHeight(14)
	editbox:SetWidth(70)
	editbox:SetJustifyH("CENTER")
	editbox:EnableMouse(true)
	editbox:SetBackdrop(ManualBackdrop)
	editbox:SetBackdropColor(0, 0, 0, 0.5)
	editbox:SetBackdropBorderColor(0.3, 0.3, 0.30, 0.80)
	editbox:SetScript("OnEnter", EditBox_OnEnter)
	editbox:SetScript("OnLeave", EditBox_OnLeave)
	editbox:SetScript("OnEnterPressed", EditBox_OnEnterPressed)
	editbox:SetScript("OnEscapePressed", EditBox_OnEscapePressed)

	local widget = {
		label       = label,
		slider      = slider,
		lowtext     = lowtext,
		hightext    = hightext,
		editbox     = editbox,
		alignoffset = 25,
		frame       = frame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	slider.obj, editbox.obj = widget, widget

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type,Constructor,Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/widgets.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<!-- Container -->
	<Script file="AceGUIContainer-BlizOptionsGroup.lua"/>
	<Script file="AceGUIContainer-DropDownGroup.lua"/>
	<Script file="AceGUIContainer-Frame.lua"/>
	<Script file="AceGUIContainer-InlineGroup.lua"/>
	<Script file="AceGUIContainer-ScrollFrame.lua"/>
	<Script file="AceGUIContainer-SimpleGroup.lua"/>
	<Script file="AceGUIContainer-TabGroup.lua"/>
	<Script file="AceGUIContainer-TreeGroup.lua"/>
	<Script file="AceGUIContainer-Window.lua"/>
	<!-- Widgets -->
	<Script file="AceGUIWidget-Button.lua"/>
	<Script file="AceGUIWidget-CheckBox.lua"/>
	<Script file="AceGUIWidget-ColorPicker.lua"/>
	<Script file="AceGUIWidget-DropDown.lua"/>
	<Script file="AceGUIWidget-DropDown-Items.lua"/>
	<Script file="AceGUIWidget-EditBox.lua"/>
	<Script file="AceGUIWidget-Heading.lua"/>
	<Script file="AceGUIWidget-Icon.lua"/>
	<Script file="AceGUIWidget-InteractiveLabel.lua"/>
	<Script file="AceGUIWidget-Keybinding.lua"/>
	<Script file="AceGUIWidget-Label.lua"/>
	<Script file="AceGUIWidget-MultiLineEditBox.lua"/>
	<Script file="AceGUIWidget-Slider.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceHook-3.0/AceHook-3.0.lua
================
--- **AceHook-3.0** offers safe Hooking/Unhooking of functions, methods and frame scripts.
-- Using AceHook-3.0 is recommended when you need to unhook your hooks again, so the hook chain isn't broken
-- when you manually restore the original function.
--
-- **AceHook-3.0** can be embeded into your addon, either explicitly by calling AceHook:Embed(MyAddon) or by
-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
-- and can be accessed directly, without having to explicitly call AceHook itself.\\
-- It is recommended to embed AceHook, otherwise you'll have to specify a custom `self` on all calls you
-- make into AceHook.
-- @class file
-- @name AceHook-3.0
-- @release $Id: AceHook-3.0.lua 1118 2014-10-12 08:21:54Z nevcairiel $
local ACEHOOK_MAJOR, ACEHOOK_MINOR = "AceHook-3.0", 8
local AceHook, oldminor = LibStub:NewLibrary(ACEHOOK_MAJOR, ACEHOOK_MINOR)

if not AceHook then return end -- No upgrade needed

local AceCore = LibStub("AceCore-3.0")
local new, del = AceCore.new, AceCore.del

AceHook.embeded = AceHook.embeded or {}
AceHook.registry = AceHook.registry or setmetatable({}, {__index = function(tbl, key) tbl[key] = {} return tbl[key] end })
AceHook.handlers = AceHook.handlers or {}
AceHook.actives = AceHook.actives or {}
AceHook.scripts = AceHook.scripts or {}
AceHook.onceSecure = AceHook.onceSecure or {}
AceHook.hooks = AceHook.hooks or {}

-- local upvalues
local registry = AceHook.registry
local handlers = AceHook.handlers
local actives = AceHook.actives
local scripts = AceHook.scripts
local onceSecure = AceHook.onceSecure

-- Lua APIs
local pairs, next, type = pairs, next, type
local format = string.format
local assert, error = assert, error

-- WoW APIs
local hooksecurefunc, issecurevariable = AceCore.hooksecurefunc, AceCore.issecurevariable

local _G = AceCore._G

local protectedScripts = {
	OnClick = true,
}

-- upgrading of embeded is done at the bottom of the file

local mixins = {
	"Hook", "SecureHook",
	"HookScript", "SecureHookScript",
	"Unhook", "UnhookAll",
	"IsHooked",
	"RawHook", "RawHookScript"
}

-- AceHook:Embed( target )
-- target (object) - target object to embed AceHook in
--
-- Embeds AceEevent into the target object making the functions from the mixins list available on target:..
function AceHook:Embed( target )
	for k, v in pairs( mixins ) do
		target[v] = self[v]
	end
	self.embeded[target] = true
	-- inject the hooks table safely
	target.hooks = target.hooks or {}
	return target
end

-- AceHook:OnEmbedDisable( target )
-- target (object) - target object that is being disabled
--
-- Unhooks all hooks when the target disables.
-- this method should be called by the target manually or by an addon framework
function AceHook:OnEmbedDisable( target )
	target:UnhookAll()
end

-- failsafe means even the hooking method fails, the original method will
-- always be called
local function createHook(self, handler, orig, secure, failsafe)
	local uid
	local method = type(handler) == "string"
	-- Ace3v: when this function called in the "hook" function, we have
	--        failsafe = not (raw or secure), so the first check condition
	--        is same as "if failsafe" or "if not raw and not secure"
	if failsafe and not secure then
		-- failsafe hook creation
		uid = function(...)
			if actives[uid] then
				if method then
					self[handler](self,unpack(arg))
				else
					handler(unpack(arg))
				end
			end
			return orig(unpack(arg))
		end
		-- /failsafe hook
	else
		-- all other hooks
		uid = function(...)
			if actives[uid] then
				if method then
					return self[handler](self,unpack(arg))
				else
					return handler(unpack(arg))
				end
			elseif not secure then -- backup on non secure
				return orig(unpack(arg))
			end
		end
		-- /hook
	end
	return uid
end

local function donothing() end

-- @param self
-- @param obj			nil or a frame object, use with script = true
-- @param method		string, the name of a global function or the name of an object method
-- @param handler		function, or string when it's a method of 'self', if nil then will use the same value as method
-- @param script		boolean, must be true, if the hooked object is a frame
-- @param secure		boolean, if hooking a secure script, if true the original script will be called first, else later
-- @param raw			boolean, if raw hooking (replacing the original method)
-- @param forceSecure	boolean, if forcing to hook a secure method
-- @param usage
local function hook(self, obj, method, handler, script, secure, raw, forceSecure, usage)
	if not handler then handler = method end

	-- These asserts make sure AceHooks's devs play by the rules.
	assert(not script or type(script) == "boolean")
	assert(not secure or type(secure) == "boolean")
	assert(not raw or type(raw) == "boolean")
	assert(not forceSecure or type(forceSecure) == "boolean")
	assert(usage)

	-- Error checking Battery!
	if obj and type(obj) ~= "table" then
		error(format("%s: 'object' - nil or table expected got %s", usage, type(obj)), 3)
	end
	if type(method) ~= "string" then
		error(format("%s: 'method' - string expected got %s", usage, type(method)), 3)
	end
	if type(handler) ~= "string" and type(handler) ~= "function" then
		error(format("%s: 'handler' - nil, string, or function expected got %s", usage, type(handler)), 3)
	end
	if type(handler) == "string" and type(self[handler]) ~= "function" then
		error(format("%s: 'handler' - Handler specified does not exist at self[handler]", usage), 3)
	end
	if script then
		if not obj or not obj.GetScript or not obj:HasScript(method) then
			error(format("%s: You can only hook a script on a frame object", usage), 3)
		end
		if not secure and obj.IsProtected and obj:IsProtected() and protectedScripts[method] then
			error(format("Cannot hook secure script %q; Use SecureHookScript(obj, method, [handler]) instead.", method), 3)
		end
	else
		local issecure
		if obj then
			issecure = onceSecure[obj] and onceSecure[obj][method] or issecurevariable(obj, method)
		else
			issecure = onceSecure[method] or issecurevariable(method)
		end
		if issecure then
			if forceSecure then
				if obj then
					onceSecure[obj] = onceSecure[obj] or {}
					onceSecure[obj][method] = true
				else
					onceSecure[method] = true
				end
			elseif not secure then
				error(format("%s: Attempt to hook secure function %s. Use `SecureHook' or add `true' to the argument list to override.", usage, method), 3)
			end
		end
	end

	local uid
	if obj then
		uid = registry[self][obj] and registry[self][obj][method]
	else
		uid = registry[self][method]
	end

	if uid then
		if actives[uid] then
			-- Only two sane choices exist here.  We either a) error 100% of the time or b) always unhook and then hook
			-- choice b would likely lead to odd debuging conditions or other mysteries so we're going with a.
			error(format("Attempting to rehook already active hook %s.", method))
		end

		if handlers[uid] == handler then -- turn on a decative hook, note enclosures break this ability, small memory leak
			actives[uid] = true
			return
		elseif obj then -- is there any reason not to call unhook instead of doing the following several lines?
			if self.hooks and self.hooks[obj] then
				self.hooks[obj][method] = nil
			end
			registry[self][obj][method] = nil
		else
			if self.hooks then
				self.hooks[method] = nil
			end
			registry[self][method] = nil
		end
		handlers[uid], actives[uid], scripts[uid] = nil, nil, nil
		uid = nil
	end

	local orig
	if script then
		-- Sometimes there is not a original function for a script.
		orig = obj:GetScript(method) or donothing
	elseif obj then
		orig = obj[method]
	else
		orig = _G[method]
	end

	if not orig then
		error(format("%s: Attempting to hook a non existing target", usage), 3)
	end

	uid = createHook(self, handler, orig, secure, not (raw or secure))

	if obj then
		registry[self][obj] = registry[self][obj] or new()
		registry[self][obj][method] = uid

		if not secure then
			self.hooks[obj] = self.hooks[obj] or new()
			self.hooks[obj][method] = orig
		end

		if script then
			if not secure then
				obj:SetScript(method, uid)
			else
				obj:SetScript(method, function(...)
					local tmp = {orig(unpack(arg))}
					uid(unpack(arg))
					return unpack(tmp)
				end)
				--obj:HookScript(method, uid)	-- Ace3v: vanilla frame has no HookScript
			end
		else
			if not secure then
				obj[method] = uid
			else
				hooksecurefunc(obj, method, uid)
			end
		end
	else
		registry[self][method] = uid

		if not secure then
			_G[method] = uid
			self.hooks[method] = orig
		else
			hooksecurefunc(method, uid)
		end
	end

	actives[uid], handlers[uid], scripts[uid] = true, handler, script and true or nil
end

--- Hook a function or a method on an object.
-- The hook created will be a "safe hook", that means that your handler will be called
-- before the hooked function ("Pre-Hook"), and you don't have to call the original function yourself,
-- however you cannot stop the execution of the function, or modify any of the arguments/return values.\\
-- This type of hook is typically used if you need to know if some function got called, and don't want to modify it.
-- @paramsig [object], method, [handler], [hookSecure]
-- @param object The object to hook a method from
-- @param method If object was specified, the name of the method, or the name of the function to hook.
-- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked function)
-- @param hookSecure If true, AceHook will allow hooking of secure functions.
-- @usage
-- -- create an addon with AceHook embeded
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("HookDemo", "AceHook-3.0")
--
-- function MyAddon:OnEnable()
--   -- Hook ActionButton_UpdateHotkeys, overwriting the secure status
--   self:Hook("ActionButton_UpdateHotkeys", true)
-- end
--
-- function MyAddon:ActionButton_UpdateHotkeys(button, type)
--   print(button:GetName() .. " is updating its HotKey")
-- end
function AceHook:Hook(object, method, handler, hookSecure)
	if type(object) == "string" then
		method, handler, hookSecure, object = object, method, handler, nil
	end

	if handler == true then
		handler, hookSecure = nil, true
	end

	hook(self, object, method, handler, false, false, false, hookSecure or false, "Usage: Hook([object], method, [handler], [hookSecure])")
end

--- RawHook a function or a method on an object.
-- The hook created will be a "raw hook", that means that your handler will completly replace
-- the original function, and your handler has to call the original function (or not, depending on your intentions).\\
-- The original function will be stored in `self.hooks[object][method]` or `self.hooks[functionName]` respectively.\\
-- This type of hook can be used for all purposes, and is usually the most common case when you need to modify arguments
-- or want to control execution of the original function.
-- @paramsig [object], method, [handler], [hookSecure]
-- @param object The object to hook a method from
-- @param method If object was specified, the name of the method, or the name of the function to hook.
-- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked function)
-- @param hookSecure If true, AceHook will allow hooking of secure functions.
-- @usage
-- -- create an addon with AceHook embeded
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("HookDemo", "AceHook-3.0")
--
-- function MyAddon:OnEnable()
--   -- Hook ActionButton_UpdateHotkeys, overwriting the secure status
--   self:RawHook("ActionButton_UpdateHotkeys", true)
-- end
--
-- function MyAddon:ActionButton_UpdateHotkeys(button, type)
--   if button:GetName() == "MyButton" then
--     -- do stuff here
--   else
--     self.hooks.ActionButton_UpdateHotkeys(button, type)
--   end
-- end
function AceHook:RawHook(object, method, handler, hookSecure)
	if type(object) == "string" then
		method, handler, hookSecure, object = object, method, handler, nil
	end

	if handler == true then
		handler, hookSecure = nil, true
	end

	hook(self, object, method, handler, false, false, true, hookSecure or false,  "Usage: RawHook([object], method, [handler], [hookSecure])")
end

--- SecureHook a function or a method on an object.
-- This function is a wrapper around the `hooksecurefunc` function in the WoW API. Using AceHook
-- extends the functionality of secure hooks, and adds the ability to unhook once the hook isn't
-- required anymore, or the addon is being disabled.\\
-- Secure Hooks should be used if the secure-status of the function is vital to its function,
-- and taint would block execution. Secure Hooks are always called after the original function was called
-- ("Post Hook"), and you cannot modify the arguments, return values or control the execution.
-- @paramsig [object], method, [handler]
-- @param object The object to hook a method from
-- @param method If object was specified, the name of the method, or the name of the function to hook.
-- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked function)
function AceHook:SecureHook(object, method, handler)
	if type(object) == "string" then
		method, handler, object = object, method, nil
	end

	hook(self, object, method, handler, false, true, false, false,  "Usage: SecureHook([object], method, [handler])")
end

--- Hook a script handler on a frame.
-- The hook created will be a "safe hook", that means that your handler will be called
-- before the hooked script ("Pre-Hook"), and you don't have to call the original function yourself,
-- however you cannot stop the execution of the function, or modify any of the arguments/return values.\\
-- This is the frame script equivalent of the :Hook safe-hook. It would typically be used to be notified
-- when a certain event happens to a frame.
-- @paramsig frame, script, [handler]
-- @param frame The Frame to hook the script on
-- @param script The script to hook
-- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked script)
-- @usage
-- -- create an addon with AceHook embeded
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("HookDemo", "AceHook-3.0")
--
-- function MyAddon:OnEnable()
--   -- Hook the OnShow of FriendsFrame
--   self:HookScript(FriendsFrame, "OnShow", "FriendsFrameOnShow")
-- end
--
-- function MyAddon:FriendsFrameOnShow(frame)
--   print("The FriendsFrame was shown!")
-- end
function AceHook:HookScript(frame, script, handler)
	hook(self, frame, script, handler, true, false, false, false,  "Usage: HookScript(object, method, [handler])")
end

--- RawHook a script handler on a frame.
-- The hook created will be a "raw hook", that means that your handler will completly replace
-- the original script, and your handler has to call the original script (or not, depending on your intentions).\\
-- The original script will be stored in `self.hooks[frame][script]`.\\
-- This type of hook can be used for all purposes, and is usually the most common case when you need to modify arguments
-- or want to control execution of the original script.
-- @paramsig frame, script, [handler]
-- @param frame The Frame to hook the script on
-- @param script The script to hook
-- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked script)
-- @usage
-- -- create an addon with AceHook embeded
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("HookDemo", "AceHook-3.0")
--
-- function MyAddon:OnEnable()
--   -- Hook the OnShow of FriendsFrame
--   self:RawHookScript(FriendsFrame, "OnShow", "FriendsFrameOnShow")
-- end
--
-- function MyAddon:FriendsFrameOnShow(frame)
--   -- Call the original function
--   self.hooks[frame].OnShow(frame)
--   -- Do our processing
--   -- .. stuff
-- end
function AceHook:RawHookScript(frame, script, handler)
	hook(self, frame, script, handler, true, false, true, false, "Usage: RawHookScript(object, method, [handler])")
end

--- SecureHook a script handler on a frame.
-- This function is a wrapper around the `frame:HookScript` function in the WoW API. Using AceHook
-- extends the functionality of secure hooks, and adds the ability to unhook once the hook isn't
-- required anymore, or the addon is being disabled.\\
-- Secure Hooks should be used if the secure-status of the function is vital to its function,
-- and taint would block execution. Secure Hooks are always called after the original function was called
-- ("Post Hook"), and you cannot modify the arguments, return values or control the execution.
-- @paramsig frame, script, [handler]
-- @param frame The Frame to hook the script on
-- @param script The script to hook
-- @param handler The handler for the hook, a funcref or a method name. (Defaults to the name of the hooked script)
function AceHook:SecureHookScript(frame, script, handler)
	hook(self, frame, script, handler, true, true, false, false, "Usage: SecureHookScript(object, method, [handler])")
end

--- Unhook from the specified function, method or script.
-- @paramsig [obj], method
-- @param obj The object or frame to unhook from
-- @param method The name of the method, function or script to unhook from.
function AceHook:Unhook(obj, method)
	local usage = "Usage: Unhook([obj], method)"
	if type(obj) == "string" then
		method, obj = obj, nil
	end

	if obj and type(obj) ~= "table" then
		error(format("%s: 'obj' - expecting nil or table got %s", usage, type(obj)), 2)
	end
	if type(method) ~= "string" then
		error(format("%s: 'method' - expeting string got %s", usage, type(method)), 2)
	end

	local uid
	if obj then
		uid = registry[self][obj] and registry[self][obj][method]
	else
		uid = registry[self][method]
	end

	if not uid or not actives[uid] then
		-- Declining to error on an unneeded unhook since the end effect is the same and this would just be annoying.
		return false
	end

	actives[uid], handlers[uid] = nil, nil

	if obj then
		local tmp = registry[self][obj]
		tmp[method] = nil
		if not next(tmp) then
			del(tmp)
			registry[self][obj] = nil
		end

		-- if the hook reference doesnt exist, then its a secure hook, just bail out and dont do any unhooking
		if not self.hooks[obj] or not self.hooks[obj][method] then return true end

		if scripts[uid] and obj:GetScript(method) == uid then  -- unhooks scripts
			obj:SetScript(method, self.hooks[obj][method] ~= donothing and self.hooks[obj][method] or nil)
			scripts[uid] = nil
		elseif obj and self.hooks[obj] and self.hooks[obj][method] and obj[method] == uid then -- unhooks methods
			obj[method] = self.hooks[obj][method]
		end

		tmp = self.hooks[obj]
		tmp[method] = nil
		if not next(tmp) then
			del(tmp)
			self.hooks[obj] = nil
		end
	else
		registry[self][method] = nil

		-- if self.hooks[method] doesn't exist, then this is a SecureHook, just bail out
		if not self.hooks[method] then return true end

		if self.hooks[method] and _G[method] == uid then -- unhooks functions
			_G[method] = self.hooks[method]
		end

		self.hooks[method] = nil
	end
	return true
end

--- Unhook all existing hooks for this addon.
function AceHook:UnhookAll()
	for key, value in pairs(registry[self]) do
		if type(key) == "table" then
			for method in pairs(value) do
				self:Unhook(key, method)
			end
		else
			self:Unhook(key)
		end
	end
end

--- Check if the specific function, method or script is already hooked.
-- @paramsig [obj], method
-- @param obj The object or frame to unhook from
-- @param method The name of the method, function or script to unhook from.
function AceHook:IsHooked(obj, method)
	-- we don't check if registry[self] exists, this is done by evil magicks in the metatable
	if type(obj) == "string" then
		if registry[self][obj] and actives[registry[self][obj]] then
			return true, handlers[registry[self][obj]]
		end
	else
		if registry[self][obj] and registry[self][obj][method] and actives[registry[self][obj][method]] then
			return true, handlers[registry[self][obj][method]]
		end
	end

	return false, nil
end

--- Upgrade our old embeded
for target, v in pairs( AceHook.embeded ) do
	AceHook:Embed( target )
end

================
File: Libs/vanilla/Ace3/AceHook-3.0/AceHook-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceHook-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceLocale-3.0/AceLocale-3.0.lua
================
--- **AceLocale-3.0** manages localization in addons, allowing for multiple locale to be registered with fallback to the base locale for untranslated strings.
-- @class file
-- @name AceLocale-3.0
-- @release $Id: AceLocale-3.0.lua 1035 2011-07-09 03:20:13Z kaelten $
local MAJOR,MINOR = "AceLocale-3.0", 6

local AceLocale, oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceLocale then return end -- no upgrade needed

-- Lua APIs
local assert, tostring, error = assert, tostring, error
local getmetatable, setmetatable, rawset, rawget = getmetatable, setmetatable, rawset, rawget

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: GAME_LOCALE, geterrorhandler

local gameLocale = GetLocale()
if gameLocale == "enGB" then
	gameLocale = "enUS"
end

AceLocale.apps = AceLocale.apps or {}          -- array of ["AppName"]=localetableref
AceLocale.appnames = AceLocale.appnames or {}  -- array of [localetableref]="AppName"

-- This metatable is used on all tables returned from GetLocale
local readmeta = {
	__index = function(self, key) -- requesting totally unknown entries: fire off a nonbreaking error and return key
		rawset(self, key, key)      -- only need to see the warning once, really
		geterrorhandler()(MAJOR..": "..tostring(AceLocale.appnames[self])..": Missing entry for '"..tostring(key).."'")
		return key
	end
}

-- This metatable is used on all tables returned from GetLocale if the silent flag is true, it does not issue a warning on unknown keys
local readmetasilent = {
	__index = function(self, key) -- requesting totally unknown entries: return key
		rawset(self, key, key)      -- only need to invoke this function once
		return key
	end
}

-- Remember the locale table being registered right now (it gets set by :NewLocale())
-- NOTE: Do never try to register 2 locale tables at once and mix their definition.
local registering

-- local assert false function
local assertfalse = function() assert(false) end

-- This metatable proxy is used when registering nondefault locales
local writeproxy = setmetatable({}, {
	__newindex = function(self, key, value)
		rawset(registering, key, value == true and key or value) -- assigning values: replace 'true' with key string
	end,
	__index = assertfalse
})

-- This metatable proxy is used when registering the default locale.
-- It refuses to overwrite existing values
-- Reason 1: Allows loading locales in any order
-- Reason 2: If 2 modules have the same string, but only the first one to be
--           loaded has a translation for the current locale, the translation
--           doesn't get overwritten.
--
local writedefaultproxy = setmetatable({}, {
	__newindex = function(self, key, value)
		if not rawget(registering, key) then
			rawset(registering, key, value == true and key or value)
		end
	end,
	__index = assertfalse
})

--- Register a new locale (or extend an existing one) for the specified application.
-- :NewLocale will return a table you can fill your locale into, or nil if the locale isn't needed for the players
-- game locale.
-- @paramsig application, locale[, isDefault[, silent]]
-- @param application Unique name of addon / module
-- @param locale Name of the locale to register, e.g. "enUS", "deDE", etc.
-- @param isDefault If this is the default locale being registered (your addon is written in this language, generally enUS)
-- @param silent If true, the locale will not issue warnings for missing keys. Must be set on the first locale registered. If set to "raw", nils will be returned for unknown keys (no metatable used).
-- @usage
-- -- enUS.lua
-- local L = LibStub("AceLocale-3.0"):NewLocale("TestLocale", "enUS", true)
-- L["string1"] = true
--
-- -- deDE.lua
-- local L = LibStub("AceLocale-3.0"):NewLocale("TestLocale", "deDE")
-- if not L then return end
-- L["string1"] = "Zeichenkette1"
-- @return Locale Table to add localizations to, or nil if the current locale is not required.
function AceLocale:NewLocale(application, locale, isDefault, silent)

	-- GAME_LOCALE allows translators to test translations of addons without having that wow client installed
	local gameLocale = GAME_LOCALE or gameLocale

	local app = AceLocale.apps[application]

	if silent and app and getmetatable(app) ~= readmetasilent then
		geterrorhandler()("Usage: NewLocale(application, locale[, isDefault[, silent]]): 'silent' must be specified for the first locale registered")
	end

	if not app then
		if silent=="raw" then
			app = {}
		else
			app = setmetatable({}, silent and readmetasilent or readmeta)
		end
		AceLocale.apps[application] = app
		AceLocale.appnames[app] = application
	end

	if locale ~= gameLocale and not isDefault then
		return nil	-- nop, we don't need these translations
	end

	registering = app -- remember globally for writeproxy and writedefaultproxy

	if isDefault then
		return writedefaultproxy
	end

	return writeproxy
end

--- Returns localizations for the current locale (or default locale if translations are missing).
-- Errors if nothing is registered (spank developer, not just a missing translation)
-- @param application Unique name of addon / module
-- @param silent If true, the locale is optional, silently return nil if it's not found (defaults to false, optional)
-- @return The locale table for the current language.
function AceLocale:GetLocale(application, silent)
	if not silent and not AceLocale.apps[application] then
		error("Usage: GetLocale(application[, silent]): 'application' - No locales registered for '"..tostring(application).."'", 2)
	end
	return AceLocale.apps[application]
end

================
File: Libs/vanilla/Ace3/AceLocale-3.0/AceLocale-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceLocale-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceLocale-3.1/AceLocale-3.1.lua
================
--- **AceLocale-3.1** manages localization in addons, allowing for multiple locale to be registered with fallback to the base locale for untranslated strings.  AceLocale-3.1 is experimental.
-- @class file
-- @name AceLocale-3.0
-- @release $Id: AceLocale-3.0.lua 1005 2011-01-29 14:19:43Z mikk $
local MAJOR, MINOR = "AceLocale-3.1", 1

local AceLocale, oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceLocale then return end -- no upgrade needed

-- Lua APIs
local assert, tostring, error = assert, tostring, error
local setmetatable, rawset, rawget = setmetatable, rawset, rawget

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: GAME_LOCALE, geterrorhandler

local gameLocale = GetLocale()
if gameLocale == "enGB" then
    gameLocale = "enUS"
end

AceLocale.apps = AceLocale.apps or {} -- array of ["AppName"]=localetableref
AceLocale.appnames = AceLocale.appnames or {} -- array of [localetableref]="AppName"
AceLocale.appmodes = AceLocale.appmodes or {}
AceLocale.applocales = AceLocale.applocales or {}

AceLocale.KEY_ON_MISSING = "KEY_ON_MISSING"
AceLocale.WARN_ON_MISSING = "WARN_ON_MISSING"
AceLocale.NIL_ON_MISSING = "NIL_ON_MISSING"

local read_metatables = {
    KEY_ON_MISSING = {
        -- returns the key for missing strings, no warning
        __index = function(self, key)
            rawset(self, key, key)
            return key
        end
    },
    WARN_ON_MISSING = {
        -- returns the key for missing strings, but gives a warning
        __index = function(self, key)
            rawset(self, key, key)
            geterrorhandler()(MAJOR .. ": " .. tostring(AceLocale.appnames[self]) .. ": Missing entry for '" .. tostring(key) .. "'")
            return key
        end
    },
    NIL_ON_MISSING = false -- this is here just so that the error checking in SetMode works properly
}

local registering_app
local write_metatables = {
    DEFAULT = setmetatable({}, {
        __newindex = function(self, key, value)
            if not rawget(registering_app, key) then
                rawset(registering_app, key, value == true and key or value)
            end
        end,
        __index = function() assert(false) end
    }),
    LOCALE = setmetatable({}, {
        __newindex = function(self, key, value)
            rawset(registering_app, key, value == true and key or value)
        end,
        __index = function() assert(false) end
    })
}

--- Override the results of GetLocale() for a specific application.
-- This must be called _before_ the first call to NewLocale for a given application.
-- @paramsig application, locale
-- @param application Unique name of the addon / module
-- @param locale Name of the locale to use
-- @usage
-- -- in this example we're wanting to test how the german looks in the addon
-- -- todo this we must call SetLocale before any NewLocale calls
-- local AceLocale = LibStub("AceLocale-3.1")
-- AceLocale:SetLocale("MyAddon", "deDE") -- testing how my addon looks in german
--
-- local L = AceLocale:NewLocale("MyAddon", "enUS", true)
-- L["string1"] = true
--
-- local L = AceLocale:NewLocale("MyAddon", "deDE")
-- L["string1"] = "Zeichenkette1"
--
-- local L = AceLocale:GetLocale("MyAddon")
-- local var = L["string1"] -- will always result in "Zeichenkette1" regardless of what game client locale you're running on
function AceLocale:SetLocale(application, locale)
    if self.apps[application] then
        error("Usage: GetLocale(application, locale): must be called before the first call to NewLocale.", 2)
    end

    self.applocales[application] = locale
end

--- Determines how AceLocale handles keys missing in the translation tables
-- Valid modes are:
-- * AceLocale.KEY_ON_MISSING - returns the key passed in
-- * AceLocale.WARN_ON_MISSING - issues a warning, and then returns the key passed in
-- * AceLocale.NIL_ON_MISSING - fails silently returning nil
-- @paramsig application, mode
-- @param application Unique name of the addon / module
-- @param mode The flag that sets how to handle the missing keys. The default is KEY_ON_MISSING
-- @usage
-- local AceLocale = LibStub("AceLocale-3.1")
--
-- local L = AceLocale:NewLocale("MyAddon", "enUS", true)
-- L["string1"] = true
--
-- local L = AceLocale:NewLocale("MyAddon", "deDE")
-- L["string1"] = "Zeichenkette1"
--
-- local L = AceLocale:GetLocale("MyAddon")
-- local var = L["string2"] -- will result in "string2"
--
-- AceLocale:SetMode("MyAddon", AceLocale.NIL_ON_MISSING)
-- local var = L["string2"] -- will result in in nil
function AceLocale:SetMode(application, mode)
    if not mode then
        mode = self.KEY_ON_MISSING
    end

    if read_metatables[mode] == nil then
        error("Usage: SetMode(application, mode): 'mode' - Invalid mode '" .. tostring(mode) .. "' used.", 2)
    end

    self.appmodes[application] = mode

    local app = self.apps[application]
    if app then
        setmetatable(app, read_metatables[mode] or nil) -- changes the false to a nil for NIL_ON_MISSING
    end
end

--- Register a new locale (or extend an existing one) for the specified application,
-- returns a table you can fill your locale into, or nil if the locale doesn't need to be loaded
-- @paramsig application, locale[, isDefault]
-- @param application Unique name of addon / module
-- @param locale Name of the locale to register, e.g. "enUS", "deDE", etc.
-- @param isDefault If this is the default locale being registered (your addon is written in this language, generally enUS).  This should only be passed in for _one_ locale.
-- @usage
-- -- enUS.lua
-- local L = LibStub("AceLocale-3.0"):NewLocale("MyAddon", "enUS", true)
-- L["string1"] = true
--
-- -- deDE.lua
-- local L = LibStub("AceLocale-3.0"):NewLocale("MyAddon", "deDE")
-- if not L then return end
-- L["string1"] = "Zeichenkette1"
-- @return Locale Table to add localizations to, or nil if the current locale is not needed.
function AceLocale:NewLocale(application, locale, isDefault)
    local app = AceLocale.apps[application]

    if not app then
        app = {}
        self.apps[application] = app
        self.appnames[app] = application
        self:SetMode(application, self.appmodes[application])
    end

    local targetLocale = self.applocales[application] or gameLocale

    if locale ~= targetLocale and not isDefault then
        return
    end

    registering_app = app
    return isDefault and write_metatables["DEFAULT"] or write_metatables["LOCALE"]
end

--- Returns localizations for the current locale (or default locale if translations are missing).
-- Errors if nothing is registered (spank developer, not just a missing translation)
-- @param application Unique name of addon / module
-- @param silent If true, the locale is optional, silently return nil if it's not found (defaults to false, optional)
-- @return The locale table for the current language.
function AceLocale:GetLocale(application, silent)
    if not silent and not AceLocale.apps[application] then
        error("Usage: GetLocale(application[, silent]): 'application' - No locales registered for '" .. tostring(application) .. "'", 2)
    end
    return AceLocale.apps[application]
end

================
File: Libs/vanilla/Ace3/AceLocale-3.1/AceLocale-3.1.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceLocale-3.1.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceSerializer-3.0/AceSerializer-3.0.lua
================
--- **AceSerializer-3.0** can serialize any variable (except functions or userdata) into a string format,
-- that can be send over the addon comm channel. AceSerializer was designed to keep all data intact, especially 
-- very large numbers or floating point numbers, and table structures. The only caveat currently is, that multiple
-- references to the same table will be send individually.
--
-- **AceSerializer-3.0** can be embeded into your addon, either explicitly by calling AceSerializer:Embed(MyAddon) or by 
-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
-- and can be accessed directly, without having to explicitly call AceSerializer itself.\\
-- It is recommended to embed AceSerializer, otherwise you'll have to specify a custom `self` on all calls you
-- make into AceSerializer.
-- @class file
-- @name AceSerializer-3.0
-- @release $Id: AceSerializer-3.0.lua 1135 2015-09-19 20:39:16Z nevcairiel $
local MAJOR,MINOR = "AceSerializer-3.0", 5
local AceSerializer, oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceSerializer then return end

-- Lua APIs
local strbyte, strchar, gsub, gfind, format = string.byte, string.char, string.gsub, string.gfind, string.format
local assert, error, pcall = assert, error, pcall
local type, tostring, tonumber = type, tostring, tonumber
local pairs, select, frexp = pairs, select, math.frexp
local tconcat, tgetn = table.concat, table.getn

-- quick copies of string representations of wonky numbers
local inf = 1/0

local serNaN  -- can't do this in 4.3, see ace3 ticket 268
local serInf, serInfMac = "1.#INF", "inf"
local serNegInf, serNegInfMac = "-1.#INF", "-inf"


-- Serialization functions

local function SerializeStringHelper(ch)	-- Used by SerializeValue for strings
	-- We use \126 ("~") as an escape character for all nonprints plus a few more
	local n = strbyte(ch)
	if n==30 then           -- v3 / ticket 115: catch a nonprint that ends up being "~^" when encoded... DOH
		return "\126\122"
	elseif n<=32 then 			-- nonprint + space
		return "\126"..strchar(n+64)
	elseif n==94 then		-- value separator 
		return "\126\125"
	elseif n==126 then		-- our own escape character
		return "\126\124"
	elseif n==127 then		-- nonprint (DEL)
		return "\126\123"
	else
		assert(false)	-- can't be reached if caller uses a sane regex
	end
end

local function SerializeValue(v, res, nres)
	-- We use "^" as a value separator, followed by one byte for type indicator
	local t=type(v)
	
	if t=="string" then		-- ^S = string (escaped to remove nonprints, "^"s, etc)
		res[nres+1] = "^S"
		res[nres+2] = gsub(v,"[%c \94\126\127]", SerializeStringHelper)
		nres=nres+2
	
	elseif t=="number" then	-- ^N = number (just tostring()ed) or ^F (float components)
		local str = tostring(v)
		if tonumber(str)==v  --[[not in 4.3 or str==serNaN]] then
			-- translates just fine, transmit as-is
			res[nres+1] = "^N"
			res[nres+2] = str
			nres=nres+2
		elseif v == inf or v == -inf then
			res[nres+1] = "^N"
			res[nres+2] = v == inf and serInf or serNegInf
			nres=nres+2
		else
			local m,e = frexp(v)
			res[nres+1] = "^F"
			res[nres+2] = format("%.0f",m*2^53)	-- force mantissa to become integer (it's originally 0.5--0.9999)
			res[nres+3] = "^f"
			res[nres+4] = tostring(e-53)	-- adjust exponent to counteract mantissa manipulation
			nres=nres+4
		end
	
	elseif t=="table" then	-- ^T...^t = table (list of key,value pairs)
		nres=nres+1
		res[nres] = "^T"
		for k,v in pairs(v) do
			nres = SerializeValue(k, res, nres)
			nres = SerializeValue(v, res, nres)
		end
		nres=nres+1
		res[nres] = "^t"
	
	elseif t=="boolean" then	-- ^B = true, ^b = false
		nres=nres+1
		if v then
			res[nres] = "^B"	-- true
		else
			res[nres] = "^b"	-- false
		end
	
	elseif t=="nil" then		-- ^Z = nil (zero, "N" was taken :P)
		nres=nres+1
		res[nres] = "^Z"
	
	else
		error(MAJOR..": Cannot serialize a value of type '"..t.."'")	-- can't produce error on right level, this is wildly recursive
	end
	
	return nres
end



local serializeTbl = { "^1" }	-- "^1" = Hi, I'm data serialized by AceSerializer protocol rev 1

--- Serialize the data passed into the function.
-- Takes a list of values (strings, numbers, booleans, nils, tables)
-- and returns it in serialized form (a string).\\
-- May throw errors on invalid data types.
-- @param ... List of values to serialize
-- @return The data in its serialized form (string)
function AceSerializer:Serialize(...)
	local nres = 1
	for i = 1,tgetn(arg) do
		local v = arg[i]
		nres = SerializeValue(v, serializeTbl, nres)
	end

	serializeTbl[nres+1] = "^^"	-- "^^" = End of serialized data
	
	return tconcat(serializeTbl, "", 1, nres+1)
end

-- Deserialization functions
local function DeserializeStringHelper(escape)
	if escape<"~\122" then
		return strchar(strbyte(escape,2,2)-64)
	elseif escape=="~\122" then	-- v3 / ticket 115: special case encode since 30+64=94 ("^") - OOPS.
		return "\030"
	elseif escape=="~\123" then
		return "\127"
	elseif escape=="~\124" then
		return "\126"
	elseif escape=="~\125" then
		return "\94"
	end
	error("DeserializeStringHelper got called for '"..escape.."'?!?")  -- can't be reached unless regex is screwed up
end

local function DeserializeNumberHelper(number)
	--[[ not in 4.3 if number == serNaN then
		return 0/0
	else]]if number == serNegInf or number == serNegInfMac then
		return -inf
	elseif number == serInf or number == serInfMac then
		return inf
	else
		return tonumber(number)
	end
end

-- DeserializeValue: worker function for :Deserialize()
-- It works in two modes:
--   Main (top-level) mode: Deserialize a list of values and return them all
--   Recursive (table) mode: Deserialize only a single value (_may_ of course be another table with lots of subvalues in it)
--
-- The function _always_ works recursively due to having to build a list of values to return
--
-- Callers are expected to pcall(DeserializeValue) to trap errors

local function DeserializeValue(iter,single,ctl,data)

	if not single then
		ctl,data = iter()
	end

	if not ctl then 
		error("Supplied data misses AceSerializer terminator ('^^')")
	end	

	if ctl=="^^" then
		-- ignore extraneous data
		return
	end

	local res
	
	if ctl=="^S" then
		res = gsub(data, "~.", DeserializeStringHelper)
	elseif ctl=="^N" then
		res = DeserializeNumberHelper(data)
		if not res then
			error("Invalid serialized number: '"..tostring(data).."'")
		end
	elseif ctl=="^F" then     -- ^F<mantissa>^f<exponent>
		local ctl2,e = iter()
		if ctl2~="^f" then
			error("Invalid serialized floating-point number, expected '^f', not '"..tostring(ctl2).."'")
		end
		local m=tonumber(data)
		e=tonumber(e)
		if not (m and e) then
			error("Invalid serialized floating-point number, expected mantissa and exponent, got '"..tostring(m).."' and '"..tostring(e).."'")
		end
		res = m*(2^e)
	elseif ctl=="^B" then	-- yeah yeah ignore data portion
		res = true
	elseif ctl=="^b" then   -- yeah yeah ignore data portion
		res = false
	elseif ctl=="^Z" then	-- yeah yeah ignore data portion
		res = nil
	elseif ctl=="^T" then
		-- ignore ^T's data, future extensibility?
		res = {}
		local k,v
		while true do
			ctl,data = iter()
			if ctl=="^t" then break end	-- ignore ^t's data
			k = DeserializeValue(iter,true,ctl,data)
			if k==nil then 
				error("Invalid AceSerializer table format (no table end marker)")
			end
			ctl,data = iter()
			v = DeserializeValue(iter,true,ctl,data)
			if v==nil then
				error("Invalid AceSerializer table format (no table end marker)")
			end
			res[k]=v
		end
	else
		error("Invalid AceSerializer control code '"..ctl.."'")
	end
	
	if not single then
		return res,DeserializeValue(iter)
	else
		return res
	end
end

--- Deserializes the data into its original values.
-- Accepts serialized data, ignoring all control characters and whitespace.
-- @param str The serialized data (from :Serialize)
-- @return true followed by a list of values, OR false followed by an error message
function AceSerializer:Deserialize(str)
	str = gsub(str, "[%c ]", "")	-- ignore all control characters; nice for embedding in email and stuff

	local iter = gfind(str, "(^.)([^^]*)")	-- Any ^x followed by string of non-^
	local ctl,data = iter()
	if not ctl or ctl~="^1" then
		-- we purposefully ignore the data portion of the start code, it can be used as an extension mechanism
		return false, "Supplied data is not AceSerializer data (rev 1)"
	end

	return pcall(DeserializeValue, iter)
end


----------------------------------------
-- Base library stuff
----------------------------------------

AceSerializer.internals = {	-- for test scripts
	SerializeValue = SerializeValue,
	SerializeStringHelper = SerializeStringHelper,
}

local mixins = {
	"Serialize",
	"Deserialize",
}

AceSerializer.embeds = AceSerializer.embeds or {}

function AceSerializer:Embed(target)
	for k, v in pairs(mixins) do
		target[v] = self[v]
	end
	self.embeds[target] = true
	return target
end

-- Update embeds
for target, v in pairs(AceSerializer.embeds) do
	AceSerializer:Embed(target)
end

================
File: Libs/vanilla/Ace3/AceSerializer-3.0/AceSerializer-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceSerializer-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceTab-3.0/AceTab-3.0.lua
================
--- AceTab-3.0 provides support for tab-completion.
-- Note: This library is not yet finalized.
-- @class file
-- @name AceTab-3.0
-- @release $Id: AceTab-3.0.lua 1148 2016-07-18 09:13:02Z nevcairiel $

local ACETAB_MAJOR, ACETAB_MINOR = 'AceTab-3.0', 9
local AceTab, oldminor = LibStub:NewLibrary(ACETAB_MAJOR, ACETAB_MINOR)

if not AceTab then return end -- No upgrade needed

local AceCore = LibStub("AceCore-3.0")
local new, del = AceCore.new, AceCore.del

AceTab.registry = AceTab.registry or {}

-- local upvalues
local _G = AceCore._G
local pairs = pairs
local ipairs = ipairs
local type = type
local registry = AceTab.registry
local tgetn = table.getn

local strfind = string.find
local strsub = string.sub
local strlower = string.lower
local strformat = string.format
local strlen = string.len

local function getCursorPosition(this)
	local ost = this:GetScript("OnTextSet")
	if type(ost) ~= "function" then ost = nil end
	if ost then this:SetScript("OnTextSet", nil) end
	-- insert a special character
	this:Insert("\255")
	-- find the inserted position
	local pos = strfind(this:GetText(),"\255")-1
	-- highlight the inserted character (like select this character in notepad)
	this:HighlightText(pos,pos+1)
	-- insert a null character will erase the inserted special character
	this:Insert("\0")
	if ost then this:SetScript("OnTextSet", ost) end
	return pos
end

local function getTextBeforeCursor(this, start)
	return strsub(this:GetText(), start or 1, getCursorPosition(this))
end

-- Hook OnTabPressed and OnTextChanged for the frame, give it an empty matches table, and set its curMatch to 0, if we haven't done so already.
local function hookFrame(f)
	if f.hookedByAceTab3 then return end
	f.hookedByAceTab3 = true
	local origOTP = f:GetScript('OnTabPressed')
	if type(origOTP) ~= 'function' then
		origOTP = function() end
	end
	f:SetScript('OnTabPressed', function()
		-- Ace3v: tested no arguments given
		if AceTab:OnTabPressed(f) then
			return origOTP()
		end
	end)
	f.at3curMatch = 0
	f.at3matches = new()
end

local firstPMLength

local fallbacks, notfallbacks = {}, {}  -- classifies completions into those which have preconditions and those which do not.  Those without preconditions are only considered if no other completions have matches.
local pmolengths = {}  -- holds the number of characters to overwrite according to pmoverwrite and the current prematch
-- ------------------------------------------------------------------------------
-- RegisterTabCompletion( descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite )
-- See http://www.wowace.com/wiki/AceTab-2.0 for detailed API documentation
--
-- descriptor	string					Unique identifier for this tab completion set
--
-- prematches	string|table|nil		String match(es) AFTER which this tab completion will apply.
--										AceTab will ignore tabs NOT preceded by the string(s).
--										If no value is passed, will check all tabs pressed in the specified editframe(s) UNLESS a more-specific tab complete applies.
--
-- wordlist		function|table			Function that will be passed a table into which it will insert strings corresponding to all possible completions, or an equivalent table.
--										The text in the editbox, the position of the start of the word to be completed, and the uncompleted partial word
--										are passed as second, third, and fourth arguments, to facilitate pre-filtering or conditional formatting, if desired.
--
-- usagefunc	function|boolean|nil	Usage statement function.  Defaults to the wordlist, one per line.  A boolean true squelches usage output.
--
-- listenframes	string|table|nil		EditFrames to monitor.  Defaults to ChatFrameEditBox.
--
-- postfunc		function|nil			Post-processing function.  If supplied, matches will be passed through this function after they've been identified as a match.
--
-- pmoverwrite	boolean|number|nil		Offset the beginning of the completion string in the editbox when making a completion.  Passing a boolean true indicates that we want to overwrite
--										the entire prematch string, and passing a number will overwrite that many characters prior to the cursor.
--										This is useful when you want to use the prematch as an indicator character, but ultimately do not want it as part of the text, itself.
--
-- no return
-- ------------------------------------------------------------------------------
function AceTab:RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite)
	-- Arg checks
	if type(descriptor) ~= 'string' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'descriptor' - string expected.", 3) end
	if prematches and type(prematches) ~= 'string' and type(prematches) ~= 'table' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'prematches' - string, table, or nil expected.", 3) end
	if type(wordlist) ~= 'function' and type(wordlist) ~= 'table' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'wordlist' - function or table expected.", 3) end
	if usagefunc and type(usagefunc) ~= 'function' and type(usagefunc) ~= 'boolean' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'usagefunc' - function or boolean expected.", 3) end
	if listenframes and type(listenframes) ~= 'string' and type(listenframes) ~= 'table' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'listenframes' - string or table expected.", 3) end
	if postfunc and type(postfunc) ~= 'function' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'postfunc' - function expected.", 3) end
	if pmoverwrite and type(pmoverwrite) ~= 'boolean' and type(pmoverwrite) ~= 'number' then error("Usage: RegisterTabCompletion(descriptor, prematches, wordlist, usagefunc, listenframes, postfunc, pmoverwrite): 'pmoverwrite' - boolean or number expected.", 3) end

	local pmtable

	if type(prematches) == 'table' then
		pmtable = prematches
		notfallbacks[descriptor] = true
	else
		pmtable = new()
		-- Mark this group as a fallback group if no value was passed.
		if not prematches then
			pmtable[1] = ""
			fallbacks[descriptor] = true
		-- Make prematches into a one-element table if it was passed as a string.
		elseif type(prematches) == 'string' then
			pmtable[1] = prematches
			if prematches == "" then
				fallbacks[descriptor] = true
			else
				notfallbacks[descriptor] = true
			end
		end
	end

	-- Make listenframes into a one-element table if it was not passed a table of frames.
	if not listenframes then  -- default
		listenframes = { _G["ChatFrameEditBox"] } -- Ace3v: in vanilla we have only this one
	elseif type(listenframes) ~= 'table' or type(listenframes[0]) == 'userdata' and type(listenframes.IsObjectType) == 'function' then  -- single frame or framename
		listenframes = { listenframes }
	end

	-- Hook each registered listenframe and give it a matches table.
	for _, f in pairs(listenframes) do
		if type(f) == 'string' then
			f = _G[f]
		end
		if type(f) ~= 'table' or type(f[0]) ~= 'userdata' or type(f.IsObjectType) ~= 'function' then
			error(format(ACETAB_MAJOR..": Cannot register frame %q; it does not exist", f:GetName()))
		end
		if f then
			if f:GetObjectType() ~= 'EditBox' then
				error(format(ACETAB_MAJOR..": Cannot register frame %q; it is not an EditBox", f:GetName()))
			else
				hookFrame(f)
			end
		end
	end

	-- Everything checks out; register this completion.
	if not registry[descriptor] then
		local tmp = new()
		tmp.prematches = pmtable
		tmp.wordlist = wordlist
		tmp.usagefunc = usagefunc
		tmp.listenframes = listenframes
		tmp.postfunc = postfunc
		tmp.pmoverwrite = pmoverwrite
		registry[descriptor] = tmp
	end
end

function AceTab:IsTabCompletionRegistered(descriptor)
	return registry and registry[descriptor]
end

function AceTab:UnregisterTabCompletion(descriptor)
	local tmp = registry[descriptor]
	if tmp then
		del(tmp.prematches)
		del(tmp)
	end
	registry[descriptor] = nil
	pmolengths[descriptor] = nil	-- number values
	fallbacks[descriptor] = nil		-- bool values
	notfallbacks[descriptor] = nil	-- bool values
end

-- ------------------------------------------------------------------------------
-- gcbs( s1, s2 )
--
-- s1		string		First string to be compared
--
-- s2		string		Second string to be compared
--
-- returns the greatest common substring beginning s1 and s2
-- ------------------------------------------------------------------------------
local function gcbs(s1, s2)
	if not s1 and not s2 then return end
	if not s1 then s1 = s2 end
	if not s2 then s2 = s1 end
	if strlen(s2) < strlen(s1) then
		s1, s2 = s2, s1
	end
	if strfind(strlower(s2), "^"..strlower(s1)) then
		return s1
	else
		return gcbs(strsub(s1, 1, -2), s2)
	end
end

local cursor  -- Holds cursor position.  Set in :OnTabPressed().
-- ------------------------------------------------------------------------------
-- cycleTab()
-- For when a tab press has multiple possible completions, we need to allow the user to press tab repeatedly to cycle through them.
-- If we have multiple possible completions, all tab presses after the first will call this function to cycle through and insert the different possible matches.
-- This function will stop being called after OnTextChanged() is triggered by something other than AceTab (i.e. the user inputs a character).
-- ------------------------------------------------------------------------------
local previousLength, cMatch, matched, postmatch
local function cycleTab(this)
	cMatch = 0  -- Counter across all sets.  The pseudo-index relevant to this value and corresponding to the current match is held in this.at3curMatch
	matched = false

	-- Check each completion group registered to this frame.
	for desc, compgrp in pairs(this.at3matches) do

		-- Loop through the valid completions for this set.
		for m, pm in pairs(compgrp) do
			cMatch = cMatch + 1
			if cMatch == this.at3curMatch then  -- we're back to where we left off last time through the combined list
				this.at3lastMatch = m
				this.at3lastWord = pm
				this.at3curMatch = cMatch + 1 -- save the new cMatch index
				matched = true
				break
			end
		end
		if matched then break end
	end

	-- If our index is beyond the end of the list, reset the original uncompleted substring and let the cycle start over next time tab is pressed.
	if not matched then
		this.at3lastMatch = this.at3origMatch
		this.at3lastWord = this.at3origWord
		this.at3curMatch = 1
	end

	-- Insert the completion.
	this:HighlightText(this.at3matchStart-1, cursor)
	this:Insert(this.at3lastWord or '')
	this.at3_last_precursor = getTextBeforeCursor(this) or ''
end

local IsSecureCmd = IsSecureCmd

local cands, candUsage = {}, {}
local numMatches = 0
local firstMatch, hasNonFallback, allGCBS, setGCBS, usage
local text_precursor, text_all, text_pmendToCursor
local matches, usagefunc  -- convenience locals

-- Fill the this.at3matches[descriptor] tables with matching completion pairs for each entry, based on
-- the partial string preceding the cursor position and using the corresponding registered wordlist.
--
-- The entries of the matches tables are of the format raw_match = formatted_match, where raw_match is the plaintext completion and
-- formatted_match is the match after being formatted/altered/processed by the registered postfunc.
-- If no postfunc exists, then the formatted and raw matches are the same.
local pms, pme, prematchStart, prematchEnd, text_prematch, entry
local function fillMatches(this, desc, fallback)
	entry = registry[desc]
	-- See what frames are registered for this completion group.  If the frame in which we pressed tab is one of them, then we start building matches.
	for _, f in ipairs(entry.listenframes) do
		if f == this then
			-- Try each precondition string registered for this completion group.
			for _, prematch in ipairs(entry.prematches) do
				-- Test if our prematch string is satisfied.
				-- If it is, then we find its last occurence prior to the cursor, calculate and store its pmoverwrite value (if applicable), and start considering completions.
				if fallback then prematch = "%s" end

				-- Find the last occurence of the prematch before the cursor.
				pms, pme = nil, 1
				text_prematch, prematchEnd, prematchStart = nil, nil, nil
				while true do
					pms, pme = strfind(text_precursor, prematch, pme)
					if pms then
						prematchStart, prematchEnd, text_prematch = pms, pme, strsub(text_precursor,pms,pme)
						pme = pme + 1
					else
						break
					end
				end

				if not prematchStart and fallback then
					prematchStart, prematchEnd, text_prematch = 0, 0, ''
				end
				if prematchStart then
					-- text_pmendToCursor should be the sub-word/phrase to be completed.
					text_pmendToCursor = strsub(text_precursor, prematchEnd + 1)

					-- How many characters should we eliminate before the completion before writing it in.
					pmolengths[desc] = entry.pmoverwrite == true and tgetn(text_prematch) or entry.pmoverwrite or 0

					-- This is where we will insert completions, taking the prematch overwrite into account.
					this.at3matchStart = prematchEnd + 1 - (pmolengths[desc] or 0)

					-- We're either a non-fallback set or all completions thus far have been fallback sets, and the precondition matches.
					-- Create cands from the registered wordlist, filling it with all potential (unfiltered) completion strings.
					local wordlist = entry.wordlist
					local cands = type(wordlist) == 'table' and wordlist or false
					if type(wordlist) == 'function' then
						cands = new()
						wordlist(cands, text_all, prematchEnd + 1, text_pmendToCursor)
					end
					if cands ~= false then
						matches = this.at3matches[desc] or new()
						for i in pairs(matches) do matches[i] = nil end

						-- Check each of the entries in cands to see if it completes the word before the cursor.
						-- Finally, increment our match count and set firstMatch, if appropriate.
						for _, m in ipairs(cands) do
							if strfind(strlower(m), strlower(text_pmendToCursor), 1, 1) == 1 then  -- we have a matching completion!
								hasNonFallback = hasNonFallback or (not fallback)
								matches[m] = entry.postfunc and entry.postfunc(m, prematchEnd + 1, text_all) or m
								numMatches = numMatches + 1
								if numMatches == 1 then
									firstMatch = matches[m]
									firstPMLength = pmolengths[desc] or 0
								end
							end
						end
						if numMatches > 0 then
							this.at3matches[desc] = matches
						else
							del(matches)
							this.at3matches[desc] = nil
						end
					end
					if type(wordlist) == 'function' then
						del(cands)
					end
				end
			end
		end
	end
end

function AceTab:OnTabPressed(this)

	if this:GetText() == '' then return true end

	if this == ChatFrameEditBox	then
		local command = this:GetText()
		if strfind(command, "^/[%a%d_]+$") then
			return true
		end
	end

	cursor = getCursorPosition(this)

	text_all = this:GetText()
	text_precursor = getTextBeforeCursor(this) or ''

	-- If we've already found some matches and haven't done anything since the last tab press, then (continue) cycling matches.
	-- Otherwise, reset this frame's matches and proceed to creating our list of possible completions.
	this.at3lastMatch = this.at3curMatch > 0 and (this.at3lastMatch or this.at3origWord)
	-- Detects if we've made any edits since the last tab press.  If not, continue cycling completions.
	if text_precursor == this.at3_last_precursor then
		return cycleTab(this)
	else
		for i in pairs(this.at3matches) do this.at3matches[i] = nil end
		this.at3curMatch = 0
		this.at3origWord = nil
		this.at3origMatch = nil
		this.at3lastWord = nil
		this.at3lastMatch = nil
		this.at3_last_precursor = text_precursor
	end

	numMatches = 0
	firstMatch = nil
	firstPMLength = 0
	hasNonFallback = false
	for i in pairs(pmolengths) do pmolengths[i] = nil end

	for desc in pairs(notfallbacks) do
		fillMatches(this, desc)
	end
	if not hasNonFallback then
		for desc in pairs(fallbacks) do
			fillMatches(this, desc, true)
		end
	end

	if not firstMatch then
		this.at3_last_precursor = "\0"
		return true
	end

	-- We want to replace the entire word with our completion, so highlight it up to the cursor.
	-- If only one match exists, then stick it in there and append a space.
	if numMatches == 1 then
		-- HighlightText takes the value AFTER which the highlighting starts, so we have to subtract 1 to have it start before the first character.
		this:HighlightText(this.at3matchStart-1, cursor)

		this:Insert(firstMatch)
		this:Insert(" ")
	else
		-- Otherwise, we want to begin cycling through the valid completions.
		-- Beginning a cycle also causes the usage statement to be printed, if one exists.

		-- Print usage statements for each possible completion (and gather up the GCBS of all matches while we're walking the tables).
		allGCBS = nil
		for desc, matches in pairs(this.at3matches) do
			-- Don't print usage statements for fallback completion groups if we have 'real' completion groups with matches.
			if hasNonFallback and fallbacks[desc] then break end

			-- Use the group's description as a heading for its usage statements.
			if usagefunc ~= true then
				DEFAULT_CHAT_FRAME:AddMessage(desc..":")
			end

			usagefunc = registry[desc].usagefunc
			if not usagefunc then
				-- No special usage processing; just print a list of the (formatted) matches.
				for m, fm in pairs(matches) do
					DEFAULT_CHAT_FRAME:AddMessage(fm)
					allGCBS = gcbs(allGCBS, m)
				end
			else
				-- Print a usage statement based on the corresponding registered usagefunc.
				-- candUsage is the table passed to usagefunc to be filled with candidate = usage_statement pairs.
				if type(usagefunc) == 'function' then
					for i in pairs(candUsage) do candUsage[i] = nil end

					-- usagefunc takes the greatest common substring of valid matches as one of its args, so let's find that now.
					-- TODO: Make the GCBS function accept a vararg or table, after which we can just pass in the list of matches.
					setGCBS = nil
					for m in pairs(matches) do
						setGCBS = gcbs(setGCBS, m)
					end
					allGCBS = gcbs(allGCBS, setGCBS)
					usage = usagefunc(candUsage, matches, setGCBS, strsub(text_precursor, 1, prematchEnd))

					-- If the usagefunc returns a string, then the entire usage statement has been taken care of by usagefunc, and we need only to print it...
					if type(usage) == 'string' then
						DEFAULT_CHAT_FRAME:AddMessage(usage)

					-- ...otherwise, it should have filled candUsage with candidate-usage statement pairs, and we need to print the matching ones.
					elseif next(candUsage) and numMatches > 0 then
						for m, fm in pairs(matches) do
							if candUsage[m] then DEFAULT_CHAT_FRAME:AddMessage(strformat("%s - %s", fm, candUsage[m])) end
						end
					end
				end
			end

			if next(matches) then
				-- Replace the original string with the greatest common substring of all valid completions.
				this.at3curMatch = 1
				this.at3origWord = strsub(text_precursor, this.at3matchStart, this.at3matchStart + pmolengths[desc] - 1) .. (allGCBS or "")
				this.at3origMatch = allGCBS or ""
				this.at3lastWord = this.at3origWord
				this.at3lastMatch = this.at3origMatch

				this:HighlightText(this.at3matchStart-1, cursor)
				this:Insert(this.at3origWord)
				this.at3_last_precursor = getTextBeforeCursor(this) or ''
			end
		end
	end
end

================
File: Libs/vanilla/Ace3/AceTab-3.0/AceTab-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceTab-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/AceTimer-3.0/AceTimer-3.0.lua
================
--- **AceTimer-3.0** provides a central facility for registering timers.
-- AceTimer supports one-shot timers and repeating timers. All timers are stored in an efficient
-- data structure that allows easy dispatching and fast rescheduling. Timers can be registered
-- or canceled at any time, even from within a running timer, without conflict or large overhead.\\
-- AceTimer is currently limited to firing timers at a frequency of 0.01s as this is what the WoW timer API
-- restricts us to.
--
-- All `:Schedule` functions will return a handle to the current timer, which you will need to store if you
-- need to cancel the timer you just registered.
--
-- **AceTimer-3.0** can be embeded into your addon, either explicitly by calling AceTimer:Embed(MyAddon) or by
-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
-- and can be accessed directly, without having to explicitly call AceTimer itself.\\
-- It is recommended to embed AceTimer, otherwise you'll have to specify a custom `self` on all calls you
-- make into AceTimer.
-- @class file
-- @name AceTimer-3.0
-- @release $Id: AceTimer-3.0.lua 1119 2014-10-14 17:23:29Z nevcairiel $

local MAJOR, MINOR = "AceTimer-3.0", 18 -- Bump minor on changes
local AceTimer, oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceTimer then return end -- No upgrade needed

local AceCore = LibStub("AceCore-3.0")
local safecall = AceCore.safecall

AceTimer.counter = AceTimer.counter or {}
AceTimer.hash = AceTimer.hash or {}	-- Array of [1..BUCKETS] = linked list of timers (using .next member)
AceTimer.activeTimers = AceTimer.activeTimers or {} -- Active timer list
AceTimer.frame = AceTimer.frame or CreateFrame("Frame", "AceTimer30Frame")

local counter = AceTimer.counter
local activeTimers = AceTimer.activeTimers -- Upvalue our private data
local timerFrame = AceTimer.frame

-- Lua APIs
local type, unpack, next, error = type, unpack, next, error
local floor, max, min, mod = math.floor, math.max, math.min, math.mod
local tostring = tostring

-- WoW APIs
local GetTime = GetTime

--[[
	Timers will not be fired more often than HZ-1 times per second.
	Keep at intended speed PLUS ONE or we get bitten by floating point rounding errors (n.5 + 0.1 can be n.599999)
	If this is ever LOWERED, all existing timers need to be enforced to have a delay >= 1/HZ on lib upgrade.
	If this number is ever changed, all entries need to be rehashed on lib upgrade.
	]]
local HZ = 11
local minDelay = 1/(HZ-1)

--[[
	Prime for good distribution
	If this number is ever changed, all entries need to be rehashed on lib upgrade.
]]
local BUCKETS = 131

local hash = AceTimer.hash
for i=1,BUCKETS do
	hash[i] = hash[i] or false	-- make it an integer-indexed array; it's faster than hashes
end

local new, del
do
local list = setmetatable({}, {__mode = "k"})
function new(self, loop, func, delay, argc,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	local name = loop and "ScheduleRepeatingTimer" or "ScheduleTimer"
	if self == AceTimer then
		error(MAJOR..": " .. name .. "(callback, delay, argc, args...): use your own 'self'", 3)
	end
	if not func or not delay then
		error(MAJOR..": " .. name .. "(callback, delay, argc, args...): 'callback' and 'delay' must have set values.", 3)
	end
	if argc and (type(argc) ~= "number" or floor(argc) ~= argc) then
		error(MAJOR..": " .. name .. "(callback, delay, argc, args...): 'argc' must be an integer.", 3)
	end
	if type(func) == "string" then
		if type(self) ~= "table" then
			error(MAJOR..": " .. name .. "(callback, delay, argc, args...): 'self' - must be a table.", 3)
		elseif type(self[func]) ~= "function" then
			error(MAJOR..": " .. name .. "(callback, delay, argc, args...): Tried to register '"..func.."' as the callback, but it is not a method.", 3)
		end
	elseif type(func) ~= "function" then
		error(MAJOR..": " .. name .. "(callback, delay, argc, args...): Tried to register '"..tostring(func).."' as the callback, but it is not a function.", 3)
	end

	if delay < minDelay then
		delay = minDelay
	end

	-- Create and stuff timer in the correct hash bucket
	local now = GetTime()

	local timer = next(list) or {}
	list[timer] = nil

	timer.object = self
	timer.func = func
	timer.delay = delay
	timer.status = loop and "loop" or "once"
	timer.ends = now + delay
	timer.argsCount = argc or 0
	timer[1] = a1
	timer[2] = a2
	timer[3] = a3
	timer[4] = a4
	timer[5] = a5
	timer[6] = a6
	timer[7] = a7
	timer[8] = a8
	timer[9] = a9
	timer[10] = a10

	local bucket = floor(mod((now+delay)*HZ,BUCKETS)) + 1
	timer.next = hash[bucket]
	hash[bucket] = timer

	local id = tostring(timer)	-- user has only access to the id but not the table itself
	activeTimers[id] = timer

	counter[self] = (counter[self] or 0) + 1

	timerFrame:Show()
	return id
end

function del(t)
	local id = tostring(t)
	activeTimers[id] = nil
	if not next(activeTimers) then
		timerFrame:Hide()
	end
	local self = t.object
	for k in pairs(t) do t[k] = nil end
	list[t] = true
	if counter[self] then
		counter[self] = counter[self] - 1
	else
		counter[self] = nil
	end
end
end	-- new, del

--- Schedule a new one-shot timer.
-- The timer will fire once in `delay` seconds, unless canceled before.
-- @param callback Callback function for the timer pulse (funcref or method name).
-- @param delay Delay for the timer, in seconds.
-- @param argc The numbers of arguments to be passed to the callback function
-- @param a1,...,a10 The arguments
-- @usage
-- MyAddOn = LibStub("AceAddon-3.0"):NewAddon("MyAddOn", "AceTimer-3.0")
--
-- function MyAddOn:OnEnable()
--   self:ScheduleTimer("TimerFeedback", 5)
-- end
--
-- function MyAddOn:TimerFeedback()
--   print("5 seconds passed")
-- end
function AceTimer:ScheduleTimer(func, delay, argc,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	return new(self, nil, func, delay, argc,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
end

--- Schedule a repeating timer.
-- The timer will fire every `delay` seconds, until canceled.
-- @param callback Callback function for the timer pulse (funcref or method name).
-- @param delay Delay for the timer, in seconds.
-- @param argc The numbers of arguments to be passed to the callback function
-- @param a1,...,a10 The arguments
-- @usage
-- MyAddOn = LibStub("AceAddon-3.0"):NewAddon("MyAddOn", "AceTimer-3.0")
--
-- function MyAddOn:OnEnable()
--   self.timerCount = 0
--   self.testTimer = self:ScheduleRepeatingTimer("TimerFeedback", 5)
-- end
--
-- function MyAddOn:TimerFeedback()
--   self.timerCount = self.timerCount + 1
--   print(("%d seconds passed"):format(5 * self.timerCount))
--   -- run 30 seconds in total
--   if self.timerCount == 6 then
--     self:CancelTimer(self.testTimer)
--   end
-- end
function AceTimer:ScheduleRepeatingTimer(func, delay, argc,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	return new(self, true, func, delay, argc,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
end

--- Cancels a timer with the given id, registered by the same addon object as used for `:ScheduleTimer`
-- Both one-shot and repeating timers can be canceled with this function, as long as the `id` is valid
-- and the timer has not fired yet or was canceled before.
-- @param id The id of the timer, as returned by `:ScheduleTimer` or `:ScheduleRepeatingTimer`
function AceTimer:CancelTimer(id)
	local timer = activeTimers[id]

	if not timer then
		return false
	else
		-- Ace3v: the timer will always be collected in the next update but not here
		-- this is necessary for AceBucket to determinate if the bucket has been unregistered
		-- in the callback
		timer.status = nil
		activeTimers[id] = nil
		return true
	end
end

--- Cancels all timers registered to the current addon object ('self')
function AceTimer:CancelAllTimers()
	if type(self) ~= "table" then
		error(MAJOR..": CancelAllTimers(): 'self' - must be a table",2)
	end
	if self == AceTimer then
		error(MAJOR..": CancelAllTimers(): supply a meaningful 'self'", 2)
	end

	for k,v in pairs(activeTimers) do
		if v.object == self then
			AceTimer.CancelTimer(self, k)
		end
	end
end

--- Returns the time left for a timer with the given id, registered by the current addon object ('self').
-- This function will return 0 when the id is invalid.
-- @param id The id of the timer, as returned by `:ScheduleTimer` or `:ScheduleRepeatingTimer`
-- @return The time left on the timer.
function AceTimer:TimeLeft(id)
	local timer = activeTimers[id]
	if not timer then
		return 0
	else
		return timer.ends - GetTime()
	end
end

function AceTimer:TimerStatus(id)
	local timer = activeTimers[id]
	if not timer then
		return nil
	else
		return timer.status
	end
end

-- ---------------------------------------------------------------------
-- Embed handling

AceTimer.embeds = AceTimer.embeds or {}

local mixins = {
	"ScheduleTimer", "ScheduleRepeatingTimer",
	"CancelTimer", "CancelAllTimers",
	"TimeLeft", "TimerStatus"
}

function AceTimer:Embed(target)
	AceTimer.embeds[target] = true
	for _,v in pairs(mixins) do
		target[v] = AceTimer[v]
	end
	return target
end

-- AceTimer:OnEmbedDisable(target)
-- target (object) - target object that AceTimer is embedded in.
--
-- cancel all timers registered for the object
function AceTimer:OnEmbedDisable(target)
	target:CancelAllTimers()
end

for addon in pairs(AceTimer.embeds) do
	AceTimer:Embed(addon)
end

-- --------------------------------------------------------------------
-- OnUpdate handler
--
-- traverse buckets, always chasing "now", and fire timers that have expired
local lastint = floor(GetTime() * HZ)
local function OnUpdate()
	local now = GetTime()
	local nowint = floor(now * HZ)

	-- Have we passed into a new hash bucket?
	if nowint == lastint then return end

	local soon = now + 1	-- +1 is safe as long as 1 < HZ < BUCKETS/2

	-- Pass through each bucket at most once
	-- Happens on e.g. instance loads, but COULD happen on high local load situations also
	for curint = (max(lastint, nowint-BUCKETS) + 1), nowint do	-- loop until we catch up with "now", usually only 1 iteratio
		local curbucket = mod(curint,BUCKETS) + 1	-- Ace3v: both int so no floor here
		-- Yank the list of timers out of the bucket and empty it. This allows reinsertion in the currently-processed bucket from callbacks.
		local nexttimer = hash[curbucket]
		hash[curbucket] = false	-- false rather than nil to prevent the array from becoming a hash

		while nexttimer do
			local timer = nexttimer
			nexttimer = timer.next
			local status = timer.status
			if not status then
				del(timer)
			else
				local ends = timer.ends
				if (status == "loop" or status == "once") and ends < soon then
					local object = timer.object
					local callback = timer.func
					if type(callback) == "string" then
						callback = (type(object) == "table") and object[callback]
						if type(callback) == "function" then
							safecall(callback, timer.argsCount+1, object,
								timer[1], timer[2], timer[3], timer[4], timer[5],
								timer[6], timer[7], timer[8], timer[9], timer[10])
						else
							status = "once"
						end
					elseif type(callback) == "function" then
						safecall(callback, timer.argsCount,
							timer[1], timer[2], timer[3], timer[4], timer[5],
							timer[6], timer[7], timer[8], timer[9], timer[10])
					else
						-- probably nilled out by CancelTimer
						status = "once"	-- don't reschedule it
					end

					if status == "once" then
						del(timer)
					else
						local delay = timer.delay
						local newends = ends + delay
						if newends < now then	-- Keep lag from making us firing a timer unnecessarily. (Note that this still won't catch too-short-delay timers though.)
							newends = now + delay
						end
						timer.ends = newends
						-- add next timer execution to the correct bucket
						local bucket = floor(mod(newends*HZ,BUCKETS)) + 1
						timer.next = hash[bucket]
						hash[bucket] = timer
					end
				else
					-- reinsert (yeah, somewhat expensive, but shouldn't be happening too often either due to hash distribution)
					timer.next = hash[curbucket]
					hash[curbucket] = timer
				end
			end
		end
	end

	lastint = nowint
end

local lastchecked = nil
local function OnEvent()
	if event ~= "PLAYER_REGEN_ENABLED" then return end

	local addon = next(counter, lastchecked)
	if not addon then
		addon = next(counter)
	end
	lastchecked = addon
	if not addon then	-- should only happen if counter is empty
		return
	end

	local n = counter[addon]
	if n > BUCKETS then
		DEFAULT_CHAT_FRAME:AddMessage(MAJOR..": Warning: The addon/module '"..tostring(addon).."' has "..tostring(n).." live timers. Surely that's not intended?")
	end
end

timerFrame:SetScript("OnUpdate", OnUpdate)
timerFrame:SetScript("OnEvent", OnEvent)
timerFrame:RegisterEvent("PLAYER_REGEN_ENABLED")
timerFrame:Hide()

================
File: Libs/vanilla/Ace3/AceTimer-3.0/AceTimer-3.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="AceTimer-3.0.lua"/>
</Ui>

================
File: Libs/vanilla/Ace3/Bindings.xml
================
<Bindings>
	<Binding name="RELOADUI" description="Reloads the UI." header="ACE3" category="ADDONS">
		ReloadUI()
	</Binding>
</Bindings>

================
File: Libs/vanilla/Ace3/changelog.txt
================
Ace3 Release - Revision r1151 (July 18th, 2016)
-----------------------------------------------
- AceConfig-3.0: Allow specifying images using the numeric fileID (Ticket #389)
- AceGUI-3.0: Use SetColorTexture in WoW 7.0
- AceGUI-3.0: Expose the HighlightText API for EditBox and MultiLineEditBox Widgets (Ticket #378)
- AceGUI-3.0: Keybinding: Support MouseWheel Up/Down bindings (Ticket #372)
- AceGUI-3.0: TreeGroup: Refresh the tree in an OnUpdate once after Acquire, not only after creation (Fixes missing tree in WoW 7.0)
- AceSerializer-3.0: Create consistent tokens for infinity, independent of the clients platform

Ace3 Release - Revision r1134 (June 23rd, 2015)
-----------------------------------------------
- AceGUI-3.0: TreeGroup: Prevent Word Wrap in tree elements

Ace3 Release - Revision r1128 (February 24th, 2015)
---------------------------------------------------
- AceGUI-3.0: Fixed an error in GameTooltip handling causing wrong formatting in some cases

Ace3 Release - Revision r1122 (October 14th, 2014)
--------------------------------------------------
- AceDB-3.0: Now using the GetCurrentRegion() API to determine region-based profile keys (fix for WoW 6.0)
- AceComm-3.0: Update ChatThrottleLib to v23
- AceConfigDialog-3.0: Show a more meaningful title on Blizzard Options Groups (Ticket #353)
- AceGUI-3.0: ColorPicker: Frame Level is automatically increased to ensure the color picker frame is above the option panel
- AceGUI-3.0: DropDown: Properly disable all clickable areas when the dropdown is disabled (Ticket #360)
- AceHook-3.0: Always use HookScript when hooking scripts in a secure fashion (Ticket #338)
- AceTimer-3.0: New timer implementation based on C_Timer.After

Ace3 Release - Revision r1109 (February 19th, 2014)
---------------------------------------------------
- AceComm-3.0: Ambiguate addon comm messages to restore behavior to be identical to pre-5.4.7
- AceConfigRegistry-3.0: Added an option to skip options table validation on registering

Ace3 Release - Revision r1104 (October 31st, 2013)
--------------------------------------------------
- AceGUI-3.0: Flow Layout: Added a safeguard to prevent an infinite loop in the layout engine
- AceGUI-3.0: DropDown: Adjust its style slightly to closer resemble the Blizzard DropDown Widget
- AceGUI-3.0: DropDown: API enhancements to specify the width of the pullout and be notified when its opened

Ace3 Release - Revision r1098 (September 13th, 2013)
----------------------------------------------------
- AceDB-3.0: Switch characters to the default profile if their active profile is deleted (Ticket #324)
- AceConfigDialog-3.0: Try to prevent static popup taint (Ticket #322)
- AceGUI-3.0: Button: Add a new "Auto Width" option (Ticket #310)
- AceGUI-3.0: DropDown: Make the entire DropDown widget clickable (Ticket #339)
- AceGUI-3.0: EditBox: Allow dragging macros to the editbox (which will then contain the macros name) (Ticket #337)
- AceGUI-3.0: Slider: Add a workaround for the broken slider steps in WoW 5.4 (Ticket #346)
- AceGUI-3.0: TreeGroup: Fix an issue introduced by 5.4 broken scrollbars (Ticket #345)
- AceHook-3.0: Allow hooking of AnimationGroup scripts (Ticket #314)

Ace3 Release - Revision r1086 (May 21st, 2013)
----------------------------------------------
- AceAddon-3.0: Improved behavior when loading modules during game startup, ensures proper loading order

Ace3 Release - Revision r1083 (March 4th, 2013)
-----------------------------------------------
- AceTimer-3.0: Fixed an issue that caused the parameter list passed to the callback to be cut off at nil values
- AceGUI-3.0: InlineGroup: The title attribute is properly reset for recycled objects

Ace3 Release - Revision r1078 (February 10th, 2013)
---------------------------------------------------
- AceTimer-3.0: Re-write based on AnimationTimers
- AceHook-3.0: Improved checks/error messages when trying to hook a script on a "nil" frame
- AceDBOptions-3.0: Added Italian locale
- AceGUI-3.0: BlizOptionsGroup: Fixed the "default" button callback
- AceGUI-3.0: Colorpicker: The colorpicker is now clamped to the screen

Ace3 Release - Revision r1061 (August 27th, 2012)
-------------------------------------------------
- AceConfigDialog-3.0: Try to avoid potential taints in static popup dialogs
- AceConfigDialog-3.0: Sort multiselects with "radio" style
- AceGUI-3.0: Support for WoW 5.0
- AceGUI-3.0: MultiLineEditBox: Support shift-click'ing items/spells/etc. into the editbox
- AceGUI-3.0: Label: Fix text alignment (Ticket #301)
- AceGUI-3.0: Checkbox: Description text on a disable checkbox should look disabled (Ticket #304)
- AceGUI-3.0: Keybinding: Ensure the Keybinding popup is on the top level (Ticket #305)

Ace3 Release - Revision r1041 (November 29th, 2011)
---------------------------------------------------
- AceDB-3.0: Added locale and factionrealmregion profile keys
- AceSerializer-3.0: Removed support for NaN, as WoW 4.3 does no longer allow it.
- AceGUI-3.0: Frame: Add :EnableResize (Ticket #214)

Ace3 Release - Revision r1032 (June 29th, 2011)
-----------------------------------------------
- AceTab-3.0: Improvements to Match handling (Ticket #255 and #256)
- AceGUI-3.0: DropDown layout fix with hidden labels (Ticket #234)

Ace3 Release - Revision r1025 (April 27th, 2011)
------------------------------------------------
- AceComm-3.0: Updated for 4.1 changes - now handles RegisterAddonMessagePrefix internally for you.
- AceGUI-3.0: TabGroup: Fixed width of tabs in 4.1(Ticket #243)

Ace3 Release - Revision r1009 (February 9th, 2011)
--------------------------------------------------
- AceLocale-3.0: Fix erronous assumption that the default locale is always the first to be registered for the :NewLocale() "silent" flag. The flag must now be set on the FIRST locale to be registered.
- AceLocale-3.0: The :NewLocale() "silent" flag may now be set to the string "raw", meaning nils are returned for unknown translations.
- AceGUI-3.0: Fix the disabled state of Icon widgets
- AceGUI-3.0: The header of the Frame widget now dynamically changes size to fit the text (Ticket #171)
- AceGUI-3.0: Its now possible to define a custom order the elements in a dropdown widget
- AceGUI-3.0: Improved widget focus behaviour across the board (Ticket #192, #193)
- AceGUI-3.0: Fixed a bug that made it impossible to block the tree widget from being user resizable (Ticket #163)
- AceGUI-3.0: Fixed a bug that caused TreeGroups to become unresponsive under certain conditions (Ticket #189, #202)
- AceGUI-3.0: Enhanced the DropDown widget to allow it to be reused more easily.
- AceConfigDialog-3.0: Select Groups now have the proper order in the dropdown (Ticket #184)
- AceConfigDialog-3.0: Implemented "radio" style select boxes (Ticket #149)

Ace3 Release - Revision r981 (October 27th, 2010)
-------------------------------------------------
- AceAddon-3.0: Fixed a library upgrading issue
- AceAddon-3.0: Modules are now enabled in loading order
- AceGUI-3.0: Keybinding: The widget will no longer steal keybindings even when inactive (Ticket #169)
- AceGUI-3.0: EditBox: Fixed spell drag'n'drop


Ace3 Release - Revision r971 (October 12th, 2010)
-------------------------------------------------
- Small fixes and adjustments for the 4.0 Content Patch.
- AceGUI-3.0: ScrollFrame: Allow for a small margin of error when determining if the scroll bar should be shown.
- AceGUI-3.0: Added new widget APIs: GetText for EditBox and DisableButton for MultiLineEditBox

Ace3 Release - Revision r960 (July 20th, 2010)
----------------------------------------------
- AceGUI-3.0: Label: Reset Image Size and TexCoords on Acquire (Ticket #110)
- AceGUI-3.0: CheckBox: Re-apply the disabled state after setting a value, so the visuals are correct in either case. (Ticket #107)
- AceGUI-3.0: Icon: Fix the vertical size. It'll now properly scale with the image size, and not be fixed to about 110px. (Ticket #104)
- AceGUI-3.0: External Containers (Frame, Window) should always start in a visible state. (Ticket #121)
- AceGUI-3.0: Added Blizzard sounds to widgets (Ticket #120)
- AceGUI-3.0: CheckBox: check for self.desc:GetText() being nil as well as "" to prevent setting the wrong height on the checkbox causing bouncing checkboxes.
- AceGUI-3.0: Rewrite of the MultiLineEditBox (Ticket #68)
- AceGUI-3.0: CheckBox: Fix alignment of the text in OnMouseDown when an image is set. (Ticket #142)
- AceGUI-3.0: Add SetMaxLetters APIs to EB and MLEB (Ticket #135)
- AceGUI-3.0: Frame: Add events for OnEnter/OnLeave of the statusbar (Ticket #139)
- AceGUI-3.0: Major cleanups and refactoring in nearly all widgets and containers.
- AceConfigDialog-3.0: Always obey the min/max values on range-type widgets (Ticket #114)
- AceConfigDialog-3.0: Pass iconCoords set on groups in the options table to the tree widget (Ticket #111)
- AceConfigDialog-3.0: Implement "softMin" and "softMax", allowing for a UI-specific minimum/maximum for range controls, while allowing manual input of values in the old min/max range. (Ticket #123)
- AceConfigDialog-3.0: Don't close frames in CloseAll that are being opened after the CloseAll event was dispatched. (Ticket #132).
- AceSerializer-3.0: Fix encoding & decoding of \030. (Ticket #115)
- AceDB-3.0: Remove empty sections on logout, keeping the SV clean of more useless informations.
- AceDBOptions-3.0.lua: Fix a string typo (Ticket #141)

Ace3 Release - Revision r907 (December 16th, 2009)
---------------------------------------------------
- AceGUI-3.0: Frame: Properly save the width in the status table.
- AceConfigCmd-3.0: Properly handle help output of inline groups with a different handler. (Ticket #101)
- AceConfigDialog-3.0: Don't bail out and error when a dialogControl was invalid, instead show the error and fallback to the default control for that type.
- AceConfigDialog-3.0: Fix a hickup with the OnUpdate script not getting upgraded properly in some situations.

Ace3 Release - Revision r900 (December 8th, 2009)
--------------------------------------------------
- AceGUI-3.0: Alot of visual fixes regarding margins and general widget styles.
- AceGUI-3.0: Ability to accept links for EditBox Widget (Ticket #21)
- AceGUI-3.0: ScrollFrame: Hide the scrollbar when there is no overflowing content, and allow the Layout functions to use that space for widgets.
- AceGUI-3.0: DropDown: Added a GetValue() API to the Widget (Ticket #69)
- AceGUI-3.0: Button: Pass the arguments of the OnClick handler to the OnClick callback (Ticket #57)
- AceGUI-3.0: add a Window container, basically a plain window with close button
- AceGUI-3.0: Add support for inline descriptions to the checkbox widget.
- AceGUI-3.0: Added an API to the Window container to disable the user-resizing of the same. (Ticket #80)
- AceGUI-3.0: TreeGroup: Allow iconCoords to be passed for the tree elements. (Ticket #59)
- AceGUI-3.0: Slider: Add a more visible backdrop/border around the manual input area (Ticket #98, #46)
- AceGUI-3.0: Allow displaying a image in front of the checkbox label. (Ticket #82)
- AceConfig-3.0: Added an experimental "descStyle" member to all option table nodes that allows you to control the way the description is presented. 
                 Supported values are "tooltip" for the old behaviour, and "inline" for a inline display of the description, pending support in AceGUI-3.0 widgets.
- AceConfigCmd-3.0: Properly parse functions and methods supplied for the "hidden" option table member. (Ticket #96)
- AceConfigDialog-3.0: Fix the unpacking of the basepath arguments when internally calling :Open (Ticket #90)
- AceConfigDialog-3.0: Properly refresh BlizOptions Windows which are registered with a path on NotifyChange. (Ticket #93)
- AceConfigDialog-3.0: Allow image/imageCoords on toogle elements (Note that the width/height of the image on the toggle cannot be changed) (Ticket #82)
- AceConfigDialog-3.0: Pass the groups "name" tag to DropDownGroups as the title. (Ticket #79)
- AceDB-3.0: Remove the metatable from the DB before removing defaults, so we don't accidentally invoke it in the process. (Ticket #66)
- AceDB-3.0: Don't save the profileKeys for namespaces, since we use the profile of the parent DB anyway. This will cut down on SV complexity when using alot of namespaces.
- AceDB-3.0: Don't fire the OnProfileReset callback when copying a profile.
- AceDBOptions-3.0: Show the current profile on the dialog. (Ticket #56)
- AceComm-3.0: Add callbacks for message chunks going out the wire (via CTL). Useful for displaying progress for very large messages.
- AceConsole-3.0: Add :Printf() so you don't have to do Print(format())

Ace3 Beta - Revision 820 (August 7th, 2009)
--------------------------------------------
- AceComm-3.0: Updated ChatThrottleLib to v21
- AceGUI-3.0: Fixed a glitch in the TabGroup code that caused tabs to be unresponsive under rare conditions. (Ticket #38)
- AceGUI-3.0: Consistent "disabled" behaviour of all widgets. (Ticket #47)
- AceGUI-3.0: Changed the way widgets are handled on release to avoid a crash in the game client. (Ticket #49)
- AceGUI-3.0: Fixed a glitch in the button graphics. (Ticket #58)
- AceGUI-3.0: Localized the "Close" Text on the Frame widget.

Ace3 Beta - Revision 803 (April 14th, 2009)
--------------------------------------------
- AceConfig-3.0: Allow spaces in the keys of config tables. Spaces will be changed on the fly to underscores in AceConfigCmd-3.0 - there is no collision check in place, yet.
- AceConfig-3.0: Support a "fontSize" attribute to the description type. Possible values are "small" (default), "medium" and "large".
- AceConfigDialog-3.0: Fixed an error that would occur when calling InterfaceOptionsFrame_OpenToCategory from within an event handler in a Blizzard Options integrated frame. (Ticket #33)
- AceConfigDialog-3.0: The "execute" type does now recognize the "image" attributes, and will display a clickable icon instead of the button when an image is supplied. (Ticket #35)
- AceConfigDialog-3.0: Pass icons defined in the option table to the TreeGroup widget (Ticket #20)
- AceConfigDialog-3.0: Fixed a bug that caused an empty group widget to be drawn if all groups were hidden.
- AceConfigCmd-3.0: Improved the behaviour of select and multiselect elements. (Ticket #26)
- AceDB-3.0: Add a GetNamespace function to the DB Objects which returns an existing namespace from the DB object.
- AceGUI-3.0 Slider Widget: Properly show percentage values as min/max if isPercent is true. (Ticket #32)
- AceGUI-3.0: Fixed an error in the TreeGroup Widget that caused execution to stop if no name was provided.
- AceGUI-3.0: Fixed the behaviour of the MultiLineEditbox Widget (Accept button not clickable). (Ticket #28)
- AceGUI-3.0: TabGroup: Set a maximum width for tabs based on the size of the widget. (Ticket #34)
- AceGUI-3.0: Added a new InteractiveLabel with OnEnter/OnLeave/OnClick callbacks and a highlight texture
- AceGUI-3.0: Add SetFont and SetFontObject functions to the Label widget (and the new InteractiveLabel)
- AceGUI-3.0: Support icons in the TreeGroup display. (Ticket #20)
- AceGUI-3.0: Added a new :SetRelativeWidth Widget-API that allows you to set the width of widgets relative to their container.
- AceGUI-3.0: Alot of fixes, tweaks and consistency changes.

Ace3 Beta - Revision 741 (Feb 15th, 2009)
--------------------------------------------
- AceDBOptions-3.0: Disable the "Copy From" and "Delete" dropdowns if there are no profiles to choose from. (Ticket #19)
- AceGUI-3.0: Improve TabGroup visual style - only stretch them to the full width if they would use more then 75% of the exisiting space.
- AceGUI-3.0: Added a third optional argument to <container>:AddChild() to specify the position for the new widget. (Ticket #22)
- AceConfigCmd-3.0: Improve help output when viewing groups.
- AceConfigDialog-3.0: Refresh the Options Panel after a confirmation is canceled to reset the value to its previous value. (Ticket #23)
- AceDB-3.0: Fix a data inconsistency when using false as a table key. (Ticket #25)

Ace3 Beta - Revision 722 (Jan 4th, 2009)
--------------------------------------------
- AceHook-3.0: Fix :SecureHookScript to not fail on previously empty scripts since frame:HookScript does nothing at all in that case. (Ticket #16)
- AceLocale-3.0: Implement 'silent' option for :NewLocale to disable the warnings on unknown entrys (Ticket #18)
- AceTimer-3.0: Implement :TimeLeft(handle) function (Ticket #10)
- AceGUI-3.0: Fix TabGroup tab resizing to be consistent
- AceGUI-3.0: Fixed EditBox alignment when the label is disabled (Ticket #13)
- AceDB-3.0: Implement OnProfileShutdown callback (Ticket #7)
- AceDBOptions-3.0: Updated esES and ruRU locale

Ace3 Beta - Revision 706 (Oct 18th, 2008)
--------------------------------------------
- First Beta release after WoWAce move
- Removed WoW 2.4.x compat layer
- AceGUI-3.0: Fix disabling of the Multiline Editbox
- AceGUI-3.0: Improvements to the Keybinding Widget

Ace3 Beta - Revision 81437 (Sept 6th, 2008)
--------------------------------------------
- AceConfigDialog-3.0: the confirm callback will now receive the new value that is being set (same signature as the validate callback)
- AceConfigDialog-3.0: :Close and :CloseAll are now safe to call from within callbacks.
- AceGUI-3.0: Added new methods to the widget base table, see ACE-205 for full reference
- AceGUI-3.0: Various fixes to Widgets and recycling process
- Now compatible with WoW 3.0 (compat layer is to be removed upon 3.0 release)


Ace3 Beta - Revision 76325 (June 9th, 2008)
--------------------------------------------
- AceGUI-3.0: Finish Multiselect support for the Dropdown widget (nargiddley)
- AceGUI-3.0: Re-write TabGroup layouting (nargiddley)
- AceGUI-3.0: TreeGroup: Add :EnableButtonTooltips(enable) to make the default tooltips on the tree optional, enabled by default. (nargiddley)
- AceGUI-3.0: TabGroup: Add OnTabEnter and OnTabLeave Callbacks  (nargiddley)
- AceConfigDialog-3.0: Add :SelectGroup(appName, ...) - Selects the group given by the path specified then refreshes open windows. (nargiddley)
- AceConfigDialog-3.0: :Open now accepts an optional path, when given will open the window with only the given group and its children visible (nargiddley)
- AceConfigDialog-3.0: :AddToBlizOptions now accepts an optional path, this will add the config page to display the specified group and its children only. (nargiddley)
- AceConfigDialog-3.0: ACE-189: allow multiselect to be shown as a dropdown by setting dialogControl = "Dropdown" (nargiddley)
- AceConfigDialog-3.0: Add Custom tooltips to the TreeGroup and TabGroup, shows both name and desc for the group. (nargiddley)
- AceConfigCmd-3.0: ACE-195: Remove unneeded references to .confirm, will no longer error when .confirm is a boolean (nargiddley)
- AceAddon-3.0: Allow for an optional first argument to NewAddon to be a table to be used as the base for the addon. (ammo)

Ace3 Beta - Revision 74633 (May 19th, 2008)
--------------------------------------------
- AceTimer-3.0: ACE-173: don't error on nil handle for CancelTimer(), just bail out early. (ammo)
- AceGUI-3.0: ACE-161, ACE-180, ACE-181: New and improved DropDown widget (originally coded by Borlox) (nargiddley,nevcairiel)
- AceGUI-3.0: AceGUI will call OnWidthSet and OnHeightSet as frames resize (nargiddley)
- AceGUI-3.0: TabGroup: Use OptionsFrameTabButtonTemplate for tabs (nargiddley)
- AceGUI-3.0: TabGroup: Tabs now span multiple lines when there are too many to fit in the width of the frame (nargiddley)
- AceGUI-3.0: TreeGroup: Tree is now sizable by dragging, orig patch by yssaril (nargiddley)
- AceGUI-3.0: Flow layout will now reduce widgets width to fit rather than leaving them sticking out the side of container widgets (nargiddley)
- AceGUI-3.0: Dropdowns will no longer be left open in the background when the frame is clicked or other widgets are activated (nargiddley)
- AceGUI-3.0: ACE-159: Rename Release to OnRelease and Acquire to OnAcquire for widgets. (nargiddley)
- AceGUI-3.0: ACE-171: add IsVisible and IsShown methods to the widget metatable (nargiddley)
- AceGUI-3.0: ACE-164: add tooltips to tree to show full text of childs that got clipped (ammo)
- AceGUI-3.0: ACE-174: make buttons in AceGUI-3.0 locale independant (ammo)
- AceGUI-3.0: ACE-166: fix treegroup visual bug (ammo)
- AceGUI-3.0: ACE-184: make numeric entry for slider more intuitive (ammo)
- AceConfigCmd-3.0: ACE-172 - ignore description in cmd (ammo)
- AceConsole-3.0:  nolonger check for existance of slashcommands, overwrite where needed. Last one wins, this enables AddonLoader to X-LoadOn-Slash and override the slashcommand from AddonLoader slashcommand with an Ace3 one. (Ammo)

Ace3 Beta - Revision 69509 (April 13th, 2008)
---------------------------------------------
- AceComm-3.0: turn off error messages when receiving invalid multi-part messages (its happening on login etc) (nevcairiel)
- AceDBOptions-3.0: shorten info text at top to prevent scrollbars. (nevcairiel)
- AceHook-3.0: ACE-162: fix unhooking of objects that were not actually hooked (nevcairiel)
- AceDB-3.0: fire the DB callbacks after the namespaces changed their profile as well (nevcairiel)
- AceDB-3.0: namespaces can now be individually reset using :ResetProfile() on the namespace directly (nevcairiel)
- AceDB-3.0: added a optional argument to :ResetProfile to not populate the reset to all namespaces (so the main profile can reset individually without reseting all namespaces too)  (nevcairiel)

Ace3 Beta - Revision 66329 (March 27th, 2008)
---------------------------------------------
- Overall 2.4 clean ups - removing 2.4 checks and work arounds (nevcairiel)
- AceBucket-3.0: clear the timer reference when unregistering a bucket to prevent a error when unregistering a bucket that was never fired (nevcairiel)
- AceAddon-3.0: Bugfix when enabling/disabling modules from the parents OnEnable after disabling / enabling the parent addon. (ammo)
- AceGUI-3.0: Don't parent the BlizOptionsGroup widget to UIParent and Hide it by default. Fixes stray controls on the screen. (nargiddley)
- AceConfigDialog-3.0: Config windows without a default size won't incorrectly get a default size from a previously open window. (nargiddley)
- AceDBOptions-3.0: added zhCN and zhTW locale (nevcairiel)

Ace3 Beta - Revision 65665 (March 25th, 2008)
---------------------------------------------
- AceGUI-3.0: ACE-139: Changed all Widgets to resemble the Blizzard 2.4 Options Style (nevcairiel)
- AceGUI-3.0: Fixed "List"-Layout not reporting new width to "fill"-mode widgets (mikk)
- AceGUI-3.0: added :SetColor to the Label widget (nevcairiel)
- AceGUI-3.0: ACE-132: ColorPicker: added checkers texture for better alpha channel display, and fixed "white"-texture bug (nevcairiel,nargiddley,ammo)
- AceConfig-3.0: ACE-113: Added uiName, uiType, handler, option, type to the info table (nevcairiel,nargiddley)
- AceConfigDialog-3.0: ACE-139: Adjusted for 2.4 options panels (nevcairiel)
- AceConfigDialog-3.0: Use "width" parameter for the description widget (if present) (nevcairiel)
- AceConfigDialog-3.0: ACE-135: Add support for specifying a rowcount for multiline editboxes (nargiddley)
- AceConfigDialog-3.0: :AddToBlizOptions will return the frame registered so you can use it in InterfaceOptionsFrame_OpenToFrame (nevcairiel)
- AceConfigCmd-3.0: handle "hidden" in help-output (nevcairiel)
- AceHook-3.0: fix unhooking of secure hooks (nevcairiel)
- AceDBOptions-3.0: add optional argument to GetOptionsTable(db[, noDefaultProfiles]) - if set to true will not show the default profiles in the profile selection (nevcairiel)
- AceDBOptions-3.0: added koKR locale (nevcairiel)
- Ace3 Standalone: Removed the "Ace3" Category from the 2.4 options panel (nevcairiel)

Ace3 Beta - Revision 64176 (March 10th, 2008)
---------------------------------------------
- AceGUI-3.0: Improve Alpha handling for the ColorPicker widget, ColorPicker widget closes the ColorPickerFrame before opening to prevent values getting carried over (nargiddley)
- AceGUI-3.0: The Slider widget will only react to the mousewheel after it has been clicked (anywhere including the label) to prevent accidental changes to the value when trying to scroll the container it is in (nargiddley)
- AceGUI-3.0: The TreeGroup widget is scrollable with the mousewheel (nargiddley)
- AceGUI-3.0: ACE-154: Fix frame levels in more cases to prevent widgets ending up behind their containers (nargiddley)
- AceConfigDialog: Color picker obeys hasAlpha on the color type (nargiddley)
- AceConfigDialog-3.0: ACE-155: Make sure that the selected group is type='group' when checking if it exists (nargiddley)
- AceDBOptions-3.0: added frFR locale (nevcairiel)

Ace3 Beta - Revision 63886 (March 8th, 2008)
---------------------------------------------
- AceDBOptions-3.0: new library to provide a Ace3Options table to control the AceDB-3.0 profiles (nevcairiel)
- AceDB-3.0: add "silent" option to DeleteProfile and CopyProfile when we deal with namespaces (nevcairiel)
- AceDB-3.0: implement library upgrade path (nevcairiel)
- AceDB-3.0: ACE-146: fix problem with non-table values overruling ['*']-type defaults (nevcairiel)
- AceConsole-3.0: treat |T|t texture links similar to |H|h|h links. (ammo)
- AceGUI-3.0: Use Blizzard Templates for the EditBox and DropDown widget (nevcairiel)
- AceBucket-3.0: ACE-150: callback is now optional, if not supplied will use the eventname as method name (only possible if one event is supplied, and not a event table) (nevcairiel)
- tests: adjust tests for AceGUI and AceConsole changes (nevcairiel)

Ace3 Beta - Revision 63220 (Feb 29th, 2008)
---------------------------------------------
- AceTimer-3.0: CancelAllTimers() now cancels silent (elkano)
- AceConfigDialog: Add :SetDefaultSize(appName, width, height), sets the size the dialog will open to. Does not effect already open windows.  (nargiddley)
- AceConfigDialog: Fix typo in type check for range values (nargiddley)
- AceGUI: ColorPicker widget will correctly fire OnValueChanged for the cancel event of the colorpicker popup.  Reset ColorPicker's color on Acquire.  (nargiddley)
- AceGUI: Fix Spelling of Aquire -> Acquire for widgets, all custom widgets will need to be updated.  A warning will be printed for widgets not upgraded yet.  (nargiddley)
- AceConfigCmd-3.0: add simple coloring to slashcommand output. (ammo)
- AceConsole-3.0: add some color to :Print (ammo)
- AceAddon-3.0: set error level on library embedding to point to the :NewAddon call (nevcairiel)

Ace3 Beta - Revision 62182 (Feb 20th, 2008)
---------------------------------------------
- Ace3 StandAlone: Add a page to the Blizzard 2.4 Interface Options with icons to open dialogs for configs registered when installed standalone (nargiddley)
- AceConfigDialog: type = 'description' now uses the fields image and imageCoords instead of icon and iconCoords, add imageWidth and imageHeight (nargiddley)
- AceConfigDialog: Add :AddToBlizzardOptions(appName, name), this will add the specified config to the Blizzard Options pane new in 2.4.  This will only be available if running on the 2.4 PTR (nargiddley)
- AceDB: fix GetProfiles() when setting the same profile twice (nevcairiel)
- AceDB: bail out of :SetProfile early when trying to set to the same profile (nevcairiel)
- AceDB: add nil checks to metatable handling (nevcairiel)
- AceDB: clear tables that are empty after defaults removal (nevcairiel)
- AceGUI: Fix a couple of layout bugs causing the width of groups to be wrong (nargiddley)
- AceGUI: Add Icon widget (nargiddley)
- AceGUI: Allow room for the border in the BlizOptionsGroup widget (nargiddley)
- AceGUI: Button and Keybinding use UIPanelButtonTemplate2 (nargiddley)
- AceConsole-3.0: Fix bug where no table for [self] was created when registering weak commands (ammo)
- AceTimer-3.0: add missing :OnEmbedDisable (ammo)
- AceAddon-3.0: added :GetName() that will always return the "real" name of a addon or module object without any prefixes (nevcairiel)

Ace3 Beta - Revision 60697 (Feb 9th, 2008)
---------------------------------------------
- CallbackHandler-1.0: remove unnecessary table creation if a event is fired thats not registered (nevcairiel)
- AceAddon-3.0: fixed a bug with recursive addon loading (nevcairiel)
- AceGUI: Update TabGroup's tablist format, tabs are selected by value not index (nargiddley)
- AceGUI: Add MultiLineEditBox widget (nargiddley, originally by bam)
- AceGUI: Small fix to the flow layout preventing controls overlapping in some cases (nargiddley)
- AceConfigDialog: Implement control and dialogControl for types 'input' and 'select' (nargiddley)
- AceConfigDialog: Add support for multiline = true on type = 'input' (nargiddley)
- AceConfigDialog: Fix an error when all groups are hidden in a group with childGroups = 'select' (nargiddley)
- AceConfigDialog: type = 'description' will now show .icon as an image with its text (nargiddley)
- AceConfigDialog: multiline inputs are no longer forced to width = "full" (nargiddley)
- AceConfigDialog: bug fix when loading without AceConsole present (nevcairiel)

Ace3 Beta - Revision 60545 (Feb 7th, 2008)
---------------------------------------------
- AceGUI: SetToplevel(true) for the Frame widget, multiple open windows should play nice together now (nargiddley)
- AceGUI: Move Frames to the FULLSCREEN_DIALOG strata (nargiddley)
- AceGUI: Dropdown, Editbox and Keybinding labels grey out when disabled (nargiddley)
- AceGUI: Add OnClick callback to the TreeGroup widget (nargiddley)
- AceConfigDialog: Confirm popups will be above the config window (nargiddley)

Ace3 Beta - Revision 60163 (Feb 3rd, 2008)
---------------------------------------------
- Initial Beta release

================
File: Libs/vanilla/Ace3/LICENSE.txt
================
Copyright (c) 2007, Ace3 Development Team 

All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice, 
      this list of conditions and the following disclaimer in the documentation 
      and/or other materials provided with the distribution.
    * Redistribution of a stand alone version is strictly prohibited without 
      prior written authorization from the Lead of the Ace3 Development Team. 
    * Neither the name of the Ace3 Development Team nor the names of its contributors 
      may be used to endorse or promote products derived from this software without 
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

================
File: Libs/vanilla/Ace3/README.md
================
# Ace3v
Vanilla WoW AddOn Library - Ace3

The goal of this project is to bring the Ace3 into vanilla wow. The author of the original Ace3 library is the Ace3 Development team.

Project current situation:

* All basic libraries are recoded so that they can be used in vanilla WOW

* Most of the AceGUI library are recoded, need furthur tests

* Added an additional lib AceCursor which is still under development, the purpose of this library is to implement the function GetCursorInfo of retail WoW

================
File: Libs/vanilla/CallbackHandler-1.0/CallbackHandler-1.0.lua
================
--[[ $Id: CallbackHandler-1.0.lua 1131 2015-06-04 07:29:24Z nevcairiel $ ]]
local MAJOR, MINOR = "CallbackHandler-1.0", 6
local CallbackHandler = LibStub:NewLibrary(MAJOR, MINOR)

if not CallbackHandler then return end -- No upgrade needed

-- Lua APIs
local tconcat, tinsert, tgetn, tsetn = table.concat, table.insert, table.getn, table.setn
local assert, error, loadstring = assert, error, loadstring
local setmetatable, rawset, rawget = setmetatable, rawset, rawget
local next, pairs, type, tostring = next, pairs, type, tostring
local strgsub = string.gsub

local new, del
do
local list = setmetatable({}, {__mode = "k"})
function new()
	local t = next(list)
	if not t then
		return {}
	end
	list[t] = nil
	return t
end

function del(t)
	setmetatable(t, nil)
	for k in pairs(t) do
		t[k] = nil
	end
	tsetn(t,0)
	list[t] = true
end
end

local meta = {__index = function(tbl, key) rawset(tbl, key, new()) return tbl[key] end}

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: geterrorhandler

local function errorhandler(err)
	return geterrorhandler()(err)
end
CallbackHandler.errorhandler = errorhandler

local function CreateDispatcher(argCount)
	local code = [[
		local xpcall, errorhandler = xpcall, LibStub("CallbackHandler-1.0").errorhandler
		local method, UP_ARGS
		local function call()
			local func, ARGS = method, UP_ARGS
			method, UP_ARGS = nil, NILS
			return func(ARGS)
		end
		return function(handlers, ARGS)
			local index
			index, method = next(handlers)
			if not method then return end
			repeat
				UP_ARGS = ARGS
				xpcall(call, errorhandler)
				index, method = next(handlers, index)
			until not method
		end
	]]
	local c = 4*argCount-1
	local s = "b01,b02,b03,b04,b05,b06,b07,b08,b09,b10"
	code = strgsub(code, "UP_ARGS", string.sub(s,1,c))
	s = "a01,a02,a03,a04,a05,a06,a07,a08,a09,a10"
	code = strgsub(code, "ARGS", string.sub(s,1,c))
	s = "nil,nil,nil,nil,nil,nil,nil,nil,nil,nil"
	code = strgsub(code, "NILS", string.sub(s,1,c))
	return assert(loadstring(code, "safecall Dispatcher["..tostring(argCount).."]"))()
end

local Dispatchers = setmetatable({}, {__index=function(self, argCount)
	local dispatcher = CreateDispatcher(argCount)
	rawset(self, argCount, dispatcher)
	return dispatcher
end})

--------------------------------------------------------------------------
-- CallbackHandler:New
--
--   target            - target object to embed public APIs in
--   RegisterName      - name of the callback registration API, default "RegisterCallback"
--   UnregisterName    - name of the callback unregistration API, default "UnregisterCallback"
--   UnregisterAllName - name of the API to unregister all callbacks, default "UnregisterAllCallbacks". false == don't publish this API.
function CallbackHandler:New(target, RegisterName, UnregisterName, UnregisterAllName)

	RegisterName = RegisterName or "RegisterCallback"
	UnregisterName = UnregisterName or "UnregisterCallback"
	if UnregisterAllName==nil then	-- false is used to indicate "don't want this method"
		UnregisterAllName = "UnregisterAllCallbacks"
	end

	-- we declare all objects and exported APIs inside this closure to quickly gain access
	-- to e.g. function names, the "target" parameter, etc


	-- Create the registry object
	local events = setmetatable({}, meta)
	local registry = { recurse=0, events=events }

	-- registry:Fire() - fires the given event/message into the registry
	function registry:Fire(eventname, argc, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
		if not rawget(events, eventname) or not next(events[eventname]) then return end
		local oldrecurse = registry.recurse
		registry.recurse = oldrecurse + 1

		argc = argc or 0
		Dispatchers[argc+1](events[eventname], eventname, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)

		registry.recurse = oldrecurse

		if registry.insertQueue and oldrecurse==0 then
			-- Something in one of our callbacks wanted to register more callbacks; they got queued
			for eventname,callbacks in pairs(registry.insertQueue) do
				local first = not rawget(events, eventname) or not next(events[eventname])	-- test for empty before. not test for one member after. that one member may have been overwritten.
				for self,func in pairs(callbacks) do
					events[eventname][self] = func
					-- fire OnUsed callback?
					if first and registry.OnUsed then
						registry.OnUsed(registry, target, eventname)
						first = nil
					end
				end
				del(callbacks)
			end
			del(registry.insertQueue)
			registry.insertQueue = nil
		end
	end

	-- Registration of a callback, handles:
	--   self["method"], leads to self["method"](self, ...)
	--   self with function ref, leads to functionref(...)
	--   "addonId" (instead of self) with function ref, leads to functionref(...)
	-- all with an optional arg, which, if present, gets passed as first argument (after self if present)
	target[RegisterName] = function(self, eventname, method, ...)
		if type(eventname) ~= "string" then
			error("Usage: "..RegisterName.."(eventname, method[, arg]): 'eventname' - string expected.", 2)
		end

		method = method or eventname

		local first = not rawget(events, eventname) or not next(events[eventname])	-- test for empty before. not test for one member after. that one member may have been overwritten.

		if type(method) ~= "string" and type(method) ~= "function" then
			error("Usage: "..RegisterName.."(eventname, method[, arg]): 'method' - string or function expected.", 2)
		end

		local regfunc
		local a1 = arg[1]

		if type(method) == "string" then
			-- self["method"] calling style
			if type(self) ~= "table" then
				error("Usage: "..RegisterName.."(eventname, method[, arg]): self was not a table?", 2)
			elseif self==target then
				error("Usage: "..RegisterName.."(eventname, method[, arg]): do not use Library:"..RegisterName.."(), use your own 'self'.", 2)
			elseif type(self[method]) ~= "function" then
				error("Usage: "..RegisterName.."(eventname, method[, arg]): 'method' - method '"..tostring(method).."' not found on 'self'.", 2)
			end

			if tgetn(arg) >= 1 then
				regfunc = function (...) return self[method](self,a1,unpack(arg)) end
			else
				regfunc = function (...) return self[method](self,unpack(arg)) end
			end
		else
			-- function ref with self=object or self="addonId"
			if type(self)~="table" and type(self)~="string" then
				error("Usage: "..RegisterName.."(self or addonId, eventname, method[, arg]): 'self or addonId': table or string expected.", 2)
			end

			if tgetn(arg) >= 1 then
				regfunc = function (...) return method(a1, unpack(arg)) end
			else
				regfunc = method
			end
		end


		if events[eventname][self] or registry.recurse<1 then
		-- if registry.recurse<1 then
			-- we're overwriting an existing entry, or not currently recursing. just set it.
			events[eventname][self] = regfunc
			-- fire OnUsed callback?
			if registry.OnUsed and first then
				registry.OnUsed(registry, target, eventname)
			end
		else
			-- we're currently processing a callback in this registry, so delay the registration of this new entry!
			-- yes, we're a bit wasteful on garbage, but this is a fringe case, so we're picking low implementation overhead over garbage efficiency
			registry.insertQueue = registry.insertQueue or setmetatable(new(),meta)
			registry.insertQueue[eventname][self] = regfunc
		end
	end

	-- Unregister a callback
	target[UnregisterName] = function(self, eventname)
		if not self or self==target then
			error("Usage: "..UnregisterName.."(eventname): bad 'self'", 2)
		end
		if type(eventname) ~= "string" then
			error("Usage: "..UnregisterName.."(eventname): 'eventname' - string expected.", 2)
		end
		if rawget(events, eventname) and events[eventname][self] then
			events[eventname][self] = nil

			-- Fire OnUnused callback?
			if registry.OnUnused and not next(events[eventname]) then
				registry.OnUnused(registry, target, eventname)
			end

			if rawget(events, eventname) and not next(events[eventname]) then
				del(events[eventname])
				events[eventname] = nil
			end
		end
		if registry.insertQueue and rawget(registry.insertQueue, eventname) and registry.insertQueue[eventname][self] then
			registry.insertQueue[eventname][self] = nil
		end
	end

	-- OPTIONAL: Unregister all callbacks for given selfs/addonIds
	if UnregisterAllName then
		target[UnregisterAllName] = function(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
			if not a1 then
				error("Usage: "..UnregisterAllName.."([whatFor]): missing 'self' or 'addonId' to unregister events for.", 2)
			end
			if a1 == target then
				error("Usage: "..UnregisterAllName.."([whatFor]): supply a meaningful 'self' or 'addonId'", 2)
			end

			-- use our registry table as argument table
			registry[1] = a1
			registry[2] = a2
			registry[3] = a3
			registry[4] = a4
			registry[5] = a5
			registry[6] = a6
			registry[7] = a7
			registry[8] = a8
			registry[9] = a9
			registry[10] = a10
			for i=1,10 do
				local self = registry[i]
				registry[i] = nil
				if self then
					if registry.insertQueue then
						for eventname, callbacks in pairs(registry.insertQueue) do
							if callbacks[self] then
								callbacks[self] = nil
							end
						end
					end
					for eventname, callbacks in pairs(events) do
						if callbacks[self] then
							callbacks[self] = nil
							-- Fire OnUnused callback?
							if registry.OnUnused and not next(callbacks) then
								registry.OnUnused(registry, target, eventname)
							end
						end
					end
				end
			end
		end
	end

	return registry
end

-- CallbackHandler purposefully does NOT do explicit embedding. Nor does it
-- try to upgrade old implicit embeds since the system is selfcontained and
-- relies on closures to work.

================
File: Libs/vanilla/CallbackHandler-1.0/CallbackHandler-1.0.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="CallbackHandler-1.0.lua"/>
</Ui>

================
File: Libs/vanilla/JSON.lua
================
--
-- json.lua
--
-- Copyright (c) 2020 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\",
  [ "\"" ] = "\"",
  [ "\b" ] = "b",
  [ "\f" ] = "f",
  [ "\n" ] = "n",
  [ "\r" ] = "r",
  [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  local f = math.floor
  if n <= 0x7f then
    return string.char(n)
  elseif n <= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(1, 4),  16 )
  local n2 = tonumber( s:sub(7, 10), 16 )
   -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local res = ""
  local j = i + 1
  local k = j

  while j <= #str do
    local x = str:byte(j)

    if x < 32 then
      decode_error(str, j, "control character in string")

    elseif x == 92 then -- `\`: Escape
      res = res .. str:sub(k, j - 1)
      j = j + 1
      local c = str:sub(j, j)
      if c == "u" then
        local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                 or str:match("^%x%x%x%x", j + 1)
                 or decode_error(str, j - 1, "invalid unicode escape in string")
        res = res .. parse_unicode_escape(hex)
        j = j + #hex
      else
        if not escape_chars[c] then
          decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
        end
        res = res .. escape_char_map_inv[c]
      end
      k = j + 1

    elseif x == 34 then -- `"`: End of string
      res = res .. str:sub(k, j - 1)
      return res, j + 1
    end

    j = j + 1
  end

  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx <= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end


return json

================
File: Libs/vanilla/LibDataBroker-1.1/LibDataBroker-1.1.lua
================
assert(LibStub, "LibDataBroker-1.1 requires LibStub")
assert(LibStub:GetLibrary("CallbackHandler-1.0", true), "LibDataBroker-1.1 requires CallbackHandler-1.0")

local lib, oldminor = LibStub:NewLibrary("LibDataBroker-1.1", 4)
if not lib then return end
oldminor = oldminor or 0


lib.callbacks = lib.callbacks or LibStub:GetLibrary("CallbackHandler-1.0"):New(lib)
lib.attributestorage, lib.namestorage, lib.proxystorage = lib.attributestorage or {}, lib.namestorage or {}, lib.proxystorage or {}
local attributestorage, namestorage, callbacks = lib.attributestorage, lib.namestorage, lib.callbacks

if oldminor < 2 then
	lib.domt = {
		__metatable = "access denied",
		__index = function(self, key) return attributestorage[self] and attributestorage[self][key] end,
	}
end

if oldminor < 3 then
	lib.domt.__newindex = function(self, key, value)
		if not attributestorage[self] then attributestorage[self] = {} end
		if attributestorage[self][key] == value then return end
		attributestorage[self][key] = value
		local name = namestorage[self]
		if not name then return end
		callbacks:Fire("LibDataBroker_AttributeChanged", name, key, value, self)
		callbacks:Fire("LibDataBroker_AttributeChanged_"..name, name, key, value, self)
		callbacks:Fire("LibDataBroker_AttributeChanged_"..name.."_"..key, name, key, value, self)
		callbacks:Fire("LibDataBroker_AttributeChanged__"..key, name, key, value, self)
	end
end

if oldminor < 2 then
	function lib:NewDataObject(name, dataobj)
		if self.proxystorage[name] then return end

		if dataobj then
			assert(type(dataobj) == "table", "Invalid dataobj, must be nil or a table")
			self.attributestorage[dataobj] = {}
			for i,v in pairs(dataobj) do
				self.attributestorage[dataobj][i] = v
				dataobj[i] = nil
			end
		end
		dataobj = setmetatable(dataobj or {}, self.domt)
		self.proxystorage[name], self.namestorage[dataobj] = dataobj, name
		self.callbacks:Fire("LibDataBroker_DataObjectCreated", name, dataobj)
		return dataobj
	end
end

if oldminor < 1 then
	function lib:DataObjectIterator()
		return pairs(self.proxystorage)
	end

	function lib:GetDataObjectByName(dataobjectname)
		return self.proxystorage[dataobjectname]
	end

	function lib:GetNameByDataObject(dataobject)
		return self.namestorage[dataobject]
	end
end

if oldminor < 4 then
	local next = pairs(attributestorage)
	function lib:pairs(dataobject_or_name)
		local t = type(dataobject_or_name)
		assert(t == "string" or t == "table", "Usage: ldb:pairs('dataobjectname') or ldb:pairs(dataobject)")

		local dataobj = self.proxystorage[dataobject_or_name] or dataobject_or_name
		assert(attributestorage[dataobj], "Data object not found")

		return next, attributestorage[dataobj], nil
	end

	local ipairs_iter = ipairs(attributestorage)
	function lib:ipairs(dataobject_or_name)
		local t = type(dataobject_or_name)
		assert(t == "string" or t == "table", "Usage: ldb:ipairs('dataobjectname') or ldb:ipairs(dataobject)")

		local dataobj = self.proxystorage[dataobject_or_name] or dataobject_or_name
		assert(attributestorage[dataobj], "Data object not found")

		return ipairs_iter, attributestorage[dataobj], 0
	end
end

================
File: Libs/vanilla/LibDeflate/examples/example.lua
================
--[[
zlib License

(C) 2018-2020 Haoqian He

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
--]]

--- LibDeflate usage example
-- @author Haoqian He
-- @file example.lua

local LibDeflate

if LibStub then -- You are using LibDeflate as WoW addon
	LibDeflate = LibStub:GetLibrary("LibDeflate")
else
	-- You are using LibDeflate as Lua library.
	-- Setup the path to locate LibDeflate.lua,
	-- if 'require("LibDeflate")' fails, for example:
	-- package.path = ("?.lua;../?.lua;")..(package.path or "")
	LibDeflate = require("LibDeflate")
end

local example_input = "12123123412345123456123456712345678123456789"

-- Compress using raw deflate format
local compress_deflate = LibDeflate:CompressDeflate(example_input)

-- decompress
local decompress_deflate = LibDeflate:DecompressDeflate(compress_deflate)
-- Check if the first return value of DecompressXXXX is non-nil to know if the
-- decompression succeeds.
if decompress_deflate == nil then
	error("Decompression fails.")
else
	-- Decompression succeeds.
	assert(example_input == decompress_deflate)
end


-- If it is to transmit through WoW addon channel,
-- compressed data must be encoded so NULL ("\000") is not transmitted.
local data_to_trasmit_WoW_addon = LibDeflate:EncodeForWoWAddonChannel(
	compress_deflate)
-- When the receiver gets the data, decoded it first.
local data_decoded_WoW_addon = LibDeflate:DecodeForWoWAddonChannel(
	data_to_trasmit_WoW_addon)
-- Then decomrpess it
assert(LibDeflate:DecompressDeflate(data_decoded_WoW_addon) == example_input)

-- The compressed output is not printable. EncodeForPrint will convert to
-- a printable format, in case you want to export to the user to
-- copy and paste. This encoding will make the data 25% bigger.
local printable_compressed = LibDeflate:EncodeForPrint(compress_deflate)

-- DecodeForPrint to convert back.
-- DecodeForPrint will remove prefixed and trailing control or space characters
-- in the string before decode it.
assert(LibDeflate:DecodeForPrint(printable_compressed) == compress_deflate)


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

--- Compress and decompress using zlib format
local compress_zlib = LibDeflate:CompressZlib(example_input)
local decompress_zlib = LibDeflate:DecompressZlib(compress_zlib)
assert(decompress_zlib == example_input)

--- Control the compression level
-- NOTE: High compression level does not make a difference here,
-- because the input data is very small
local compress_deflate_with_level = LibDeflate:CompressDeflate(example_input
	, {level = 9})
local decompress_deflate_with_level = LibDeflate:DecompressDeflate(
	compress_deflate_with_level)
assert(decompress_deflate_with_level == example_input)


-- Compress with a preset dictionary
local dict_str = "121231234" -- example preset dictionary string.
-- print(LibDeflate:Adler32(dict_str), #dict_str)
-- 9 147325380
-- hardcode the print result above, the ensure it is not modified
-- accidenttaly during the program development.
--
-- WARNING: The compressor and decompressor must use the same dictionary.
-- You should be aware of this when tranmitting compressed data over the
-- internet.
local dict = LibDeflate:CreateDictionary(dict_str, 9, 147325380)

-- Using the dictionary with raw deflate format
local compress_deflate_with_dict = LibDeflate:CompressDeflateWithDict(
	example_input, dict)
assert(#compress_deflate_with_dict < #compress_deflate)
local decompress_deflate_with_dict = LibDeflate:DecompressDeflateWithDict(
	compress_deflate_with_dict, dict)
assert(decompress_deflate_with_dict == example_input)

-- Using the dictionary with zlib format, specifying compression level
local compress_zlib_with_dict = LibDeflate:CompressZlibWithDict(
	example_input, dict, {level = 9})
assert(#compress_zlib_with_dict < #compress_zlib)
local decompress_zlib_with_dict = LibDeflate:DecompressZlibWithDict(
	compress_zlib_with_dict, dict)
assert(decompress_zlib_with_dict == example_input)

================
File: Libs/vanilla/LibDeflate/lib.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Script file="LibDeflate.lua" />
</Ui>

================
File: Libs/vanilla/LibDeflate/LibDeflate.lua
================
--[[--
LibDeflate 1.0.2-release <br>
Pure Lua compressor and decompressor with high compression ratio using
DEFLATE/zlib format.

@file LibDeflate.lua
@author Haoqian He (Github: SafeteeWoW; World of Warcraft: Safetyy-Illidan(US))
@copyright LibDeflate <2018-2020> Haoqian He
@license zlib License

This library is implemented according to the following specifications. <br>
Report a bug if LibDeflate is not fully compliant with those specs. <br>
Both compressors and decompressors have been implemented in the library.<br>
1. RFC1950: DEFLATE Compressed Data Format Specification version 1.3 <br>
https://tools.ietf.org/html/rfc1951 <br>
2. RFC1951: ZLIB Compressed Data Format Specification version 3.3 <br>
https://tools.ietf.org/html/rfc1950 <br>

This library requires Lua 5.1/5.2/5.3/5.4 interpreter or LuaJIT v2.0+. <br>
This library does not have any dependencies. <br>
<br>
This file "LibDeflate.lua" is the only source file of
the library. <br>
Submit suggestions or report bugs to
https://github.com/safeteeWow/LibDeflate/issues
]]

--[[
zlib License

(C) 2018-2020 Haoqian He

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

License History:
1. GNU General Public License Version 3 in v1.0.0 and earlier versions.
2. GNU Lesser General Public License Version 3 in v1.0.1
3. the zlib License since v1.0.2

Credits and Disclaimer:
This library rewrites the code from the algorithm
and the ideas of the following projects,
and uses their code to help to test the correctness of this library,
but their code is not included directly in the library itself.
Their original licenses shall be comply when used.

1. zlib, by Jean-loup Gailly (compression) and Mark Adler (decompression).
	http://www.zlib.net/
	Licensed under zlib License. http://www.zlib.net/zlib_license.html
	For the compression algorithm.
2. puff, by Mark Adler. https://github.com/madler/zlib/tree/master/contrib/puff
	Licensed under zlib License. http://www.zlib.net/zlib_license.html
	For the decompression algorithm.
3. LibCompress, by jjsheets and Galmok of European Stormrage (Horde)
	https://www.wowace.com/projects/libcompress
	Licensed under GPLv2.
	https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
	For the code to create customized codec.
4. WeakAuras2,
	https://github.com/WeakAuras/WeakAuras2
	Licensed under GPLv2.
	For the 6bit encoding and decoding.
]]

--[[
	Curseforge auto-packaging replacements:

	Project Date: @project-date-iso@
	Project Hash: @project-hash@
	Project Version: @project-version@
--]]

local LibDeflate

do
  -- Semantic version. all lowercase.
  -- Suffix can be alpha1, alpha2, beta1, beta2, rc1, rc2, etc.
  -- NOTE: Two version numbers needs to modify.
  -- 1. On the top of LibDeflate.lua
  -- 2. _VERSION
  -- 3. _MINOR

  -- version to store the official version of LibDeflate
  local _VERSION = "1.0.2-release"

  -- When MAJOR is changed, I should name it as LibDeflate2
  local _MAJOR = "LibDeflate"

  -- Update this whenever a new version, for LibStub version registration.
  -- 0 : v0.x
  -- 1 : v1.0.0
  -- 2 : v1.0.1
  -- 3 : v1.0.2
  local _MINOR = 3

  local _COPYRIGHT =
      "LibDeflate " .. _VERSION
      .. " Copyright (C) 2018-2020 Haoqian He."
      .. " Licensed under the zlib License"

  -- Register in the World of Warcraft library "LibStub" if detected.
  if LibStub then
    local lib, minor = LibStub:GetLibrary( _MAJOR, true )
    if lib and minor and minor >= _MINOR then -- No need to update.
      return lib
    else                                      -- Update or first time register
      LibDeflate = LibStub:NewLibrary( _MAJOR, _MINOR )
      -- NOTE: It is important that new version has implemented
      -- all exported APIs and tables in the old version,
      -- so the old library is fully garbage collected,
      -- and we 100% ensure the backward compatibility.
    end
  else -- "LibStub" is not detected.
    LibDeflate = {}
  end

  LibDeflate._VERSION = _VERSION
  LibDeflate._MAJOR = _MAJOR
  LibDeflate._MINOR = _MINOR
  LibDeflate._COPYRIGHT = _COPYRIGHT
end

-- localize Lua api for faster access.
local assert = assert
local error = error
local pairs = pairs
local string_byte = string.byte
local string_char = string.char
local string_find = string.find
local string_gsub = string.gsub
local string_sub = string.sub
local table_concat = table.concat
local table_sort = table.sort
local tostring = tostring
local type = type
---@diagnostic disable-next-line: undefined-field
local mod = math.mod

-- Converts i to 2^i, (0<=i<=32)
-- This is used to implement bit left shift and bit right shift.
-- "x >> y" in C:   "(x-x%_pow2[y])/_pow2[y]" in Lua
-- "x << y" in C:   "x*_pow2[y]" in Lua
local _pow2 = {}

-- Converts any byte to a character, (0<=byte<=255)
local _byte_to_char = {}

-- _reverseBitsTbl[len][val] stores the bit reverse of
-- the number with bit length "len" and value "val"
-- For example, decimal number 6 with bits length 5 is binary 00110
-- It's reverse is binary 01100,
-- which is decimal 12 and 12 == _reverseBitsTbl[5][6]
-- 1<=len<=9, 0<=val<=2^len-1
-- The reason for 1<=len<=9 is that the max of min bitlen of huffman code
-- of a huffman alphabet is 9?
local _reverse_bits_tbl = {}

-- Convert a LZ77 length (3<=len<=258) to
-- a deflate literal/LZ77_length code (257<=code<=285)
local _length_to_deflate_code = {}

-- convert a LZ77 length (3<=len<=258) to
-- a deflate literal/LZ77_length code extra bits.
local _length_to_deflate_extra_bits = {}

-- Convert a LZ77 length (3<=len<=258) to
-- a deflate literal/LZ77_length code extra bit length.
local _length_to_deflate_extra_bitlen = {}

-- Convert a small LZ77 distance (1<=dist<=256) to a deflate code.
local _dist256_to_deflate_code = {}

-- Convert a small LZ77 distance (1<=dist<=256) to
-- a deflate distance code extra bits.
local _dist256_to_deflate_extra_bits = {}

-- Convert a small LZ77 distance (1<=dist<=256) to
-- a deflate distance code extra bit length.
local _dist256_to_deflate_extra_bitlen = {}

-- Convert a literal/LZ77_length deflate code to LZ77 base length
-- The key of the table is (code - 256), 257<=code<=285
local _literal_deflate_code_to_base_len = {
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258,
}

-- Convert a literal/LZ77_length deflate code to base LZ77 length extra bits
-- The key of the table is (code - 256), 257<=code<=285
local _literal_deflate_code_to_extra_bitlen = {
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
  3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,
}

-- Convert a distance deflate code to base LZ77 distance. (0<=code<=29)
local _dist_deflate_code_to_base_dist = {
  [ 0 ] = 1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
}

-- Convert a distance deflate code to LZ77 bits length. (0<=code<=29)
local _dist_deflate_code_to_extra_bitlen = {
  [ 0 ] = 0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
}

-- The code order of the first huffman header in the dynamic deflate block.
-- See the page 12 of RFC1951
local _rle_codes_huffman_bitlen_order = { 16, 17, 18,
  0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
}

-- The following tables are used by fixed deflate block.
-- The value of these tables are assigned at the bottom of the source.

-- The huffman code of the literal/LZ77_length deflate codes,
-- in fixed deflate block.
local _fix_block_literal_huffman_code

-- Convert huffman code of the literal/LZ77_length to deflate codes,
-- in fixed deflate block.
local _fix_block_literal_huffman_to_deflate_code

-- The bit length of the huffman code of literal/LZ77_length deflate codes,
-- in fixed deflate block.
local _fix_block_literal_huffman_bitlen

-- The count of each bit length of the literal/LZ77_length deflate codes,
-- in fixed deflate block.
local _fix_block_literal_huffman_bitlen_count

-- The huffman code of the distance deflate codes,
-- in fixed deflate block.
local _fix_block_dist_huffman_code

-- Convert huffman code of the distance to deflate codes,
-- in fixed deflate block.
local _fix_block_dist_huffman_to_deflate_code

-- The bit length of the huffman code of the distance deflate codes,
-- in fixed deflate block.
local _fix_block_dist_huffman_bitlen

-- The count of each bit length of the huffman code of
-- the distance deflate codes,
-- in fixed deflate block.
local _fix_block_dist_huffman_bitlen_count

for i = 0, 255 do
  _byte_to_char[ i ] = string_char( i )
end

do
  local pow = 1
  for i = 0, 32 do
    _pow2[ i ] = pow
    pow = pow * 2
  end
end

for i = 1, 9 do
  _reverse_bits_tbl[ i ] = {}
  for j = 0, _pow2[ i + 1 ] - 1 do
    local reverse = 0
    local value = j
    for _ = 1, i do
      -- The following line is equivalent to "res | (code %2)" in C.
      reverse = reverse - mod( reverse, 2 )
          + (((mod( reverse, 2 ) == 1) or (mod( value, 2 )) == 1) and 1 or 0)
      value = (value - mod( value, 2 )) / 2
      reverse = reverse * 2
    end
    _reverse_bits_tbl[ i ][ j ] = (reverse - mod( reverse, 2 )) / 2
  end
end

-- The source code is written according to the pattern in the numbers
-- in RFC1951 Page10.
do
  local a = 18
  local b = 16
  local c = 265
  local bitlen = 1
  for len = 3, 258 do
    if len <= 10 then
      _length_to_deflate_code[ len ] = len + 254
      _length_to_deflate_extra_bitlen[ len ] = 0
    elseif len == 258 then
      _length_to_deflate_code[ len ] = 285
      _length_to_deflate_extra_bitlen[ len ] = 0
    else
      if len > a then
        a = a + b
        b = b * 2
        c = c + 4
        bitlen = bitlen + 1
      end
      local t = len - a - 1 + b / 2
      _length_to_deflate_code[ len ] = (t - (mod( t, b / 8 ))) / (b / 8) + c
      _length_to_deflate_extra_bitlen[ len ] = bitlen
      _length_to_deflate_extra_bits[ len ] = mod( t, b / 8 )
    end
  end
end

-- The source code is written according to the pattern in the numbers
-- in RFC1951 Page11.
do
  _dist256_to_deflate_code[ 1 ] = 0
  _dist256_to_deflate_code[ 2 ] = 1
  _dist256_to_deflate_extra_bitlen[ 1 ] = 0
  _dist256_to_deflate_extra_bitlen[ 2 ] = 0

  local a = 3
  local b = 4
  local code = 2
  local bitlen = 0
  for dist = 3, 256 do
    if dist > b then
      a = a * 2
      b = b * 2
      code = code + 2
      bitlen = bitlen + 1
    end
    _dist256_to_deflate_code[ dist ] = (dist <= a) and code or (code + 1)
    _dist256_to_deflate_extra_bitlen[ dist ] = (bitlen < 0) and 0 or bitlen
    if b >= 8 then
      _dist256_to_deflate_extra_bits[ dist ] = mod( dist - b / 2 - 1, b / 4 )
    end
  end
end

--- Calculate the Adler-32 checksum of the string. <br>
-- See RFC1950 Page 9 https://tools.ietf.org/html/rfc1950 for the
-- definition of Adler-32 checksum.
-- @param str [string] the input string to calcuate its Adler-32 checksum.
-- @return [integer] The Adler-32 checksum, which is greater or equal to 0,
-- and less than 2^32 (4294967296).
function LibDeflate:Adler32( str )
  -- This function is loop unrolled by better performance.
  --
  -- Here is the minimum code:
  --
  -- local a = 1
  -- local b = 0
  -- for i=1, #str do
  -- 		local s = string.byte(str, i, i)
  -- 		a = (a+s)%65521
  -- 		b = (b+a)%65521
  -- 		end
  -- return b*65536+a
  if type( str ) ~= "string" then
    error( string.format( "Usage: LibDeflate:Adler32(str):"
      .. " 'str' - string expected got '%s'.", type( str ) ), 2 )
  end
  local strlen = string.len( str )

  local i = 1
  local a = 1
  local b = 0
  while i <= strlen - 15 do
    local x1, x2, x3, x4, x5, x6, x7, x8,
    x9, x10, x11, x12, x13, x14, x15, x16 = string_byte( str, i, i + 15 )
    b = mod( b + 16 * a + 16 * x1 + 15 * x2 + 14 * x3 + 13 * x4 + 12 * x5 + 11 * x6 + 10 * x7 + 9 * x8 + 8 * x9
      + 7 * x10 + 6 * x11 + 5 * x12 + 4 * x13 + 3 * x14 + 2 * x15 + x16, 65521 )
    a = mod( a + x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16, 65521 )
    i = i + 16
  end
  while (i <= strlen) do
    local x = string_byte( str, i, i )
    a = mod( a + x, 65521 )
    b = mod( b + a, 65521 )
    i = i + 1
  end
  return mod( b * 65536 + a, 4294967296 )
end

-- Compare adler32 checksum.
-- adler32 should be compared with a mod to avoid sign problem
-- 4072834167 (unsigned) is the same adler32 as -222133129
local function IsEqualAdler32( actual, expected )
  return mod( actual, 4294967296 ) == mod( expected, 4294967296 )
end

--- Create a preset dictionary.
--
-- This function is not fast, and the memory consumption of the produced
-- dictionary is about 50 times of the input string. Therefore, it is suggestted
-- to run this function only once in your program.
--
-- It is very important to know that if you do use a preset dictionary,
-- compressors and decompressors MUST USE THE SAME dictionary. That is,
-- dictionary must be created using the same string. If you update your program
-- with a new dictionary, people with the old version won't be able to transmit
-- data with people with the new version. Therefore, changing the dictionary
-- must be very careful.
--
-- The parameters "strlen" and "adler32" add a layer of verification to ensure
-- the parameter "str" is not modified unintentionally during the program
-- development.
--
-- @usage local dict_str = "1234567890"
--
-- -- print(dict_str:len(), LibDeflate:Adler32(dict_str))
-- -- Hardcode the print result below to verify it to avoid acciently
-- -- modification of 'str' during the program development.
-- -- string length: 10, Adler-32: 187433486,
-- -- Don't calculate string length and its Adler-32 at run-time.
--
-- local dict = LibDeflate:CreateDictionary(dict_str, 10, 187433486)
--
-- @param str [string] The string used as the preset dictionary. <br>
-- You should put stuffs that frequently appears in the dictionary
-- string and preferablely put more frequently appeared stuffs toward the end
-- of the string. <br>
-- Empty string and string longer than 32768 bytes are not allowed.
-- @param strlen [integer] The length of 'str'. Please pass in this parameter
-- as a hardcoded constant, in order to verify the content of 'str'. The value
-- of this parameter should be known before your program runs.
-- @param adler32 [integer] The Adler-32 checksum of 'str'. Please pass in this
-- parameter as a hardcoded constant, in order to verify the content of 'str'.
-- The value of this parameter should be known before your program runs.
-- @return  [table] The dictionary used for preset dictionary compression and
-- decompression.
-- @raise error if 'strlen' does not match the length of 'str',
-- or if 'adler32' does not match the Adler-32 checksum of 'str'.
function LibDeflate:CreateDictionary( str, strlen, adler32 )
  if type( str ) ~= "string" then
    error( string.format( "Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
      .. " 'str' - string expected got '%s'.", type( str ) ), 2 )
  end
  if type( strlen ) ~= "number" then
    error( string.format( "Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
      .. " 'strlen' - number expected got '%s'.", type( strlen ) ), 2 )
  end
  if type( adler32 ) ~= "number" then
    error( string.format( "Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
      .. " 'adler32' - number expected got '%s'.", type( adler32 ) ), 2 )
  end
  if strlen ~= string.len( str ) then
    error( string.format( "Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
      .. " 'strlen' does not match the actual length of 'str'."
      .. " 'strlen': %u, '#str': %u ."
      .. " Please check if 'str' is modified unintentionally.", strlen, string.len( str ) ) )
  end
  if strlen == 0 then
    error( ("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
      .. " 'str' - Empty string is not allowed."), 2 )
  end
  if strlen > 32768 then
    error( string.format( "Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
      .. " 'str' - string longer than 32768 bytes is not allowed."
      .. " Got %d bytes.", strlen ), 2 )
  end
  local actual_adler32 = self:Adler32( str )
  if not IsEqualAdler32( adler32, actual_adler32 ) then
    error( string.format( "Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
      .. " 'adler32' does not match the actual adler32 of 'str'."
      .. " 'adler32': %u, 'Adler32(str)': %u ."
      .. " Please check if 'str' is modified unintentionally.", adler32, actual_adler32 ) )
  end

  local dictionary = {}
  dictionary.adler32 = adler32
  dictionary.hash_tables = {}
  dictionary.string_table = {}
  dictionary.strlen = strlen
  local string_table = dictionary.string_table
  local hash_tables = dictionary.hash_tables
  string_table[ 1 ] = string_byte( str, 1, 1 )
  string_table[ 2 ] = string_byte( str, 2, 2 )
  if strlen >= 3 then
    local i = 1
    local hash = string_table[ 1 ] * 256 + string_table[ 2 ]
    while i <= strlen - 2 - 3 do
      local x1, x2, x3, x4 = string_byte( str, i + 2, i + 5 )
      string_table[ i + 2 ] = x1
      string_table[ i + 3 ] = x2
      string_table[ i + 4 ] = x3
      string_table[ i + 5 ] = x4
      hash = mod( hash * 256 + x1, 16777216 )
      local t = hash_tables[ hash ]
      if not t then
        t = {}; hash_tables[ hash ] = t
      end
      t[ table.getn( t ) + 1 ] = i - strlen
      i = i + 1
      hash = mod( hash * 256 + x2, 16777216 )
      t = hash_tables[ hash ]
      if not t then
        t = {}; hash_tables[ hash ] = t
      end
      t[ table.getn( t ) + 1 ] = i - strlen
      i = i + 1
      hash = mod( hash * 256 + x3, 16777216 )
      t = hash_tables[ hash ]
      if not t then
        t = {}; hash_tables[ hash ] = t
      end
      t[ table.getn( t ) + 1 ] = i - strlen
      i = i + 1
      hash = mod( hash * 256 + x4, 16777216 )
      t = hash_tables[ hash ]
      if not t then
        t = {}; hash_tables[ hash ] = t
      end
      t[ table.getn( t ) + 1 ] = i - strlen
      i = i + 1
    end
    while i <= strlen - 2 do
      local x = string_byte( str, i + 2 )
      string_table[ i + 2 ] = x
      hash = mod( hash * 256 + x, 16777216 )
      local t = hash_tables[ hash ]
      if not t then
        t = {}; hash_tables[ hash ] = t
      end
      t[ table.getn( t ) + 1 ] = i - strlen
      i = i + 1
    end
  end
  return dictionary
end

-- Check if the dictionary is valid.
-- @param dictionary The preset dictionary for compression and decompression.
-- @return true if valid, false if not valid.
-- @return if not valid, the error message.
local function IsValidDictionary( dictionary )
  if type( dictionary ) ~= "table" then
    return false, string.format( "'dictionary' - table expected got '%s'.", type( dictionary ) )
  end
  if type( dictionary.adler32 ) ~= "number"
      or type( dictionary.string_table ) ~= "table"
      or type( dictionary.strlen ) ~= "number"
      or dictionary.strlen <= 0
      or dictionary.strlen > 32768
      or dictionary.strlen ~= table.getn( dictionary.string_table )
      or type( dictionary.hash_tables ) ~= "table"
  then
    return false, "'dictionary' - corrupted dictionary."
  end
  return true, ""
end

--[[
	key of the configuration table is the compression level,
	and its value stores the compression setting.
	These numbers come from zlib source code.

	Higher compression level usually means better compression.
	(Because LibDeflate uses a simplified version of zlib algorithm,
	there is no guarantee that higher compression level does not create
	bigger file than lower level, but I can say it's 99% likely)

	Be careful with the high compression level. This is a pure lua
	implementation compressor/decompressor, which is significant slower than
	a C/C++ equivalant compressor/decompressor. Very high compression level
	costs significant more CPU time, and usually compression size won't be
	significant smaller when you increase compression level by 1, when the
	level is already very high. Benchmark yourself if you can afford it.

	See also https://github.com/madler/zlib/blob/master/doc/algorithm.txt,
	https://github.com/madler/zlib/blob/master/deflate.c for more information.

	The meaning of each field:
	@field 1 use_lazy_evaluation:
		true/false. Whether the program uses lazy evaluation.
		See what is "lazy evaluation" in the link above.
		lazy_evaluation improves ratio, but relatively slow.
	@field 2 good_prev_length:
		Only effective if lazy is set, Only use 1/4 of max_chain,
		if prev length of lazy match is above this.
	@field 3 max_insert_length/max_lazy_match:
		If not using lazy evaluation,
		insert new strings in the hash table only if the match length is not
		greater than this length.
		If using lazy evaluation, only continue lazy evaluation,
		if previous match length is strictly smaller than this value.
	@field 4 nice_length:
		Number. Don't continue to go down the hash chain,
		if match length is above this.
	@field 5 max_chain:
		Number. The maximum number of hash chains we look.
--]]
local _compression_level_configs = {
  [ 0 ] = { false, nil, 0, 0, 0 },      -- level 0, no compression
  [ 1 ] = { false, nil, 4, 8, 4 },      -- level 1, similar to zlib level 1
  [ 2 ] = { false, nil, 5, 18, 8 },     -- level 2, similar to zlib level 2
  [ 3 ] = { false, nil, 6, 32, 32 },    -- level 3, similar to zlib level 3
  [ 4 ] = { true, 4, 4, 16, 16 },       -- level 4, similar to zlib level 4
  [ 5 ] = { true, 8, 16, 32, 32 },      -- level 5, similar to zlib level 5
  [ 6 ] = { true, 8, 16, 128, 128 },    -- level 6, similar to zlib level 6
  [ 7 ] = { true, 8, 32, 128, 256 },    -- (SLOW) level 7, similar to zlib level 7
  [ 8 ] = { true, 32, 128, 258, 1024 }, --(SLOW) level 8,similar to zlib level 8
  [ 9 ] = { true, 32, 258, 258, 4096 },
  -- (VERY SLOW) level 9, similar to zlib level 9
}

-- Check if the compression/decompression arguments is valid
-- @param str The input string.
-- @param check_dictionary if true, check if dictionary is valid.
-- @param dictionary The preset dictionary for compression and decompression.
-- @param check_configs if true, check if config is valid.
-- @param configs The compression configuration table
-- @return true if valid, false if not valid.
-- @return if not valid, the error message.
local function IsValidArguments( str,
                                 check_dictionary, dictionary,
                                 check_configs, configs )
  if type( str ) ~= "string" then
    return false, string.format( "'str' - string expected got '%s'.", type( str ) )
  end
  if check_dictionary then
    local dict_valid, dict_err = IsValidDictionary( dictionary )
    if not dict_valid then
      return false, dict_err
    end
  end
  if check_configs then
    local type_configs = type( configs )
    if type_configs ~= "nil" and type_configs ~= "table" then
      return false, string.format( "'configs' - nil or table expected got '%s'.", type( configs ) )
    end
    if type_configs == "table" then
      for k, v in pairs( configs ) do
        if k ~= "level" and k ~= "strategy" then
          return false,
              string.format( "'configs' - unsupported table key in the configs: '%s'.", k )
        elseif k == "level" and not _compression_level_configs[ v ] then
          return false,
              string.format( "'configs' - unsupported 'level': %s.", tostring( v ) )
        elseif k == "strategy" and v ~= "fixed" and v ~= "huffman_only"
            and v ~= "dynamic" then
          -- random_block_type is for testing purpose
          return false, string.format( "'configs' - unsupported 'strategy': '%s'.", tostring( v ) )
        end
      end
    end
  end
  return true, ""
end



--[[ --------------------------------------------------------------------------
	Compress code
--]] --------------------------------------------------------------------------

-- partial flush to save memory
local _FLUSH_MODE_MEMORY_CLEANUP = 0
-- full flush with partial bytes
local _FLUSH_MODE_OUTPUT = 1
-- write bytes to get to byte boundary
local _FLUSH_MODE_BYTE_BOUNDARY = 2
-- no flush, just get num of bits written so far
local _FLUSH_MODE_NO_FLUSH = 3

--[[
	Create an empty writer to easily write stuffs as the unit of bits.
	Return values:
	1. WriteBits(code, bitlen):
	2. WriteString(str):
	3. Flush(mode):
--]]
local function CreateWriter()
  local buffer_size = 0
  local cache = 0
  local cache_bitlen = 0
  local total_bitlen = 0
  local buffer = {}
  -- When buffer is big enough, flush into result_buffer to save memory.
  local result_buffer = {}

  -- Write bits with value "value" and bit length of "bitlen" into writer.
  -- @param value: The value being written
  -- @param bitlen: The bit length of "value"
  -- @return nil
  local function WriteBits( value, bitlen )
    cache = cache + value * _pow2[ cache_bitlen ]
    cache_bitlen = cache_bitlen + bitlen
    total_bitlen = total_bitlen + bitlen
    -- Only bulk to buffer every 4 bytes. This is quicker.
    if cache_bitlen >= 32 then
      buffer_size = buffer_size + 1
      buffer[ buffer_size ] =
          _byte_to_char[ mod( cache, 256 ) ]
          .. _byte_to_char[ mod( (cache - mod( cache, 256 )) / 256, 256 ) ]
          .. _byte_to_char[ mod( (cache - mod( cache, 65536 )) / 65536, 256 ) ]
          .. _byte_to_char[ mod( (cache - mod( cache, 16777216 )) / 16777216, 256 ) ]
      local rshift_mask = _pow2[ 32 - cache_bitlen + bitlen ]
      cache = (value - mod( value, rshift_mask )) / rshift_mask
      cache_bitlen = cache_bitlen - 32
    end
  end

  -- Write the entire string into the writer.
  -- @param str The string being written
  -- @return nil
  local function WriteString( str )
    for _ = 1, cache_bitlen, 8 do
      buffer_size = buffer_size + 1
      buffer[ buffer_size ] = string_char( mod( cache, 256 ) )
      cache = (cache - mod( cache, 256 )) / 256
    end
    cache_bitlen = 0
    buffer_size = buffer_size + 1
    buffer[ buffer_size ] = str
    total_bitlen = total_bitlen + string.len( str ) * 8
  end

  -- Flush current stuffs in the writer and return it.
  -- This operation will free most of the memory.
  -- @param mode See the descrtion of the constant and the source code.
  -- @return The total number of bits stored in the writer right now.
  -- for byte boundary mode, it includes the padding bits.
  -- for output mode, it does not include padding bits.
  -- @return Return the outputs if mode is output.
  local function FlushWriter( mode )
    if mode == _FLUSH_MODE_NO_FLUSH then
      return total_bitlen
    end

    if mode == _FLUSH_MODE_OUTPUT
        or mode == _FLUSH_MODE_BYTE_BOUNDARY then
      -- Full flush, also output cache.
      -- Need to pad some bits if cache_bitlen is not multiple of 8.
      local padding_bitlen = mod( 8 - mod( cache_bitlen, 8 ), 8 )

      if cache_bitlen > 0 then
        -- padding with all 1 bits, mainly because "\000" is not
        -- good to be tranmitted. I do this so "\000" is a little bit
        -- less frequent.
        cache = cache - _pow2[ cache_bitlen ]
            + _pow2[ cache_bitlen + padding_bitlen ]
        for _ = 1, cache_bitlen, 8 do
          buffer_size = buffer_size + 1
          buffer[ buffer_size ] = _byte_to_char[ mod( cache, 256 ) ]
          cache = (cache - mod( cache, 256 )) / 256
        end

        cache = 0
        cache_bitlen = 0
      end
      if mode == _FLUSH_MODE_BYTE_BOUNDARY then
        total_bitlen = total_bitlen + padding_bitlen
        return total_bitlen
      end
    end

    local flushed = table_concat( buffer )
    buffer = {}
    buffer_size = 0
    result_buffer[ table.getn( result_buffer ) + 1 ] = flushed

    if mode == _FLUSH_MODE_MEMORY_CLEANUP then
      return total_bitlen
    else
      return total_bitlen, table_concat( result_buffer )
    end
  end

  return WriteBits, WriteString, FlushWriter
end

-- Push an element into a max heap
-- @param heap A max heap whose max element is at index 1.
-- @param e The element to be pushed. Assume element "e" is a table
--  and comparison is done via its first entry e[1]
-- @param heap_size current number of elements in the heap.
--  NOTE: There may be some garbage stored in
--  heap[heap_size+1], heap[heap_size+2], etc..
-- @return nil
local function MinHeapPush( heap, e, heap_size )
  heap_size = heap_size + 1
  heap[ heap_size ] = e
  local value = e[ 1 ]
  local pos = heap_size
  local parent_pos = (pos - mod( pos, 2 )) / 2

  while (parent_pos >= 1 and heap[ parent_pos ][ 1 ] > value) do
    local t = heap[ parent_pos ]
    heap[ parent_pos ] = e
    heap[ pos ] = t
    pos = parent_pos
    parent_pos = (parent_pos - mod( parent_pos, 2 )) / 2
  end
end

-- Pop an element from a max heap
-- @param heap A max heap whose max element is at index 1.
-- @param heap_size current number of elements in the heap.
-- @return the poped element
-- Note: This function does not change table size of "heap" to save CPU time.
local function MinHeapPop( heap, heap_size )
  local top = heap[ 1 ]
  local e = heap[ heap_size ]
  local value = e[ 1 ]
  heap[ 1 ] = e
  heap[ heap_size ] = top
  heap_size = heap_size - 1

  local pos = 1
  local left_child_pos = pos * 2
  local right_child_pos = left_child_pos + 1

  while (left_child_pos <= heap_size) do
    local left_child = heap[ left_child_pos ]
    if (right_child_pos <= heap_size
          and heap[ right_child_pos ][ 1 ] < left_child[ 1 ]) then
      local right_child = heap[ right_child_pos ]
      if right_child[ 1 ] < value then
        heap[ right_child_pos ] = e
        heap[ pos ] = right_child
        pos = right_child_pos
        left_child_pos = pos * 2
        right_child_pos = left_child_pos + 1
      else
        break
      end
    else
      if left_child[ 1 ] < value then
        heap[ left_child_pos ] = e
        heap[ pos ] = left_child
        pos = left_child_pos
        left_child_pos = pos * 2
        right_child_pos = left_child_pos + 1
      else
        break
      end
    end
  end

  return top
end

-- Deflate defines a special huffman tree, which is unique once the bit length
-- of huffman code of all symbols are known.
-- @param bitlen_count Number of symbols with a specific bitlen
-- @param symbol_bitlen The bit length of a symbol
-- @param max_symbol The max symbol among all symbols,
--		which is (number of symbols - 1)
-- @param max_bitlen The max huffman bit length among all symbols.
-- @return The huffman code of all symbols.
local function GetHuffmanCodeFromBitlen( bitlen_counts, symbol_bitlens
    , max_symbol, max_bitlen )
  local huffman_code = 0
  local next_codes = {}
  local symbol_huffman_codes = {}
  for bitlen = 1, max_bitlen do
    huffman_code = (huffman_code + (bitlen_counts[ bitlen - 1 ] or 0)) * 2
    next_codes[ bitlen ] = huffman_code
  end
  for symbol = 0, max_symbol do
    local bitlen = symbol_bitlens[ symbol ]
    if bitlen then
      huffman_code = next_codes[ bitlen ]
      next_codes[ bitlen ] = huffman_code + 1

      -- Reverse the bits of huffman code,
      -- because most signifant bits of huffman code
      -- is stored first into the compressed data.
      -- @see RFC1951 Page5 Section 3.1.1
      if bitlen <= 9 then -- Have cached reverse for small bitlen.
        symbol_huffman_codes[ symbol ] =
            _reverse_bits_tbl[ bitlen ][ huffman_code ]
      else
        local reverse = 0
        for _ = 1, bitlen do
          reverse = reverse - mod( reverse, 2 )
              + (((mod( reverse, 2 ) == 1)
                or mod( huffman_code, 2 ) == 1) and 1 or 0)
          huffman_code = (huffman_code - mod( huffman_code, 2 )) / 2
          reverse = reverse * 2
        end
        symbol_huffman_codes[ symbol ] = (reverse - mod( reverse, 2 )) / 2
      end
    end
  end
  return symbol_huffman_codes
end

-- A helper function to sort heap elements
-- a[1], b[1] is the huffman frequency
-- a[2], b[2] is the symbol value.
local function SortByFirstThenSecond( a, b )
  return a[ 1 ] < b[ 1 ] or
      (a[ 1 ] == b[ 1 ] and a[ 2 ] < b[ 2 ])
end

-- Calculate the huffman bit length and huffman code.
-- @param symbol_count: A table whose table key is the symbol, and table value
--		is the symbol frenquency (nil means 0 frequency).
-- @param max_bitlen: See description of return value.
-- @param max_symbol: The maximum symbol
-- @return a table whose key is the symbol, and the value is the huffman bit
--		bit length. We guarantee that all bit length <= max_bitlen.
--		For 0<=symbol<=max_symbol, table value could be nil if the frequency
--		of the symbol is 0 or nil.
-- @return a table whose key is the symbol, and the value is the huffman code.
-- @return a number indicating the maximum symbol whose bitlen is not 0.
local function GetHuffmanBitlenAndCode( symbol_counts, max_bitlen, max_symbol )
  local heap_size
  local max_non_zero_bitlen_symbol = -1
  local leafs = {}
  local heap = {}
  local symbol_bitlens = {}
  local symbol_codes = {}
  local bitlen_counts = {}

  --[[
		tree[1]: weight, temporarily used as parent and bitLengths
		tree[2]: symbol
		tree[3]: left child
		tree[4]: right child
	--]]
  local number_unique_symbols = 0
  for symbol, count in pairs( symbol_counts ) do
    number_unique_symbols = number_unique_symbols + 1
    leafs[ number_unique_symbols ] = { count, symbol }
  end

  if (number_unique_symbols == 0) then
    -- no code.
    return {}, {}, -1
  elseif (number_unique_symbols == 1) then
    -- Only one code. In this case, its huffman code
    -- needs to be assigned as 0, and bit length is 1.
    -- This is the only case that the return result
    -- represents an imcomplete huffman tree.
    local symbol = leafs[ 1 ][ 2 ]
    symbol_bitlens[ symbol ] = 1
    symbol_codes[ symbol ] = 0
    return symbol_bitlens, symbol_codes, symbol
  else
    table_sort( leafs, SortByFirstThenSecond )
    heap_size = number_unique_symbols
    for i = 1, heap_size do
      heap[ i ] = leafs[ i ]
    end

    while (heap_size > 1) do
      -- Note: pop does not change table size of heap
      local leftChild = MinHeapPop( heap, heap_size )
      heap_size = heap_size - 1
      local rightChild = MinHeapPop( heap, heap_size )
      heap_size = heap_size - 1
      local newNode =
      { leftChild[ 1 ] + rightChild[ 1 ], -1, leftChild, rightChild }
      MinHeapPush( heap, newNode, heap_size )
      heap_size = heap_size + 1
    end

    -- Number of leafs whose bit length is greater than max_len.
    local number_bitlen_overflow = 0

    -- Calculate bit length of all nodes
    local fifo = { heap[ 1 ], 0, 0, 0 } -- preallocate some spaces.
    local fifo_size = 1
    local index = 1
    heap[ 1 ][ 1 ] = 0
    while (index <= fifo_size) do -- Breath first search
      local e = fifo[ index ]
      local bitlen = e[ 1 ]
      local symbol = e[ 2 ]
      local left_child = e[ 3 ]
      local right_child = e[ 4 ]
      if left_child then
        fifo_size = fifo_size + 1
        fifo[ fifo_size ] = left_child
        left_child[ 1 ] = bitlen + 1
      end
      if right_child then
        fifo_size = fifo_size + 1
        fifo[ fifo_size ] = right_child
        right_child[ 1 ] = bitlen + 1
      end
      index = index + 1

      if (bitlen > max_bitlen) then
        number_bitlen_overflow = number_bitlen_overflow + 1
        bitlen = max_bitlen
      end
      if symbol >= 0 then
        symbol_bitlens[ symbol ] = bitlen
        max_non_zero_bitlen_symbol =
            (symbol > max_non_zero_bitlen_symbol)
            and symbol or max_non_zero_bitlen_symbol
        bitlen_counts[ bitlen ] = (bitlen_counts[ bitlen ] or 0) + 1
      end
    end

    -- Resolve bit length overflow
    -- @see ZLib/trees.c:gen_bitlen(s, desc), for reference
    if (number_bitlen_overflow > 0) then
      repeat
        local bitlen = max_bitlen - 1
        while ((bitlen_counts[ bitlen ] or 0) == 0) do
          bitlen = bitlen - 1
        end
        -- move one leaf down the tree
        bitlen_counts[ bitlen ] = bitlen_counts[ bitlen ] - 1
        -- move one overflow item as its brother
        bitlen_counts[ bitlen + 1 ] = (bitlen_counts[ bitlen + 1 ] or 0) + 2
        bitlen_counts[ max_bitlen ] = bitlen_counts[ max_bitlen ] - 1
        number_bitlen_overflow = number_bitlen_overflow - 2
      until (number_bitlen_overflow <= 0)

      index = 1
      for bitlen = max_bitlen, 1, -1 do
        local n = bitlen_counts[ bitlen ] or 0
        while (n > 0) do
          local symbol = leafs[ index ][ 2 ]
          symbol_bitlens[ symbol ] = bitlen
          n = n - 1
          index = index + 1
        end
      end
    end

    symbol_codes = GetHuffmanCodeFromBitlen( bitlen_counts, symbol_bitlens,
      max_symbol, max_bitlen )
    return symbol_bitlens, symbol_codes, max_non_zero_bitlen_symbol
  end
end

-- Calculate the first huffman header in the dynamic huffman block
-- @see RFC1951 Page 12
-- @param lcode_bitlen: The huffman bit length of literal/LZ77_length.
-- @param max_non_zero_bitlen_lcode: The maximum literal/LZ77_length symbol
--		whose huffman bit length is not zero.
-- @param dcode_bitlen: The huffman bit length of LZ77 distance.
-- @param max_non_zero_bitlen_dcode: The maximum LZ77 distance symbol
--		whose huffman bit length is not zero.
-- @return The run length encoded codes.
-- @return The extra bits. One entry for each rle code that needs extra bits.
--		(code == 16 or 17 or 18).
-- @return The count of appearance of each rle codes.
local function RunLengthEncodeHuffmanBitlen(
    lcode_bitlens,
    max_non_zero_bitlen_lcode,
    dcode_bitlens,
    max_non_zero_bitlen_dcode )
  local rle_code_tblsize = 0
  local rle_codes = {}
  local rle_code_counts = {}
  local rle_extra_bits_tblsize = 0
  local rle_extra_bits = {}
  local prev = nil
  local count = 0

  -- If there is no distance code, assume one distance code of bit length 0.
  -- RFC1951: One distance code of zero bits means that
  -- there are no distance codes used at all (the data is all literals).
  max_non_zero_bitlen_dcode = (max_non_zero_bitlen_dcode < 0)
      and 0 or max_non_zero_bitlen_dcode
  local max_code = max_non_zero_bitlen_lcode + max_non_zero_bitlen_dcode + 1

  for code = 0, max_code + 1 do
    local len = (code <= max_non_zero_bitlen_lcode)
        and (lcode_bitlens[ code ] or 0)
        or ((code <= max_code)
          and (dcode_bitlens[ code - max_non_zero_bitlen_lcode - 1 ] or 0) or nil)
    if len == prev then
      count = count + 1
      if len ~= 0 and count == 6 then
        rle_code_tblsize = rle_code_tblsize + 1
        rle_codes[ rle_code_tblsize ] = 16
        rle_extra_bits_tblsize = rle_extra_bits_tblsize + 1
        rle_extra_bits[ rle_extra_bits_tblsize ] = 3
        rle_code_counts[ 16 ] = (rle_code_counts[ 16 ] or 0) + 1
        count = 0
      elseif len == 0 and count == 138 then
        rle_code_tblsize = rle_code_tblsize + 1
        rle_codes[ rle_code_tblsize ] = 18
        rle_extra_bits_tblsize = rle_extra_bits_tblsize + 1
        rle_extra_bits[ rle_extra_bits_tblsize ] = 127
        rle_code_counts[ 18 ] = (rle_code_counts[ 18 ] or 0) + 1
        count = 0
      end
    else
      if count == 1 then
        rle_code_tblsize = rle_code_tblsize + 1
        rle_codes[ rle_code_tblsize ] = prev
        rle_code_counts[ prev ] = (rle_code_counts[ prev ] or 0) + 1
      elseif count == 2 then
        rle_code_tblsize = rle_code_tblsize + 1
        rle_codes[ rle_code_tblsize ] = prev
        rle_code_tblsize = rle_code_tblsize + 1
        rle_codes[ rle_code_tblsize ] = prev
        rle_code_counts[ prev ] = (rle_code_counts[ prev ] or 0) + 2
      elseif count >= 3 then
        rle_code_tblsize = rle_code_tblsize + 1
        local rleCode = (prev ~= 0) and 16 or (count <= 10 and 17 or 18)
        rle_codes[ rle_code_tblsize ] = rleCode
        rle_code_counts[ rleCode ] = (rle_code_counts[ rleCode ] or 0) + 1
        rle_extra_bits_tblsize = rle_extra_bits_tblsize + 1
        rle_extra_bits[ rle_extra_bits_tblsize ] =
            (count <= 10) and (count - 3) or (count - 11)
      end

      prev = len
      if len and len ~= 0 then
        rle_code_tblsize = rle_code_tblsize + 1
        rle_codes[ rle_code_tblsize ] = len
        rle_code_counts[ len ] = (rle_code_counts[ len ] or 0) + 1
        count = 0
      else
        count = 1
      end
    end
  end

  return rle_codes, rle_extra_bits, rle_code_counts
end

-- Load the string into a table, in order to speed up LZ77.
-- Loop unrolled 16 times to speed this function up.
-- @param str The string to be loaded.
-- @param t The load destination
-- @param start str[index] will be the first character to be loaded.
-- @param end str[index] will be the last character to be loaded
-- @param offset str[index] will be loaded into t[index-offset]
-- @return t
local function LoadStringToTable( str, t, start, stop, offset )
  local i = start - offset
  while i <= stop - 15 - offset do
    t[ i ], t[ i + 1 ], t[ i + 2 ], t[ i + 3 ], t[ i + 4 ], t[ i + 5 ], t[ i + 6 ], t[ i + 7 ], t[ i + 8 ],
    t[ i + 9 ], t[ i + 10 ], t[ i + 11 ], t[ i + 12 ], t[ i + 13 ], t[ i + 14 ], t[ i + 15 ] =
        string_byte( str, i + offset, i + 15 + offset )
    i = i + 16
  end
  while (i <= stop - offset) do
    t[ i ] = string_byte( str, i + offset, i + offset )
    i = i + 1
  end
  return t
end

-- Do LZ77 process. This function uses the majority of the CPU time.
-- @see zlib/deflate.c:deflate_fast(), zlib/deflate.c:deflate_slow()
-- @see https://github.com/madler/zlib/blob/master/doc/algorithm.txt
-- This function uses the algorithms used above. You should read the
-- algorithm.txt above to understand what is the hash function and the
-- lazy evaluation.
--
-- The special optimization used here is hash functions used here.
-- The hash function is just the multiplication of the three consective
-- characters. So if the hash matches, it guarantees 3 characters are matched.
-- This optimization can be implemented because Lua table is a hash table.
--
-- @param level integer that describes compression level.
-- @param string_table table that stores the value of string to be compressed.
--			The index of this table starts from 1.
--			The caller needs to make sure all values needed by this function
--			are loaded.
--			Assume "str" is the origin input string into the compressor
--			str[block_start]..str[block_end+3] needs to be loaded into
--			string_table[block_start-offset]..string_table[block_end-offset]
--			If dictionary is presented, the last 258 bytes of the dictionary
--			needs to be loaded into sing_table[-257..0]
--			(See more in the description of offset.)
-- @param hash_tables. The table key is the hash value (0<=hash<=16777216=256^3)
--			The table value is an array0 that stores the indexes of the
--			input data string to be compressed, such that
--			hash == str[index]*str[index+1]*str[index+2]
--			Indexes are ordered in this array.
-- @param block_start The indexes of the input data string to be compressed.
--				that starts the LZ77 block.
-- @param block_end The indexes of the input data string to be compressed.
--				that stores the LZ77 block.
-- @param offset str[index] is stored in string_table[index-offset],
--			This offset is mainly an optimization to limit the index
--			of string_table, so lua can access this table quicker.
-- @param dictionary See LibDeflate:CreateDictionary
-- @return literal/LZ77_length deflate codes.
-- @return the extra bits of literal/LZ77_length deflate codes.
-- @return the count of each literal/LZ77 deflate code.
-- @return LZ77 distance deflate codes.
-- @return the extra bits of LZ77 distance deflate codes.
-- @return the count of each LZ77 distance deflate code.
local function GetBlockLZ77Result( level, string_table, hash_tables, block_start,
                                   block_end, offset, dictionary )
  local config = _compression_level_configs[ level ]
  local config_use_lazy
  , config_good_prev_length
  , config_max_lazy_match
  , config_nice_length
  , config_max_hash_chain =
      config[ 1 ], config[ 2 ], config[ 3 ], config[ 4 ], config[ 5 ]

  local config_max_insert_length = (not config_use_lazy)
      and config_max_lazy_match or 2147483646
  local config_good_hash_chain =
      (config_max_hash_chain - mod( config_max_hash_chain, 4 ) / 4)

  local hash

  local dict_hash_tables
  local dict_string_table
  local dict_string_len = 0

  if dictionary then
    dict_hash_tables = dictionary.hash_tables
    dict_string_table = dictionary.string_table
    dict_string_len = dictionary.strlen
    assert( block_start == 1 )
    if block_end >= block_start and dict_string_len >= 2 then
      hash = dict_string_table[ dict_string_len - 1 ] * 65536
          + dict_string_table[ dict_string_len ] * 256 + string_table[ 1 ]
      local t = hash_tables[ hash ]
      if not t then
        t = {}; hash_tables[ hash ] = t
      end
      t[ table.getn( t ) + 1 ] = -1
    end
    if block_end >= block_start + 1 and dict_string_len >= 1 then
      hash = dict_string_table[ dict_string_len ] * 65536
          + string_table[ 1 ] * 256 + string_table[ 2 ]
      local t = hash_tables[ hash ]
      if not t then
        t = {}; hash_tables[ hash ] = t
      end
      t[ table.getn( t ) + 1 ] = 0
    end
  end

  local dict_string_len_plus3 = dict_string_len + 3

  hash = (string_table[ block_start - offset ] or 0) * 256
      + (string_table[ block_start + 1 - offset ] or 0)

  local lcodes = {}
  local lcode_tblsize = 0
  local lcodes_counts = {}
  local dcodes = {}
  local dcodes_tblsize = 0
  local dcodes_counts = {}

  local lextra_bits = {}
  local lextra_bits_tblsize = 0
  local dextra_bits = {}
  local dextra_bits_tblsize = 0

  local match_available = false
  local prev_len
  local prev_dist
  local cur_len = 0
  local cur_dist = 0

  local index = block_start
  local index_end = block_end + (config_use_lazy and 1 or 0)

  -- the zlib source code writes separate code for lazy evaluation and
  -- not lazy evaluation, which is easier to understand.
  -- I put them together, so it is a bit harder to understand.
  -- because I think this is easier for me to maintain it.
  while (index <= index_end) do
    local string_table_index = index - offset
    local offset_minus_three = offset - 3
    prev_len = cur_len
    prev_dist = cur_dist
    cur_len = 0

    hash = mod( hash * 256 + (string_table[ string_table_index + 2 ] or 0), 16777216 )

    local chain_index
    local cur_chain
    local hash_chain = hash_tables[ hash ]
    local chain_old_size
    if not hash_chain then
      chain_old_size = 0
      hash_chain = {}
      hash_tables[ hash ] = hash_chain
      if dict_hash_tables then
        cur_chain = dict_hash_tables[ hash ]
        chain_index = cur_chain and table.getn( cur_chain ) or 0
      else
        chain_index = 0
      end
    else
      chain_old_size = table.getn( hash_chain )
      cur_chain = hash_chain
      chain_index = chain_old_size
    end

    if index <= block_end then
      hash_chain[ chain_old_size + 1 ] = index
    end

    if (chain_index > 0 and index + 2 <= block_end
          and (not config_use_lazy or prev_len < config_max_lazy_match)) then
      local depth =
          (config_use_lazy and prev_len >= config_good_prev_length)
          and config_good_hash_chain or config_max_hash_chain

      local max_len_minus_one = block_end - index
      max_len_minus_one = (max_len_minus_one >= 257) and 257 or max_len_minus_one
      max_len_minus_one = max_len_minus_one + string_table_index
      local string_table_index_plus_three = string_table_index + 3

      while chain_index >= 1 and depth > 0 do
        local prev = cur_chain[ chain_index ]

        if index - prev > 32768 then
          break
        end
        if prev < index then
          local sj = string_table_index_plus_three

          if prev >= -257 then
            local pj = prev - offset_minus_three
            while (sj <= max_len_minus_one
                and string_table[ pj ]
                == string_table[ sj ]) do
              sj = sj + 1
              pj = pj + 1
            end
          else
            local pj = dict_string_len_plus3 + prev
            while (sj <= max_len_minus_one
                and dict_string_table[ pj ]
                == string_table[ sj ]) do
              sj = sj + 1
              pj = pj + 1
            end
          end
          local j = sj - string_table_index
          if j > cur_len then
            cur_len = j
            cur_dist = index - prev
          end
          if cur_len >= config_nice_length then
            break
          end
        end

        chain_index = chain_index - 1
        depth = depth - 1
        if chain_index == 0 and prev > 0 and dict_hash_tables then
          cur_chain = dict_hash_tables[ hash ]
          chain_index = cur_chain and table.getn( cur_chain ) or 0
        end
      end
    end

    if not config_use_lazy then
      prev_len, prev_dist = cur_len, cur_dist
    end
    if ((not config_use_lazy or match_available)
          and (prev_len > 3 or (prev_len == 3 and prev_dist < 4096))
          and cur_len <= prev_len) then
      local code = _length_to_deflate_code[ prev_len ]
      local length_extra_bits_bitlen =
          _length_to_deflate_extra_bitlen[ prev_len ]
      local dist_code, dist_extra_bits_bitlen, dist_extra_bits
      if prev_dist <= 256 then -- have cached code for small distance.
        dist_code = _dist256_to_deflate_code[ prev_dist ]
        dist_extra_bits = _dist256_to_deflate_extra_bits[ prev_dist ]
        dist_extra_bits_bitlen =
            _dist256_to_deflate_extra_bitlen[ prev_dist ]
      else
        dist_code = 16
        dist_extra_bits_bitlen = 7
        local a = 384
        local b = 512

        while true do
          if prev_dist <= a then
            dist_extra_bits = mod( prev_dist - (b / 2) - 1, b / 4 )
            break
          elseif prev_dist <= b then
            dist_extra_bits = mod( prev_dist - (b / 2) - 1, b / 4 )
            dist_code = dist_code + 1
            break
          else
            dist_code = dist_code + 2
            dist_extra_bits_bitlen = dist_extra_bits_bitlen + 1
            a = a * 2
            b = b * 2
          end
        end
      end
      lcode_tblsize = lcode_tblsize + 1
      lcodes[ lcode_tblsize ] = code
      lcodes_counts[ code ] = (lcodes_counts[ code ] or 0) + 1

      dcodes_tblsize = dcodes_tblsize + 1
      dcodes[ dcodes_tblsize ] = dist_code
      dcodes_counts[ dist_code ] = (dcodes_counts[ dist_code ] or 0) + 1

      if length_extra_bits_bitlen > 0 then
        local lenExtraBits = _length_to_deflate_extra_bits[ prev_len ]
        lextra_bits_tblsize = lextra_bits_tblsize + 1
        lextra_bits[ lextra_bits_tblsize ] = lenExtraBits
      end
      if dist_extra_bits_bitlen > 0 then
        dextra_bits_tblsize = dextra_bits_tblsize + 1
        dextra_bits[ dextra_bits_tblsize ] = dist_extra_bits
      end

      for i = index + 1, index + prev_len - (config_use_lazy and 2 or 1) do
        hash = mod( hash * 256 + (string_table[ i - offset + 2 ] or 0), 16777216 )
        if prev_len <= config_max_insert_length then
          hash_chain = hash_tables[ hash ]
          if not hash_chain then
            hash_chain = {}
            hash_tables[ hash ] = hash_chain
          end
          hash_chain[ table.getn( hash_chain ) + 1 ] = i
        end
      end
      index = index + prev_len - (config_use_lazy and 1 or 0)
      match_available = false
    elseif (not config_use_lazy) or match_available then
      local code = string_table[ config_use_lazy
      and (string_table_index - 1) or string_table_index ]
      lcode_tblsize = lcode_tblsize + 1
      lcodes[ lcode_tblsize ] = code
      lcodes_counts[ code ] = (lcodes_counts[ code ] or 0) + 1
      index = index + 1
    else
      match_available = true
      index = index + 1
    end
  end

  -- Write "end of block" symbol
  lcode_tblsize = lcode_tblsize + 1
  lcodes[ lcode_tblsize ] = 256
  lcodes_counts[ 256 ] = (lcodes_counts[ 256 ] or 0) + 1

  return lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits
  , dcodes_counts
end

-- Get the header data of dynamic block.
-- @param lcodes_count The count of each literal/LZ77_length codes.
-- @param dcodes_count The count of each Lz77 distance codes.
-- @return a lots of stuffs.
-- @see RFC1951 Page 12
local function GetBlockDynamicHuffmanHeader( lcodes_counts, dcodes_counts )
  local lcodes_huffman_bitlens, lcodes_huffman_codes
  , max_non_zero_bitlen_lcode =
      GetHuffmanBitlenAndCode( lcodes_counts, 15, 285 )
  local dcodes_huffman_bitlens, dcodes_huffman_codes
  , max_non_zero_bitlen_dcode =
      GetHuffmanBitlenAndCode( dcodes_counts, 15, 29 )

  local rle_deflate_codes, rle_extra_bits, rle_codes_counts =
      RunLengthEncodeHuffmanBitlen( lcodes_huffman_bitlens
      , max_non_zero_bitlen_lcode, dcodes_huffman_bitlens
      , max_non_zero_bitlen_dcode )

  local rle_codes_huffman_bitlens, rle_codes_huffman_codes =
      GetHuffmanBitlenAndCode( rle_codes_counts, 7, 18 )

  local HCLEN = 0
  for i = 1, 19 do
    local symbol = _rle_codes_huffman_bitlen_order[ i ]
    local length = rle_codes_huffman_bitlens[ symbol ] or 0
    if length ~= 0 then
      HCLEN = i
    end
  end

  HCLEN = HCLEN - 4
  local HLIT = max_non_zero_bitlen_lcode + 1 - 257
  local HDIST = max_non_zero_bitlen_dcode + 1 - 1
  if HDIST < 0 then HDIST = 0 end

  return HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens
  , rle_codes_huffman_codes, rle_deflate_codes, rle_extra_bits
  , lcodes_huffman_bitlens, lcodes_huffman_codes
  , dcodes_huffman_bitlens, dcodes_huffman_codes
end

-- Get the size of dynamic block without writing any bits into the writer.
-- @param ... Read the source code of GetBlockDynamicHuffmanHeader()
-- @return the bit length of the dynamic block
local function GetDynamicHuffmanBlockSize( lcodes, dcodes, HCLEN
    , rle_codes_huffman_bitlens, rle_deflate_codes
    , lcodes_huffman_bitlens, dcodes_huffman_bitlens )
  local block_bitlen = 17 -- 1+2+5+5+4
  block_bitlen = block_bitlen + (HCLEN + 4) * 3

  for i = 1, table.getn( rle_deflate_codes ) do
    local code = rle_deflate_codes[ i ]
    block_bitlen = block_bitlen + rle_codes_huffman_bitlens[ code ]
    if code >= 16 then
      block_bitlen = block_bitlen +
          ((code == 16) and 2 or (code == 17 and 3 or 7))
    end
  end

  local length_code_count = 0
  for i = 1, table.getn( lcodes ) do
    local code = lcodes[ i ]
    local huffman_bitlen = lcodes_huffman_bitlens[ code ]
    block_bitlen = block_bitlen + huffman_bitlen
    if code > 256 then                  -- Length code
      length_code_count = length_code_count + 1
      if code > 264 and code < 285 then -- Length code with extra bits
        local extra_bits_bitlen =
            _literal_deflate_code_to_extra_bitlen[ code - 256 ]
        block_bitlen = block_bitlen + extra_bits_bitlen
      end
      local dist_code = dcodes[ length_code_count ]
      local dist_huffman_bitlen = dcodes_huffman_bitlens[ dist_code ]
      block_bitlen = block_bitlen + dist_huffman_bitlen

      if dist_code > 3 then -- dist code with extra bits
        local dist_extra_bits_bitlen = (dist_code - mod( dist_code, 2 )) / 2 - 1
        block_bitlen = block_bitlen + dist_extra_bits_bitlen
      end
    end
  end
  return block_bitlen
end

-- Write dynamic block.
-- @param ... Read the source code of GetBlockDynamicHuffmanHeader()
local function CompressDynamicHuffmanBlock( WriteBits, is_last_block
    , lcodes, lextra_bits, dcodes, dextra_bits, HLIT, HDIST, HCLEN
    , rle_codes_huffman_bitlens, rle_codes_huffman_codes
    , rle_deflate_codes, rle_extra_bits
    , lcodes_huffman_bitlens, lcodes_huffman_codes
    , dcodes_huffman_bitlens, dcodes_huffman_codes )
  WriteBits( is_last_block and 1 or 0, 1 ) -- Last block identifier
  WriteBits( 2, 2 )                        -- Dynamic Huffman block identifier

  WriteBits( HLIT, 5 )
  WriteBits( HDIST, 5 )
  WriteBits( HCLEN, 4 )

  for i = 1, HCLEN + 4 do
    local symbol = _rle_codes_huffman_bitlen_order[ i ]
    local length = rle_codes_huffman_bitlens[ symbol ] or 0
    WriteBits( length, 3 )
  end

  local rleExtraBitsIndex = 1
  for i = 1, table.getn( rle_deflate_codes ) do
    local code = rle_deflate_codes[ i ]
    WriteBits( rle_codes_huffman_codes[ code ]
    , rle_codes_huffman_bitlens[ code ] )
    if code >= 16 then
      local extraBits = rle_extra_bits[ rleExtraBitsIndex ]
      WriteBits( extraBits, (code == 16) and 2 or (code == 17 and 3 or 7) )
      rleExtraBitsIndex = rleExtraBitsIndex + 1
    end
  end

  local length_code_count = 0
  local length_code_with_extra_count = 0
  local dist_code_with_extra_count = 0

  for i = 1, table.getn( lcodes ) do
    local deflate_codee = lcodes[ i ]
    local huffman_code = lcodes_huffman_codes[ deflate_codee ]
    local huffman_bitlen = lcodes_huffman_bitlens[ deflate_codee ]
    WriteBits( huffman_code, huffman_bitlen )
    if deflate_codee > 256 then -- Length code
      length_code_count = length_code_count + 1
      if deflate_codee > 264 and deflate_codee < 285 then
        -- Length code with extra bits
        length_code_with_extra_count = length_code_with_extra_count + 1
        local extra_bits = lextra_bits[ length_code_with_extra_count ]
        local extra_bits_bitlen =
            _literal_deflate_code_to_extra_bitlen[ deflate_codee - 256 ]
        WriteBits( extra_bits, extra_bits_bitlen )
      end
      -- Write distance code
      local dist_deflate_code = dcodes[ length_code_count ]
      local dist_huffman_code = dcodes_huffman_codes[ dist_deflate_code ]
      local dist_huffman_bitlen =
          dcodes_huffman_bitlens[ dist_deflate_code ]
      WriteBits( dist_huffman_code, dist_huffman_bitlen )

      if dist_deflate_code > 3 then -- dist code with extra bits
        dist_code_with_extra_count = dist_code_with_extra_count + 1
        local dist_extra_bits = dextra_bits[ dist_code_with_extra_count ]
        local dist_extra_bits_bitlen =
            (dist_deflate_code - mod( dist_deflate_code, 2 )) / 2 - 1
        WriteBits( dist_extra_bits, dist_extra_bits_bitlen )
      end
    end
  end
end

-- Get the size of fixed block without writing any bits into the writer.
-- @param lcodes literal/LZ77_length deflate codes
-- @param decodes LZ77 distance deflate codes
-- @return the bit length of the fixed block
local function GetFixedHuffmanBlockSize( lcodes, dcodes )
  local block_bitlen = 3
  local length_code_count = 0
  for i = 1, table.getn( lcodes ) do
    local code = lcodes[ i ]
    local huffman_bitlen = _fix_block_literal_huffman_bitlen[ code ]
    block_bitlen = block_bitlen + huffman_bitlen
    if code > 256 then                  -- Length code
      length_code_count = length_code_count + 1
      if code > 264 and code < 285 then -- Length code with extra bits
        local extra_bits_bitlen =
            _literal_deflate_code_to_extra_bitlen[ code - 256 ]
        block_bitlen = block_bitlen + extra_bits_bitlen
      end
      local dist_code = dcodes[ length_code_count ]
      block_bitlen = block_bitlen + 5

      if dist_code > 3 then -- dist code with extra bits
        local dist_extra_bits_bitlen =
            (dist_code - mod( dist_code, 2 )) / 2 - 1
        block_bitlen = block_bitlen + dist_extra_bits_bitlen
      end
    end
  end
  return block_bitlen
end

-- Write fixed block.
-- @param lcodes literal/LZ77_length deflate codes
-- @param decodes LZ77 distance deflate codes
local function CompressFixedHuffmanBlock( WriteBits, is_last_block,
                                          lcodes, lextra_bits, dcodes, dextra_bits )
  WriteBits( is_last_block and 1 or 0, 1 ) -- Last block identifier
  WriteBits( 1, 2 )                        -- Fixed Huffman block identifier
  local length_code_count = 0
  local length_code_with_extra_count = 0
  local dist_code_with_extra_count = 0
  for i = 1, table.getn( lcodes ) do
    local deflate_code = lcodes[ i ]
    local huffman_code = _fix_block_literal_huffman_code[ deflate_code ]
    local huffman_bitlen = _fix_block_literal_huffman_bitlen[ deflate_code ]
    WriteBits( huffman_code, huffman_bitlen )
    if deflate_code > 256 then -- Length code
      length_code_count = length_code_count + 1
      if deflate_code > 264 and deflate_code < 285 then
        -- Length code with extra bits
        length_code_with_extra_count = length_code_with_extra_count + 1
        local extra_bits = lextra_bits[ length_code_with_extra_count ]
        local extra_bits_bitlen =
            _literal_deflate_code_to_extra_bitlen[ deflate_code - 256 ]
        WriteBits( extra_bits, extra_bits_bitlen )
      end
      -- Write distance code
      local dist_code = dcodes[ length_code_count ]
      local dist_huffman_code = _fix_block_dist_huffman_code[ dist_code ]
      WriteBits( dist_huffman_code, 5 )

      if dist_code > 3 then -- dist code with extra bits
        dist_code_with_extra_count = dist_code_with_extra_count + 1
        local dist_extra_bits = dextra_bits[ dist_code_with_extra_count ]
        local dist_extra_bits_bitlen = (dist_code - mod( dist_code, 2 )) / 2 - 1
        WriteBits( dist_extra_bits, dist_extra_bits_bitlen )
      end
    end
  end
end

-- Get the size of store block without writing any bits into the writer.
-- @param block_start The start index of the origin input string
-- @param block_end The end index of the origin input string
-- @param Total bit lens had been written into the compressed result before,
-- because store block needs to shift to byte boundary.
-- @return the bit length of the fixed block
local function GetStoreBlockSize( block_start, block_end, total_bitlen )
  assert( block_end - block_start + 1 <= 65535 )
  local block_bitlen = 3
  total_bitlen = total_bitlen + 3
  local padding_bitlen = mod( 8 - mod( total_bitlen, 8 ), 8 )
  block_bitlen = block_bitlen + padding_bitlen
  block_bitlen = block_bitlen + 32
  block_bitlen = block_bitlen + (block_end - block_start + 1) * 8
  return block_bitlen
end

-- Write the store block.
-- @param ... lots of stuffs
-- @return nil
local function CompressStoreBlock( WriteBits, WriteString, is_last_block, str
    , block_start, block_end, total_bitlen )
  assert( block_end - block_start + 1 <= 65535 )
  WriteBits( is_last_block and 1 or 0, 1 ) -- Last block identifer.
  WriteBits( 0, 2 )                        -- Store block identifier.
  total_bitlen = total_bitlen + 3
  local padding_bitlen = mod( 8 - mod( total_bitlen, 8 ), 8 )
  if padding_bitlen > 0 then
    WriteBits( _pow2[ padding_bitlen ] - 1, padding_bitlen )
  end
  local size = block_end - block_start + 1
  WriteBits( size, 16 )

  -- Write size's one's complement
  local comp = (255 - mod( size, 256 )) + (255 - (size - mod( size, 256 )) / 256) * 256
  WriteBits( comp, 16 )

  WriteString( string.sub( str, block_start, block_end ) )
end

-- Do the deflate
-- Currently using a simple way to determine the block size
-- (This is why the compression ratio is little bit worse than zlib when
-- the input size is very large
-- The first block is 64KB, the following block is 32KB.
-- After each block, there is a memory cleanup operation.
-- This is not a fast operation, but it is needed to save memory usage, so
-- the memory usage does not grow unboundly. If the data size is less than
-- 64KB, then memory cleanup won't happen.
-- This function determines whether to use store/fixed/dynamic blocks by
-- calculating the block size of each block type and chooses the smallest one.
local function Deflate( configs, WriteBits, WriteString, FlushWriter, str
    , dictionary )
  local string_table = {}
  local hash_tables = {}
  local is_last_block = nil
  local block_start
  local block_end
  local bitlen_written
  local total_bitlen = FlushWriter( _FLUSH_MODE_NO_FLUSH )
  local strlen = string.len( str )
  local offset

  local level
  local strategy
  if configs then
    if configs.level then
      level = configs.level
    end
    if configs.strategy then
      strategy = configs.strategy
    end
  end

  if not level then
    if strlen < 2048 then
      level = 7
    elseif strlen > 65536 then
      level = 3
    else
      level = 5
    end
  end

  while not is_last_block do
    if not block_start then
      block_start = 1
      block_end = 64 * 1024 - 1
      offset = 0
    else
      block_start = block_end + 1
      block_end = block_end + 32 * 1024
      offset = block_start - 32 * 1024 - 1
    end

    if block_end >= strlen then
      block_end = strlen
      is_last_block = true
    else
      is_last_block = false
    end

    local lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits
    , dcodes_counts

    local HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens
    , rle_codes_huffman_codes, rle_deflate_codes
    , rle_extra_bits, lcodes_huffman_bitlens, lcodes_huffman_codes
    , dcodes_huffman_bitlens, dcodes_huffman_codes

    local dynamic_block_bitlen
    local fixed_block_bitlen
    local store_block_bitlen

    if level ~= 0 then
      -- GetBlockLZ77 needs block_start to block_end+3 to be loaded.
      LoadStringToTable( str, string_table, block_start, block_end + 3
      , offset )
      if block_start == 1 and dictionary then
        local dict_string_table = dictionary.string_table
        local dict_strlen = dictionary.strlen
        for i = 0, (-dict_strlen + 1) < -257
        and -257 or (-dict_strlen + 1), -1 do
          string_table[ i ] = dict_string_table[ dict_strlen + i ]
        end
      end

      if strategy == "huffman_only" then
        lcodes = {}
        LoadStringToTable( str, lcodes, block_start, block_end
        , block_start - 1 )
        lextra_bits = {}
        lcodes_counts = {}
        lcodes[ block_end - block_start + 2 ] = 256 -- end of block
        for i = 1, block_end - block_start + 2 do
          local code = lcodes[ i ]
          lcodes_counts[ code ] = (lcodes_counts[ code ] or 0) + 1
        end
        dcodes = {}
        dextra_bits = {}
        dcodes_counts = {}
      else
        lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits
        , dcodes_counts = GetBlockLZ77Result( level, string_table
        , hash_tables, block_start, block_end, offset, dictionary
        )
      end

      HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens
      , rle_codes_huffman_codes, rle_deflate_codes
      , rle_extra_bits, lcodes_huffman_bitlens, lcodes_huffman_codes
      , dcodes_huffman_bitlens, dcodes_huffman_codes =
          GetBlockDynamicHuffmanHeader( lcodes_counts, dcodes_counts )
      dynamic_block_bitlen = GetDynamicHuffmanBlockSize(
        lcodes, dcodes, HCLEN, rle_codes_huffman_bitlens
        , rle_deflate_codes, lcodes_huffman_bitlens
        , dcodes_huffman_bitlens )
      fixed_block_bitlen = GetFixedHuffmanBlockSize( lcodes, dcodes )
    end

    store_block_bitlen = GetStoreBlockSize( block_start, block_end
    , total_bitlen )

    local min_bitlen = store_block_bitlen
    min_bitlen = (fixed_block_bitlen and fixed_block_bitlen < min_bitlen)
        and fixed_block_bitlen or min_bitlen
    min_bitlen = (dynamic_block_bitlen
          and dynamic_block_bitlen < min_bitlen)
        and dynamic_block_bitlen or min_bitlen

    if level == 0 or (strategy ~= "fixed" and strategy ~= "dynamic" and
          store_block_bitlen == min_bitlen) then
      CompressStoreBlock( WriteBits, WriteString, is_last_block
      , str, block_start, block_end, total_bitlen )
      total_bitlen = total_bitlen + store_block_bitlen
    elseif strategy ~= "dynamic" and (
          strategy == "fixed" or fixed_block_bitlen == min_bitlen) then
      CompressFixedHuffmanBlock( WriteBits, is_last_block,
        lcodes, lextra_bits, dcodes, dextra_bits )
      total_bitlen = total_bitlen + fixed_block_bitlen
    elseif strategy == "dynamic" or dynamic_block_bitlen == min_bitlen then
      CompressDynamicHuffmanBlock( WriteBits, is_last_block, lcodes
      , lextra_bits, dcodes, dextra_bits, HLIT, HDIST, HCLEN
      , rle_codes_huffman_bitlens, rle_codes_huffman_codes
      , rle_deflate_codes, rle_extra_bits
      , lcodes_huffman_bitlens, lcodes_huffman_codes
      , dcodes_huffman_bitlens, dcodes_huffman_codes )
      total_bitlen = total_bitlen + dynamic_block_bitlen
    end

    if is_last_block then
      bitlen_written = FlushWriter( _FLUSH_MODE_NO_FLUSH )
    else
      bitlen_written = FlushWriter( _FLUSH_MODE_MEMORY_CLEANUP )
    end

    assert( bitlen_written == total_bitlen )

    -- Memory clean up, so memory consumption does not always grow linearly
    -- , even if input string is > 64K.
    -- Not a very efficient operation, but this operation won't happen
    -- when the input data size is less than 64K.
    if not is_last_block then
      local j
      if dictionary and block_start == 1 then
        j = 0
        while (string_table[ j ]) do
          string_table[ j ] = nil
          j = j - 1
        end
      end
      dictionary = nil
      j = 1
      for i = block_end - 32767, block_end do
        string_table[ j ] = string_table[ i - offset ]
        j = j + 1
      end

      for k, t in pairs( hash_tables ) do
        local tSize = table.getn( t )
        if tSize > 0 and block_end + 1 - t[ 1 ] > 32768 then
          if tSize == 1 then
            hash_tables[ k ] = nil
          else
            local new = {}
            local newSize = 0
            for i = 2, tSize do
              j = t[ i ]
              if block_end + 1 - j <= 32768 then
                newSize = newSize + 1
                new[ newSize ] = j
              end
            end
            hash_tables[ k ] = new
          end
        end
      end
    end
  end
end

--- The description to compression configuration table. <br>
-- Any field can be nil to use its default. <br>
-- Table with keys other than those below is an invalid table.
-- @class table
-- @name compression_configs
-- @field level The compression level ranged from 0 to 9. 0 is no compression.
-- 9 is the slowest but best compression. Use nil for default level.
-- @field strategy The compression strategy. "fixed" to only use fixed deflate
-- compression block. "dynamic" to only use dynamic block. "huffman_only" to
-- do no LZ77 compression. Only do huffman compression.


-- @see LibDeflate:CompressDeflate(str, configs)
-- @see LibDeflate:CompressDeflateWithDict(str, dictionary, configs)
local function CompressDeflateInternal( str, dictionary, configs )
  local WriteBits, WriteString, FlushWriter = CreateWriter()
  Deflate( configs, WriteBits, WriteString, FlushWriter, str, dictionary )
  local total_bitlen, result = FlushWriter( _FLUSH_MODE_OUTPUT )
  local padding_bitlen = mod( 8 - mod( total_bitlen, 8 ), 8 )
  return result, padding_bitlen
end

-- @see LibDeflate:CompressZlib
-- @see LibDeflate:CompressZlibWithDict
local function CompressZlibInternal( str, dictionary, configs )
  local WriteBits, WriteString, FlushWriter = CreateWriter()

  local CM = 8    -- Compression method
  local CINFO = 7 --Window Size = 32K
  local CMF = CINFO * 16 + CM
  WriteBits( CMF, 8 )

  local FDIST = dictionary and 1 or 0
  local FLEVEL = 2 -- Default compression
  local FLG = FLEVEL * 64 + FDIST * 32
  local FCHECK = (31 - mod( CMF * 256 + FLG, 31 ))
  -- The FCHECK value must be such that CMF and FLG,
  -- when viewed as a 16-bit unsigned integer stored
  -- in MSB order (CMF*256 + FLG), is a multiple of 31.
  FLG = FLG + FCHECK
  WriteBits( FLG, 8 )

  if FDIST == 1 then
    local adler32 = dictionary.adler32
    local byte0 = mod( adler32, 256 )
    adler32 = (adler32 - byte0) / 256
    local byte1 = mod( adler32, 256 )
    adler32 = (adler32 - byte1) / 256
    local byte2 = mod( adler32, 256 )
    adler32 = (adler32 - byte2) / 256
    local byte3 = mod( adler32, 256 )
    WriteBits( byte3, 8 )
    WriteBits( byte2, 8 )
    WriteBits( byte1, 8 )
    WriteBits( byte0, 8 )
  end

  Deflate( configs, WriteBits, WriteString, FlushWriter, str, dictionary )
  FlushWriter( _FLUSH_MODE_BYTE_BOUNDARY )

  local adler32 = LibDeflate:Adler32( str )

  -- Most significant byte first
  local byte3 = mod( adler32, 256 )
  adler32 = (adler32 - byte3) / 256
  local byte2 = mod( adler32, 256 )
  adler32 = (adler32 - byte2) / 256
  local byte1 = mod( adler32, 256 )
  adler32 = (adler32 - byte1) / 256
  local byte0 = mod( adler32, 256 )

  WriteBits( byte0, 8 )
  WriteBits( byte1, 8 )
  WriteBits( byte2, 8 )
  WriteBits( byte3, 8 )
  local total_bitlen, result = FlushWriter( _FLUSH_MODE_OUTPUT )
  local padding_bitlen = mod( 8 - mod( total_bitlen, 8 ), 8 )
  return result, padding_bitlen
end

--- Compress using the raw deflate format.
-- @param str [string] The data to be compressed.
-- @param configs [table/nil] The configuration table to control the compression
-- . If nil, use the default configuration.
-- @return [string] The compressed data.
-- @return [integer] The number of bits padded at the end of output.
-- 0 <= bits < 8  <br>
-- This means the most significant "bits" of the last byte of the returned
-- compressed data are padding bits and they don't affect decompression.
-- You don't need to use this value unless you want to do some postprocessing
-- to the compressed data.
-- @see compression_configs
-- @see LibDeflate:DecompressDeflate
function LibDeflate:CompressDeflate( str, configs )
  local arg_valid, arg_err = IsValidArguments( str, false, nil, true, configs )
  if not arg_valid then
    error( ("Usage: LibDeflate:CompressDeflate(str, configs): "
      .. arg_err), 2 )
  end
  return CompressDeflateInternal( str, nil, configs )
end

--- Compress using the raw deflate format with a preset dictionary.
-- @param str [string] The data to be compressed.
-- @param dictionary [table] The preset dictionary produced by
-- LibDeflate:CreateDictionary
-- @param configs [table/nil] The configuration table to control the compression
-- . If nil, use the default configuration.
-- @return [string] The compressed data.
-- @return [integer] The number of bits padded at the end of output.
-- 0 <= bits < 8  <br>
-- This means the most significant "bits" of the last byte of the returned
-- compressed data are padding bits and they don't affect decompression.
-- You don't need to use this value unless you want to do some postprocessing
-- to the compressed data.
-- @see compression_configs
-- @see LibDeflate:CreateDictionary
-- @see LibDeflate:DecompressDeflateWithDict
function LibDeflate:CompressDeflateWithDict( str, dictionary, configs )
  local arg_valid, arg_err = IsValidArguments( str, true, dictionary
  , true, configs )
  if not arg_valid then
    error( ("Usage: LibDeflate:CompressDeflateWithDict"
      .. "(str, dictionary, configs): "
      .. arg_err), 2 )
  end
  return CompressDeflateInternal( str, dictionary, configs )
end

--- Compress using the zlib format.
-- @param str [string] the data to be compressed.
-- @param configs [table/nil] The configuration table to control the compression
-- . If nil, use the default configuration.
-- @return [string] The compressed data.
-- @return [integer] The number of bits padded at the end of output.
-- Should always be 0.
-- Zlib formatted compressed data never has padding bits at the end.
-- @see compression_configs
-- @see LibDeflate:DecompressZlib
function LibDeflate:CompressZlib( str, configs )
  local arg_valid, arg_err = IsValidArguments( str, false, nil, true, configs )
  if not arg_valid then
    error( ("Usage: LibDeflate:CompressZlib(str, configs): "
      .. arg_err), 2 )
  end
  return CompressZlibInternal( str, nil, configs )
end

--- Compress using the zlib format with a preset dictionary.
-- @param str [string] the data to be compressed.
-- @param dictionary [table] A preset dictionary produced
-- by LibDeflate:CreateDictionary()
-- @param configs [table/nil] The configuration table to control the compression
-- . If nil, use the default configuration.
-- @return [string] The compressed data.
-- @return [integer] The number of bits padded at the end of output.
-- Should always be 0.
-- Zlib formatted compressed data never has padding bits at the end.
-- @see compression_configs
-- @see LibDeflate:CreateDictionary
-- @see LibDeflate:DecompressZlibWithDict
function LibDeflate:CompressZlibWithDict( str, dictionary, configs )
  local arg_valid, arg_err = IsValidArguments( str, true, dictionary
  , true, configs )
  if not arg_valid then
    error( ("Usage: LibDeflate:CompressZlibWithDict"
      .. "(str, dictionary, configs): "
      .. arg_err), 2 )
  end
  return CompressZlibInternal( str, dictionary, configs )
end

--[[ --------------------------------------------------------------------------
	Decompress code
--]] --------------------------------------------------------------------------

--[[
	Create a reader to easily reader stuffs as the unit of bits.
	Return values:
	1. ReadBits(bitlen)
	2. ReadBytes(bytelen, buffer, buffer_size)
	3. Decode(huffman_bitlen_count, huffman_symbol, min_bitlen)
	4. ReaderBitlenLeft()
	5. SkipToByteBoundary()
--]]
local function CreateReader( input_string )
  local input = input_string
  local input_strlen = string.len( input_string )
  local input_next_byte_pos = 1
  local cache_bitlen = 0
  local cache = 0

  -- Read some bits.
  -- To improve speed, this function does not
  -- check if the input has been exhausted.
  -- Use ReaderBitlenLeft() < 0 to check it.
  -- @param bitlen the number of bits to read
  -- @return the data is read.
  local function ReadBits( bitlen )
    local rshift_mask = _pow2[ bitlen ]
    local code
    if bitlen <= cache_bitlen then
      code = mod( cache, rshift_mask )
      cache = (cache - code) / rshift_mask
      cache_bitlen = cache_bitlen - bitlen
    else -- Whether input has been exhausted is not checked.
      local lshift_mask = _pow2[ cache_bitlen ]
      local byte1, byte2, byte3, byte4 = string_byte( input
      , input_next_byte_pos, input_next_byte_pos + 3 )
      -- This requires lua number to be at least double ()
      cache = cache + ((byte1 or 0) + (byte2 or 0) * 256
        + (byte3 or 0) * 65536 + (byte4 or 0) * 16777216) * lshift_mask
      input_next_byte_pos = input_next_byte_pos + 4
      cache_bitlen = cache_bitlen + 32 - bitlen
      code = mod( cache, rshift_mask )
      cache = (cache - code) / rshift_mask
    end
    return code
  end

  -- Read some bytes from the reader.
  -- Assume reader is on the byte boundary.
  -- @param bytelen The number of bytes to be read.
  -- @param buffer The byte read will be stored into this buffer.
  -- @param buffer_size The buffer will be modified starting from
  --	buffer[buffer_size+1], ending at buffer[buffer_size+bytelen-1]
  -- @return the new buffer_size
  local function ReadBytes( bytelen, buffer, buffer_size )
    assert( mod( cache_bitlen, 8 ) == 0 )

    local byte_from_cache = (cache_bitlen / 8 < bytelen)
        and (cache_bitlen / 8) or bytelen
    for _ = 1, byte_from_cache do
      local byte = mod( cache, 256 )
      buffer_size = buffer_size + 1
      buffer[ buffer_size ] = string_char( byte )
      cache = (cache - byte) / 256
    end
    cache_bitlen = cache_bitlen - byte_from_cache * 8
    bytelen = bytelen - byte_from_cache
    if (input_strlen - input_next_byte_pos - bytelen + 1) * 8
        + cache_bitlen < 0 then
      return -1 -- out of input
    end
    for i = input_next_byte_pos, input_next_byte_pos + bytelen - 1 do
      buffer_size = buffer_size + 1
      buffer[ buffer_size ] = string_sub( input, i, i )
    end

    input_next_byte_pos = input_next_byte_pos + bytelen
    return buffer_size
  end

  -- Decode huffman code
  -- To improve speed, this function does not check
  -- if the input has been exhausted.
  -- Use ReaderBitlenLeft() < 0 to check it.
  -- Credits for Mark Adler. This code is from puff:Decode()
  -- @see puff:Decode(...)
  -- @param huffman_bitlen_count
  -- @param huffman_symbol
  -- @param min_bitlen The minimum huffman bit length of all symbols
  -- @return The decoded deflate code.
  --	Negative value is returned if decoding fails.
  local function Decode( huffman_bitlen_counts, huffman_symbols, min_bitlen )
    local code = 0
    local first = 0
    local index = 0
    local count
    if min_bitlen > 0 then
      if cache_bitlen < 15 and input then
        local lshift_mask = _pow2[ cache_bitlen ]
        local byte1, byte2, byte3, byte4 =
            string_byte( input, input_next_byte_pos
            , input_next_byte_pos + 3 )
        -- This requires lua number to be at least double ()
        cache = cache + ((byte1 or 0) + (byte2 or 0) * 256
          + (byte3 or 0) * 65536 + (byte4 or 0) * 16777216) * lshift_mask
        input_next_byte_pos = input_next_byte_pos + 4
        cache_bitlen = cache_bitlen + 32
      end

      local rshift_mask = _pow2[ min_bitlen ]
      cache_bitlen = cache_bitlen - min_bitlen
      code = mod( cache, rshift_mask )
      cache = (cache - code) / rshift_mask
      -- Reverse the bits
      code = _reverse_bits_tbl[ min_bitlen ][ code ]

      count = huffman_bitlen_counts[ min_bitlen ]
      if code < count then
        return huffman_symbols[ code ]
      end
      index = count
      first = count * 2
      code = code * 2
    end

    for bitlen = min_bitlen + 1, 15 do
      local bit
      bit = mod( cache, 2 )
      cache = (cache - bit) / 2
      cache_bitlen = cache_bitlen - 1

      code = (bit == 1) and (code + 1 - mod( code, 2 )) or code
      count = huffman_bitlen_counts[ bitlen ] or 0
      local diff = code - first
      if diff < count then
        return huffman_symbols[ index + diff ]
      end
      index = index + count
      first = first + count
      first = first * 2
      code = code * 2
    end
    -- invalid literal/length or distance code
    -- in fixed or dynamic block (run out of code)
    return -10
  end

  local function ReaderBitlenLeft()
    return (input_strlen - input_next_byte_pos + 1) * 8 + cache_bitlen
  end

  local function SkipToByteBoundary()
    local skipped_bitlen = mod( cache_bitlen, 8 )
    local rshift_mask = _pow2[ skipped_bitlen ]
    cache_bitlen = cache_bitlen - skipped_bitlen
    cache = (cache - mod( cache, rshift_mask )) / rshift_mask
  end

  return ReadBits, ReadBytes, Decode, ReaderBitlenLeft, SkipToByteBoundary
end

-- Create a deflate state, so I can pass in less arguments to functions.
-- @param str the whole string to be decompressed.
-- @param dictionary The preset dictionary. nil if not provided.
--		This dictionary should be produced by LibDeflate:CreateDictionary(str)
-- @return The decomrpess state.
local function CreateDecompressState( str, dictionary )
  local ReadBits, ReadBytes, Decode, ReaderBitlenLeft
  , SkipToByteBoundary = CreateReader( str )
  local state =
  {
    ReadBits = ReadBits,
    ReadBytes = ReadBytes,
    Decode = Decode,
    ReaderBitlenLeft = ReaderBitlenLeft,
    SkipToByteBoundary = SkipToByteBoundary,
    buffer_size = 0,
    buffer = {},
    result_buffer = {},
    dictionary = dictionary,
  }
  return state
end

-- Get the stuffs needed to decode huffman codes
-- @see puff.c:construct(...)
-- @param huffman_bitlen The huffman bit length of the huffman codes.
-- @param max_symbol The maximum symbol
-- @param max_bitlen The min huffman bit length of all codes
-- @return zero or positive for success, negative for failure.
-- @return The count of each huffman bit length.
-- @return A table to convert huffman codes to deflate codes.
-- @return The minimum huffman bit length.
local function GetHuffmanForDecode( huffman_bitlens, max_symbol, max_bitlen )
  local huffman_bitlen_counts = {}
  local min_bitlen = max_bitlen
  for symbol = 0, max_symbol do
    local bitlen = huffman_bitlens[ symbol ] or 0
    min_bitlen = (bitlen > 0 and bitlen < min_bitlen)
        and bitlen or min_bitlen
    huffman_bitlen_counts[ bitlen ] = (huffman_bitlen_counts[ bitlen ] or 0) + 1
  end

  if huffman_bitlen_counts[ 0 ] == max_symbol + 1 then -- No Codes
    return 0, huffman_bitlen_counts, {}, 0             -- Complete, but decode will fail
  end

  local left = 1
  for len = 1, max_bitlen do
    left = left * 2
    left = left - (huffman_bitlen_counts[ len ] or 0)
    if left < 0 then
      return left -- Over-subscribed, return negative
    end
  end

  -- Generate offsets info symbol table for each length for sorting
  local offsets = {}
  offsets[ 1 ] = 0
  for len = 1, max_bitlen - 1 do
    offsets[ len + 1 ] = offsets[ len ] + (huffman_bitlen_counts[ len ] or 0)
  end

  local huffman_symbols = {}
  for symbol = 0, max_symbol do
    local bitlen = huffman_bitlens[ symbol ] or 0
    if bitlen ~= 0 then
      local offset = offsets[ bitlen ]
      huffman_symbols[ offset ] = symbol
      offsets[ bitlen ] = offsets[ bitlen ] + 1
    end
  end

  -- Return zero for complete set, positive for incomplete set.
  return left, huffman_bitlen_counts, huffman_symbols, min_bitlen
end

-- Decode a fixed or dynamic huffman blocks, excluding last block identifier
-- and block type identifer.
-- @see puff.c:codes()
-- @param state decompression state that will be modified by this function.
--	@see CreateDecompressState
-- @param ... Read the source code
-- @return 0 on success, other value on failure.
local function DecodeUntilEndOfBlock( state, lcodes_huffman_bitlens
    , lcodes_huffman_symbols, lcodes_huffman_min_bitlen
    , dcodes_huffman_bitlens, dcodes_huffman_symbols
    , dcodes_huffman_min_bitlen )
  local buffer, buffer_size, ReadBits, Decode, ReaderBitlenLeft
  , result_buffer =
      state.buffer, state.buffer_size, state.ReadBits, state.Decode
      , state.ReaderBitlenLeft, state.result_buffer
  local dictionary = state.dictionary
  local dict_string_table
  local dict_strlen

  local buffer_end = 1
  if dictionary and not buffer[ 0 ] then
    -- If there is a dictionary, copy the last 258 bytes into
    -- the string_table to make the copy in the main loop quicker.
    -- This is done only once per decompression.
    dict_string_table = dictionary.string_table
    dict_strlen = dictionary.strlen
    buffer_end = -dict_strlen + 1
    for i = 0, (-dict_strlen + 1) < -257 and -257 or (-dict_strlen + 1), -1 do
      buffer[ i ] = _byte_to_char[ dict_string_table[ dict_strlen + i ] ]
    end
  end

  repeat
    local symbol = Decode( lcodes_huffman_bitlens
    , lcodes_huffman_symbols, lcodes_huffman_min_bitlen )
    if symbol < 0 or symbol > 285 then
      -- invalid literal/length or distance code in fixed or dynamic block
      return -10
    elseif symbol < 256 then -- Literal
      buffer_size = buffer_size + 1
      buffer[ buffer_size ] = _byte_to_char[ symbol ]
    elseif symbol > 256 then -- Length code
      symbol = symbol - 256
      local bitlen = _literal_deflate_code_to_base_len[ symbol ]
      bitlen = (symbol >= 8)
          and (bitlen
            + ReadBits( _literal_deflate_code_to_extra_bitlen[ symbol ] ))
          or bitlen
      symbol = Decode( dcodes_huffman_bitlens, dcodes_huffman_symbols
      , dcodes_huffman_min_bitlen )
      if symbol < 0 or symbol > 29 then
        -- invalid literal/length or distance code in fixed or dynamic block
        return -10
      end
      local dist = _dist_deflate_code_to_base_dist[ symbol ]
      dist = (dist > 4) and (dist
        + ReadBits( _dist_deflate_code_to_extra_bitlen[ symbol ] )) or dist

      local char_buffer_index = buffer_size - dist + 1
      if char_buffer_index < buffer_end then
        -- distance is too far back in fixed or dynamic block
        return -11
      end
      if char_buffer_index >= -257 then
        for _ = 1, bitlen do
          buffer_size = buffer_size + 1
          buffer[ buffer_size ] = buffer[ char_buffer_index ]
          char_buffer_index = char_buffer_index + 1
        end
      else
        char_buffer_index = dict_strlen + char_buffer_index
        for _ = 1, bitlen do
          buffer_size = buffer_size + 1
          buffer[ buffer_size ] =
              _byte_to_char[ dict_string_table[ char_buffer_index ] ]
          char_buffer_index = char_buffer_index + 1
        end
      end
    end

    if ReaderBitlenLeft() < 0 then
      return 2 -- available inflate data did not terminate
    end

    if buffer_size >= 65536 then
      result_buffer[ table.getn( result_buffer ) + 1 ] =
          table_concat( buffer, "", 1, 32768 )
      for i = 32769, buffer_size do
        buffer[ i - 32768 ] = buffer[ i ]
      end
      buffer_size = buffer_size - 32768
      buffer[ buffer_size + 1 ] = nil
      -- NOTE: buffer[32769..end] and buffer[-257..0] are not cleared.
      -- This is why "buffer_size" variable is needed.
    end
  until symbol == 256

  state.buffer_size = buffer_size

  return 0
end

-- Decompress a store block
-- @param state decompression state that will be modified by this function.
-- @return 0 if succeeds, other value if fails.
local function DecompressStoreBlock( state )
  local buffer, buffer_size, ReadBits, ReadBytes, ReaderBitlenLeft
  , SkipToByteBoundary, result_buffer =
      state.buffer, state.buffer_size, state.ReadBits, state.ReadBytes
      , state.ReaderBitlenLeft, state.SkipToByteBoundary, state.result_buffer

  SkipToByteBoundary()
  local bytelen = ReadBits( 16 )
  if ReaderBitlenLeft() < 0 then
    return 2 -- available inflate data did not terminate
  end
  local bytelenComp = ReadBits( 16 )
  if ReaderBitlenLeft() < 0 then
    return 2 -- available inflate data did not terminate
  end

  if mod( bytelen, 256 ) + mod( bytelenComp, 256 ) ~= 255 then
    return -2 -- Not one's complement
  end
  if (bytelen - mod( bytelen, 256 )) / 256
      + (bytelenComp - mod( bytelenComp, 256 )) / 256 ~= 255 then
    return -2 -- Not one's complement
  end

  -- Note that ReadBytes will skip to the next byte boundary first.
  buffer_size = ReadBytes( bytelen, buffer, buffer_size )
  if buffer_size < 0 then
    return 2 -- available inflate data did not terminate
  end

  -- memory clean up when there are enough bytes in the buffer.
  if buffer_size >= 65536 then
    result_buffer[ table.getn( result_buffer ) + 1 ] = table_concat( buffer, "", 1, 32768 )
    for i = 32769, buffer_size do
      buffer[ i - 32768 ] = buffer[ i ]
    end
    buffer_size = buffer_size - 32768
    buffer[ buffer_size + 1 ] = nil
  end
  state.buffer_size = buffer_size
  return 0
end

-- Decompress a fixed block
-- @param state decompression state that will be modified by this function.
-- @return 0 if succeeds other value if fails.
local function DecompressFixBlock( state )
  return DecodeUntilEndOfBlock( state
  , _fix_block_literal_huffman_bitlen_count
  , _fix_block_literal_huffman_to_deflate_code, 7
  , _fix_block_dist_huffman_bitlen_count
  , _fix_block_dist_huffman_to_deflate_code, 5 )
end

-- Decompress a dynamic block
-- @param state decompression state that will be modified by this function.
-- @return 0 if success, other value if fails.
local function DecompressDynamicBlock( state )
  local ReadBits, Decode = state.ReadBits, state.Decode
  local nlen = ReadBits( 5 ) + 257
  local ndist = ReadBits( 5 ) + 1
  local ncode = ReadBits( 4 ) + 4
  if nlen > 286 or ndist > 30 then
    -- dynamic block code description: too many length or distance codes
    return -3
  end

  local rle_codes_huffman_bitlens = {}

  for i = 1, ncode do
    rle_codes_huffman_bitlens[ _rle_codes_huffman_bitlen_order[ i ] ] =
        ReadBits( 3 )
  end

  local rle_codes_err, rle_codes_huffman_bitlen_counts,
  rle_codes_huffman_symbols, rle_codes_huffman_min_bitlen =
      GetHuffmanForDecode( rle_codes_huffman_bitlens, 18, 7 )
  if rle_codes_err ~= 0 then -- Require complete code set here
    -- dynamic block code description: code lengths codes incomplete
    return -4
  end

  local lcodes_huffman_bitlens = {}
  local dcodes_huffman_bitlens = {}
  -- Read length/literal and distance code length tables
  local index = 0
  while index < nlen + ndist do
    local symbol -- Decoded value
    local bitlen -- Last length to repeat

    symbol = Decode( rle_codes_huffman_bitlen_counts
    , rle_codes_huffman_symbols, rle_codes_huffman_min_bitlen )

    if symbol < 0 then
      return symbol -- Invalid symbol
    elseif symbol < 16 then
      if index < nlen then
        lcodes_huffman_bitlens[ index ] = symbol
      else
        dcodes_huffman_bitlens[ index - nlen ] = symbol
      end
      index = index + 1
    else
      bitlen = 0
      if symbol == 16 then
        if index == 0 then
          -- dynamic block code description: repeat lengths
          -- with no first length
          return -5
        end
        if index - 1 < nlen then
          bitlen = lcodes_huffman_bitlens[ index - 1 ]
        else
          bitlen = dcodes_huffman_bitlens[ index - nlen - 1 ]
        end
        symbol = 3 + ReadBits( 2 )
      elseif symbol == 17 then -- Repeat zero 3..10 times
        symbol = 3 + ReadBits( 3 )
      else                     -- == 18, repeat zero 11.138 times
        symbol = 11 + ReadBits( 7 )
      end
      if index + symbol > nlen + ndist then
        -- dynamic block code description:
        -- repeat more than specified lengths
        return -6
      end
      while symbol > 0 do -- Repeat last or zero symbol times
        symbol = symbol - 1
        if index < nlen then
          lcodes_huffman_bitlens[ index ] = bitlen
        else
          dcodes_huffman_bitlens[ index - nlen ] = bitlen
        end
        index = index + 1
      end
    end
  end

  if (lcodes_huffman_bitlens[ 256 ] or 0) == 0 then
    -- dynamic block code description: missing end-of-block code
    return -9
  end

  local lcodes_err, lcodes_huffman_bitlen_counts
  , lcodes_huffman_symbols, lcodes_huffman_min_bitlen =
      GetHuffmanForDecode( lcodes_huffman_bitlens, nlen - 1, 15 )
  --dynamic block code description: invalid literal/length code lengths,
  -- Incomplete code ok only for single length 1 code
  if (lcodes_err ~= 0 and (lcodes_err < 0
        or nlen ~= (lcodes_huffman_bitlen_counts[ 0 ] or 0)
        + (lcodes_huffman_bitlen_counts[ 1 ] or 0))) then
    return -7
  end

  local dcodes_err, dcodes_huffman_bitlen_counts
  , dcodes_huffman_symbols, dcodes_huffman_min_bitlen =
      GetHuffmanForDecode( dcodes_huffman_bitlens, ndist - 1, 15 )
  -- dynamic block code description: invalid distance code lengths,
  -- Incomplete code ok only for single length 1 code
  if (dcodes_err ~= 0 and (dcodes_err < 0
        or ndist ~= (dcodes_huffman_bitlen_counts[ 0 ] or 0)
        + (dcodes_huffman_bitlen_counts[ 1 ] or 0))) then
    return -8
  end

  -- Build buffman table for literal/length codes
  return DecodeUntilEndOfBlock( state, lcodes_huffman_bitlen_counts
  , lcodes_huffman_symbols, lcodes_huffman_min_bitlen
  , dcodes_huffman_bitlen_counts, dcodes_huffman_symbols
  , dcodes_huffman_min_bitlen )
end

-- Decompress a deflate stream
-- @param state: a decompression state
-- @return the decompressed string if succeeds. nil if fails.
local function Inflate( state )
  local ReadBits = state.ReadBits

  local is_last_block
  while not is_last_block do
    is_last_block = (ReadBits( 1 ) == 1)
    local block_type = ReadBits( 2 )
    local status
    if block_type == 0 then
      status = DecompressStoreBlock( state )
    elseif block_type == 1 then
      status = DecompressFixBlock( state )
    elseif block_type == 2 then
      status = DecompressDynamicBlock( state )
    else
      return nil, -1 -- invalid block type (type == 3)
    end
    if status ~= 0 then
      return nil, status
    end
  end

  state.result_buffer[ table.getn( state.result_buffer ) + 1 ] =
      table_concat( state.buffer, "", 1, state.buffer_size )
  local result = table_concat( state.result_buffer )
  return result
end

-- @see LibDeflate:DecompressDeflate(str)
-- @see LibDeflate:DecompressDeflateWithDict(str, dictionary)
local function DecompressDeflateInternal( str, dictionary )
  local state = CreateDecompressState( str, dictionary )
  local result, status = Inflate( state )
  if not result then
    return nil, status
  end

  local bitlen_left = state.ReaderBitlenLeft()
  local bytelen_left = (bitlen_left - mod( bitlen_left, 8 )) / 8
  return result, bytelen_left
end

-- @see LibDeflate:DecompressZlib(str)
-- @see LibDeflate:DecompressZlibWithDict(str)
local function DecompressZlibInternal( str, dictionary )
  local state = CreateDecompressState( str, dictionary )
  local ReadBits = state.ReadBits

  local CMF = ReadBits( 8 )
  if state.ReaderBitlenLeft() < 0 then
    return nil, 2 -- available inflate data did not terminate
  end
  local CM = mod( CMF, 16 )
  local CINFO = (CMF - CM) / 16
  if CM ~= 8 then
    return nil, -12 -- invalid compression method
  end
  if CINFO > 7 then
    return nil, -13 -- invalid window size
  end

  local FLG = ReadBits( 8 )
  if state.ReaderBitlenLeft() < 0 then
    return nil, 2 -- available inflate data did not terminate
  end
  if mod( CMF * 256 + FLG, 31 ) ~= 0 then
    return nil, -14 -- invalid header checksum
  end

  local FDIST = mod( (FLG - mod( FLG, 32 )) / 32, 2 )
  local FLEVEL = mod( (FLG - mod( FLG, 64 )) / 64, 4 ) -- luacheck: ignore FLEVEL

  if FDIST == 1 then
    if not dictionary then
      return nil, -16 -- need dictonary, but dictionary is not provided.
    end
    local byte3 = ReadBits( 8 )
    local byte2 = ReadBits( 8 )
    local byte1 = ReadBits( 8 )
    local byte0 = ReadBits( 8 )
    local actual_adler32 = byte3 * 16777216 + byte2 * 65536 + byte1 * 256 + byte0
    if state.ReaderBitlenLeft() < 0 then
      return nil, 2 -- available inflate data did not terminate
    end
    if not IsEqualAdler32( actual_adler32, dictionary.adler32 ) then
      return nil, -17 -- dictionary adler32 does not match
    end
  end
  local result, status = Inflate( state )
  if not result then
    return nil, status
  end
  state.SkipToByteBoundary()

  local adler_byte0 = ReadBits( 8 )
  local adler_byte1 = ReadBits( 8 )
  local adler_byte2 = ReadBits( 8 )
  local adler_byte3 = ReadBits( 8 )
  if state.ReaderBitlenLeft() < 0 then
    return nil, 2 -- available inflate data did not terminate
  end

  local adler32_expected = adler_byte0 * 16777216
      + adler_byte1 * 65536 + adler_byte2 * 256 + adler_byte3
  local adler32_actual = LibDeflate:Adler32( result )
  if not IsEqualAdler32( adler32_expected, adler32_actual ) then
    return nil, -15 -- Adler32 checksum does not match
  end

  local bitlen_left = state.ReaderBitlenLeft()
  local bytelen_left = (bitlen_left - mod( bitlen_left, 8 )) / 8
  return result, bytelen_left
end

--- Decompress a raw deflate compressed data.
-- @param str [string] The data to be decompressed.
-- @return [string/nil] If the decompression succeeds, return the decompressed
-- data. If the decompression fails, return nil. You should check if this return
-- value is non-nil to know if the decompression succeeds.
-- @return [integer] If the decompression succeeds, return the number of
-- unprocessed bytes in the input compressed data. This return value is a
-- positive integer if the input data is a valid compressed data appended by an
-- arbitary non-empty string. This return value is 0 if the input data does not
-- contain any extra bytes.<br>
-- If the decompression fails (The first return value of this function is nil),
-- this return value is undefined.
-- @see LibDeflate:CompressDeflate
function LibDeflate:DecompressDeflate( str )
  local arg_valid, arg_err = IsValidArguments( str )
  if not arg_valid then
    error( ("Usage: LibDeflate:DecompressDeflate(str): "
      .. arg_err), 2 )
  end
  return DecompressDeflateInternal( str )
end

--- Decompress a raw deflate compressed data with a preset dictionary.
-- @param str [string] The data to be decompressed.
-- @param dictionary [table] The preset dictionary used by
-- LibDeflate:CompressDeflateWithDict when the compressed data is produced.
-- Decompression and compression must use the same dictionary.
-- Otherwise wrong decompressed data could be produced without generating any
-- error.
-- @return [string/nil] If the decompression succeeds, return the decompressed
-- data. If the decompression fails, return nil. You should check if this return
-- value is non-nil to know if the decompression succeeds.
-- @return [integer] If the decompression succeeds, return the number of
-- unprocessed bytes in the input compressed data. This return value is a
-- positive integer if the input data is a valid compressed data appended by an
-- arbitary non-empty string. This return value is 0 if the input data does not
-- contain any extra bytes.<br>
-- If the decompression fails (The first return value of this function is nil),
-- this return value is undefined.
-- @see LibDeflate:CompressDeflateWithDict
function LibDeflate:DecompressDeflateWithDict( str, dictionary )
  local arg_valid, arg_err = IsValidArguments( str, true, dictionary )
  if not arg_valid then
    error( ("Usage: LibDeflate:DecompressDeflateWithDict(str, dictionary): "
      .. arg_err), 2 )
  end
  return DecompressDeflateInternal( str, dictionary )
end

--- Decompress a zlib compressed data.
-- @param str [string] The data to be decompressed
-- @return [string/nil] If the decompression succeeds, return the decompressed
-- data. If the decompression fails, return nil. You should check if this return
-- value is non-nil to know if the decompression succeeds.
-- @return [integer] If the decompression succeeds, return the number of
-- unprocessed bytes in the input compressed data. This return value is a
-- positive integer if the input data is a valid compressed data appended by an
-- arbitary non-empty string. This return value is 0 if the input data does not
-- contain any extra bytes.<br>
-- If the decompression fails (The first return value of this function is nil),
-- this return value is undefined.
-- @see LibDeflate:CompressZlib
function LibDeflate:DecompressZlib( str )
  local arg_valid, arg_err = IsValidArguments( str )
  if not arg_valid then
    error( ("Usage: LibDeflate:DecompressZlib(str): "
      .. arg_err), 2 )
  end
  return DecompressZlibInternal( str )
end

--- Decompress a zlib compressed data with a preset dictionary.
-- @param str [string] The data to be decompressed
-- @param dictionary [table] The preset dictionary used by
-- LibDeflate:CompressDeflateWithDict when the compressed data is produced.
-- Decompression and compression must use the same dictionary.
-- Otherwise wrong decompressed data could be produced without generating any
-- error.
-- @return [string/nil] If the decompression succeeds, return the decompressed
-- data. If the decompression fails, return nil. You should check if this return
-- value is non-nil to know if the decompression succeeds.
-- @return [integer] If the decompression succeeds, return the number of
-- unprocessed bytes in the input compressed data. This return value is a
-- positive integer if the input data is a valid compressed data appended by an
-- arbitary non-empty string. This return value is 0 if the input data does not
-- contain any extra bytes.<br>
-- If the decompression fails (The first return value of this function is nil),
-- this return value is undefined.
-- @see LibDeflate:CompressZlibWithDict
function LibDeflate:DecompressZlibWithDict( str, dictionary )
  local arg_valid, arg_err = IsValidArguments( str, true, dictionary )
  if not arg_valid then
    error( ("Usage: LibDeflate:DecompressZlibWithDict(str, dictionary): "
      .. arg_err), 2 )
  end
  return DecompressZlibInternal( str, dictionary )
end

-- Calculate the huffman code of fixed block
do
  _fix_block_literal_huffman_bitlen = {}
  for sym = 0, 143 do
    _fix_block_literal_huffman_bitlen[ sym ] = 8
  end
  for sym = 144, 255 do
    _fix_block_literal_huffman_bitlen[ sym ] = 9
  end
  for sym = 256, 279 do
    _fix_block_literal_huffman_bitlen[ sym ] = 7
  end
  for sym = 280, 287 do
    _fix_block_literal_huffman_bitlen[ sym ] = 8
  end

  _fix_block_dist_huffman_bitlen = {}
  for dist = 0, 31 do
    _fix_block_dist_huffman_bitlen[ dist ] = 5
  end
  local status
  status, _fix_block_literal_huffman_bitlen_count
  , _fix_block_literal_huffman_to_deflate_code =
      GetHuffmanForDecode( _fix_block_literal_huffman_bitlen, 287, 9 )
  assert( status == 0 )
  status, _fix_block_dist_huffman_bitlen_count,
  _fix_block_dist_huffman_to_deflate_code =
      GetHuffmanForDecode( _fix_block_dist_huffman_bitlen, 31, 5 )
  assert( status == 0 )

  _fix_block_literal_huffman_code =
      GetHuffmanCodeFromBitlen( _fix_block_literal_huffman_bitlen_count
      , _fix_block_literal_huffman_bitlen, 287, 9 )
  _fix_block_dist_huffman_code =
      GetHuffmanCodeFromBitlen( _fix_block_dist_huffman_bitlen_count
      , _fix_block_dist_huffman_bitlen, 31, 5 )
end

-- Prefix encoding algorithm
-- Credits to LibCompress.
-- The code has been rewritten by the author of LibDeflate.
------------------------------------------------------------------------------

-- to be able to match any requested byte value, the search
-- string must be preprocessed characters to escape with %:
-- ( ) . % + - * ? [ ] ^ $
-- "illegal" byte values:
-- 0 is replaces %z
local _gsub_escape_table = {
  [ "\000" ] = "%z",
  [ "(" ] = "%(",
  [ ")" ] = "%)",
  [ "." ] = "%.",
  [ "%" ] = "%%",
  [ "+" ] = "%+",
  [ "-" ] = "%-",
  [ "*" ] = "%*",
  [ "?" ] = "%?",
  [ "[" ] = "%[",
  [ "]" ] = "%]",
  [ "^" ] = "%^",
  [ "$" ] = "%$",
}

local function escape_for_gsub( str )
  return string.gsub( str, "([%z%(%)%.%%%+%-%*%?%[%]%^%$])", _gsub_escape_table )
end

--- Create a custom codec with encoder and decoder. <br>
-- This codec is used to convert an input string to make it not contain
-- some specific bytes.
-- This created codec and the parameters of this function do NOT take
-- localization into account. One byte (0-255) in the string is exactly one
-- character (0-255).
-- Credits to LibCompress.
-- The code has been rewritten by the author of LibDeflate. <br>
-- @param reserved_chars [string] The created encoder will ensure encoded
-- data does not contain any single character in reserved_chars. This parameter
-- should be non-empty.
-- @param escape_chars [string] The escape character(s) used in the created
-- codec. The codec converts any character included in reserved\_chars /
-- escape\_chars / map\_chars to (one escape char + one character not in
-- reserved\_chars / escape\_chars / map\_chars).
-- You usually only need to provide a length-1 string for this parameter.
-- Length-2 string is only needed when
-- reserved\_chars + escape\_chars + map\_chars is longer than 127.
-- This parameter should be non-empty.
-- @param map_chars [string] The created encoder will map every
-- reserved\_chars:sub(i, i) (1 <= i <= #map\_chars) to map\_chars:sub(i, i).
-- This parameter CAN be empty string.
-- @return [table/nil] If the codec cannot be created, return nil.<br>
-- If the codec can be created according to the given
-- parameters, return the codec, which is a encode/decode table.
-- The table contains two functions: <br>
-- t:Encode(str) returns the encoded string. <br>
-- t:Decode(str) returns the decoded string if succeeds. nil if fails.
-- @return [nil/string] If the codec is successfully created, return nil.
-- If not, return a string that describes the reason why the codec cannot be
-- created.
-- @usage
-- -- Create an encoder/decoder that maps all "\000" to "\003",
-- -- and escape "\001" (and "\002" and "\003") properly
-- local codec = LibDeflate:CreateCodec("\000\001", "\002", "\003")
--
-- local encoded = codec:Encode(SOME_STRING)
-- -- "encoded" does not contain "\000" or "\001"
-- local decoded = codec:Decode(encoded)
-- -- assert(decoded == SOME_STRING)
function LibDeflate:CreateCodec( reserved_chars, escape_chars
    , map_chars )
  if type( reserved_chars ) ~= "string"
      or type( escape_chars ) ~= "string"
      or type( map_chars ) ~= "string" then
    error(
      "Usage: LibDeflate:CreateCodec(reserved_chars,"
      .. " escape_chars, map_chars):"
      .. " All arguments must be string.", 2 )
  end

  if escape_chars == "" then
    return nil, "No escape characters supplied."
  end
  if string.len( reserved_chars ) < string.len( map_chars ) then
    return nil, "The number of reserved characters must be"
        .. " at least as many as the number of mapped chars."
  end
  if reserved_chars == "" then
    return nil, "No characters to encode."
  end

  local encode_bytes = reserved_chars .. escape_chars .. map_chars
  -- build list of bytes not available as a suffix to a prefix byte
  local taken = {}
  for i = 1, string.len( encode_bytes ) do
    local byte = string_byte( encode_bytes, i, i )
    if taken[ byte ] then
      return nil, "There must be no duplicate characters in the"
          .. " concatenation of reserved_chars, escape_chars and"
          .. " map_chars."
    end
    taken[ byte ] = true
  end

  local decode_patterns = {}
  local decode_repls = {}

  -- the encoding can be a single gsub
  -- , but the decoding can require multiple gsubs
  local encode_search = {}
  local encode_translate = {}

  -- map single byte to single byte
  if string.len( map_chars ) > 0 then
    local decode_search = {}
    local decode_translate = {}
    for i = 1, string.len( map_chars ) do
      local from = string_sub( reserved_chars, i, i )
      local to = string_sub( map_chars, i, i )
      encode_translate[ from ] = to
      encode_search[ table.getn( encode_search ) + 1 ] = from
      decode_translate[ to ] = from
      decode_search[ table.getn( decode_search ) + 1 ] = to
    end
    decode_patterns[ table.getn( decode_patterns ) + 1 ] =
        "([" .. escape_for_gsub( table_concat( decode_search ) ) .. "])"
    decode_repls[ table.getn( decode_repls ) + 1 ] = decode_translate
  end

  local escape_char_index = 1
  local escape_char = string_sub( escape_chars
  , escape_char_index, escape_char_index )
  -- map single byte to double-byte
  local r = 0 -- suffix char value to the escapeChar

  local decode_search = {}
  local decode_translate = {}
  for i = 1, string.len( encode_bytes ) do
    local c = string_sub( encode_bytes, i, i )
    if not encode_translate[ c ] then
      while r >= 256 or taken[ r ] do
        r = r + 1
        if r > 255 then -- switch to next escapeChar
          decode_patterns[ table.getn( decode_patterns ) + 1 ] =
              escape_for_gsub( escape_char )
              .. "(["
              .. escape_for_gsub( table_concat( decode_search ) ) .. "])"
          decode_repls[ table.getn( decode_repls ) + 1 ] = decode_translate

          escape_char_index = escape_char_index + 1
          escape_char = string_sub( escape_chars, escape_char_index
          , escape_char_index )
          r = 0
          decode_search = {}
          decode_translate = {}

          if not escape_char or escape_char == "" then
            -- actually I don't need to check
            -- "not ecape_char", but what if Lua changes
            -- the behavior of string.sub() in the future?
            -- we are out of escape chars and we need more!
            return nil, "Out of escape characters."
          end
        end
      end

      local char_r = _byte_to_char[ r ]
      encode_translate[ c ] = escape_char .. char_r
      encode_search[ table.getn( encode_search ) + 1 ] = c
      decode_translate[ char_r ] = c
      decode_search[ table.getn( decode_search ) + 1 ] = char_r
      r = r + 1
    end
    if i == string.len( encode_bytes ) then
      decode_patterns[ table.getn( decode_patterns ) + 1 ] =
          escape_for_gsub( escape_char ) .. "(["
          .. escape_for_gsub( table_concat( decode_search ) ) .. "])"
      decode_repls[ table.getn( decode_repls ) + 1 ] = decode_translate
    end
  end

  local codec = {}

  local encode_pattern = "(["
      .. escape_for_gsub( table_concat( encode_search ) ) .. "])"
  local encode_repl = encode_translate

  function codec:Encode( str )
    if type( str ) ~= "string" then
      error( string.format( "Usage: codec:Encode(str):"
        .. " 'str' - string expected got '%s'.", type( str ) ), 2 )
    end
    return string_gsub( str, encode_pattern, encode_repl )
  end

  local decode_tblsize = table.getn( decode_patterns )
  local decode_fail_pattern = "(["
      .. escape_for_gsub( reserved_chars ) .. "])"

  function codec:Decode( str )
    if type( str ) ~= "string" then
      error( string.format( "Usage: codec:Decode(str):"
        .. " 'str' - string expected got '%s'.", type( str ) ), 2 )
    end
    if string_find( str, decode_fail_pattern ) then
      return nil
    end
    for i = 1, decode_tblsize do
      str = string_gsub( str, decode_patterns[ i ], decode_repls[ i ] )
    end
    return str
  end

  return codec
end

local _addon_channel_codec

local function GenerateWoWAddonChannelCodec()
  return LibDeflate:CreateCodec( "\000", "\001", "" )
end

--- Encode the string to make it ready to be transmitted in World of
-- Warcraft addon channel. <br>
-- The encoded string is guaranteed to contain no NULL ("\000") character.
-- @param str [string] The string to be encoded.
-- @return The encoded string.
-- @see LibDeflate:DecodeForWoWAddonChannel
function LibDeflate:EncodeForWoWAddonChannel( str )
  if type( str ) ~= "string" then
    error( string.format( "Usage: LibDeflate:EncodeForWoWAddonChannel(str):"
      .. " 'str' - string expected got '%s'.", type( str ) ), 2 )
  end
  if not _addon_channel_codec then
    _addon_channel_codec = GenerateWoWAddonChannelCodec()
  end
  return _addon_channel_codec:Encode( str )
end

--- Decode the string produced by LibDeflate:EncodeForWoWAddonChannel
-- @param str [string] The string to be decoded.
-- @return [string/nil] The decoded string if succeeds. nil if fails.
-- @see LibDeflate:EncodeForWoWAddonChannel
function LibDeflate:DecodeForWoWAddonChannel( str )
  if type( str ) ~= "string" then
    error( string.format( "Usage: LibDeflate:DecodeForWoWAddonChannel(str):"
      .. " 'str' - string expected got '%s'.", type( str ) ), 2 )
  end
  if not _addon_channel_codec then
    _addon_channel_codec = GenerateWoWAddonChannelCodec()
  end
  return _addon_channel_codec:Decode( str )
end

-- For World of Warcraft Chat Channel Encoding
-- Credits to LibCompress.
-- The code has been rewritten by the author of LibDeflate. <br>
-- Following byte values are not allowed:
-- \000, s, S, \010, \013, \124, %
-- Because SendChatMessage will error
-- if an UTF8 multibyte character is incomplete,
-- all character values above 127 have to be encoded to avoid this.
-- This costs quite a bit of bandwidth (about 13-14%)
-- Also, because drunken status is unknown for the received
-- , strings used with SendChatMessage should be terminated with
-- an identifying byte value, after which the server MAY add "...hic!"
-- or as much as it can fit(!).
-- Pass the identifying byte as a reserved character to this function
-- to ensure the encoding doesn't contain that value.
-- or use this: local message, match = arg1:gsub("^(.*)\029.-$", "%1")
-- arg1 is message from channel, \029 is the string terminator
-- , but may be used in the encoded datastream as well. :-)
-- This encoding will expand data anywhere from:
-- 0% (average with pure ascii text)
-- 53.5% (average with random data valued zero to 255)
-- 100% (only encoding data that encodes to two bytes)
local function GenerateWoWChatChannelCodec()
  local r = {}
  for i = 128, 255 do
    r[ table.getn( r ) + 1 ] = _byte_to_char[ i ]
  end

  local reserved_chars = "sS\000\010\013\124%" .. table_concat( r )
  return LibDeflate:CreateCodec( reserved_chars
  , "\029\031", "\015\020" )
end

local _chat_channel_codec

--- Encode the string to make it ready to be transmitted in World of
-- Warcraft chat channel. <br>
-- See also https://wow.gamepedia.com/ValidChatMessageCharacters
-- @param str [string] The string to be encoded.
-- @return [string] The encoded string.
-- @see LibDeflate:DecodeForWoWChatChannel
function LibDeflate:EncodeForWoWChatChannel( str )
  if type( str ) ~= "string" then
    error( string.format( "Usage: LibDeflate:EncodeForWoWChatChannel(str):"
      .. " 'str' - string expected got '%s'.", type( str ) ), 2 )
  end
  if not _chat_channel_codec then
    _chat_channel_codec = GenerateWoWChatChannelCodec()
  end
  return _chat_channel_codec:Encode( str )
end

--- Decode the string produced by LibDeflate:EncodeForWoWChatChannel.
-- @param str [string] The string to be decoded.
-- @return [string/nil] The decoded string if succeeds. nil if fails.
-- @see LibDeflate:EncodeForWoWChatChannel
function LibDeflate:DecodeForWoWChatChannel( str )
  if type( str ) ~= "string" then
    error( string.format( "Usage: LibDeflate:DecodeForWoWChatChannel(str):"
      .. " 'str' - string expected got '%s'.", type( str ) ), 2 )
  end
  if not _chat_channel_codec then
    _chat_channel_codec = GenerateWoWChatChannelCodec()
  end
  return _chat_channel_codec:Decode( str )
end

-- Credits to WeakAuras2 and Galmok for the 6 bit encoding algorithm.
-- The code has been rewritten by the author of LibDeflate.
-- The result of encoding will be 25% larger than the
-- origin string, but every single byte of the encoding result will be
-- printable characters as the following.
local _byte_to_6bit_char = {
  [ 0 ] = "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "(",
  ")",
}

local _6bit_to_byte = {
  [ 97 ] = 0,
  [ 98 ] = 1,
  [ 99 ] = 2,
  [ 100 ] = 3,
  [ 101 ] = 4,
  [ 102 ] = 5,
  [ 103 ] = 6,
  [ 104 ] = 7,
  [ 105 ] = 8,
  [ 106 ] = 9,
  [ 107 ] = 10,
  [ 108 ] = 11,
  [ 109 ] = 12,
  [ 110 ] = 13,
  [ 111 ] = 14,
  [ 112 ] = 15,
  [ 113 ] = 16,
  [ 114 ] = 17,
  [ 115 ] = 18,
  [ 116 ] = 19,
  [ 117 ] = 20,
  [ 118 ] = 21,
  [ 119 ] = 22,
  [ 120 ] = 23,
  [ 121 ] = 24,
  [ 122 ] = 25,
  [ 65 ] = 26,
  [ 66 ] = 27,
  [ 67 ] = 28,
  [ 68 ] = 29,
  [ 69 ] = 30,
  [ 70 ] = 31,
  [ 71 ] = 32,
  [ 72 ] = 33,
  [ 73 ] = 34,
  [ 74 ] = 35,
  [ 75 ] = 36,
  [ 76 ] = 37,
  [ 77 ] = 38,
  [ 78 ] = 39,
  [ 79 ] = 40,
  [ 80 ] = 41,
  [ 81 ] = 42,
  [ 82 ] = 43,
  [ 83 ] = 44,
  [ 84 ] = 45,
  [ 85 ] = 46,
  [ 86 ] = 47,
  [ 87 ] = 48,
  [ 88 ] = 49,
  [ 89 ] = 50,
  [ 90 ] = 51,
  [ 48 ] = 52,
  [ 49 ] = 53,
  [ 50 ] = 54,
  [ 51 ] = 55,
  [ 52 ] = 56,
  [ 53 ] = 57,
  [ 54 ] = 58,
  [ 55 ] = 59,
  [ 56 ] = 60,
  [ 57 ] = 61,
  [ 40 ] = 62,
  [ 41 ] = 63,
}

--- Encode the string to make it printable. <br>
--
-- Credit to WeakAuras2, this function is equivalant to the implementation
-- it is using right now. <br>
-- The code has been rewritten by the author of LibDeflate. <br>
-- The encoded string will be 25% larger than the origin string. However, every
-- single byte of the encoded string will be one of 64 printable ASCII
-- characters, which are can be easier copied, pasted and displayed.
-- (26 lowercase letters, 26 uppercase letters, 10 numbers digits,
-- left parenthese, or right parenthese)
-- @param str [string] The string to be encoded.
-- @return [string] The encoded string.
function LibDeflate:EncodeForPrint( str )
  if type( str ) ~= "string" then
    error( string.format( "Usage: LibDeflate:EncodeForPrint(str):"
      .. " 'str' - string expected got '%s'.", type( str ) ), 2 )
  end
  local strlen = string.len( str )
  local strlenMinus2 = strlen - 2
  local i = 1
  local buffer = {}
  local buffer_size = 0
  while i <= strlenMinus2 do
    local x1, x2, x3 = string_byte( str, i, i + 2 )
    i = i + 3
    local cache = x1 + x2 * 256 + x3 * 65536
    local b1 = mod( cache, 64 )
    cache = (cache - b1) / 64
    local b2 = mod( cache, 64 )
    cache = (cache - b2) / 64
    local b3 = mod( cache, 64 )
    local b4 = (cache - b3) / 64
    buffer_size = buffer_size + 1
    buffer[ buffer_size ] =
        _byte_to_6bit_char[ b1 ] .. _byte_to_6bit_char[ b2 ]
        .. _byte_to_6bit_char[ b3 ] .. _byte_to_6bit_char[ b4 ]
  end

  local cache = 0
  local cache_bitlen = 0
  while i <= strlen do
    local x = string_byte( str, i, i )
    cache = cache + x * _pow2[ cache_bitlen ]
    cache_bitlen = cache_bitlen + 8
    i = i + 1
  end
  while cache_bitlen > 0 do
    local bit6 = mod( cache, 64 )
    buffer_size = buffer_size + 1
    buffer[ buffer_size ] = _byte_to_6bit_char[ bit6 ]
    cache = (cache - bit6) / 64
    cache_bitlen = cache_bitlen - 6
  end

  return table_concat( buffer )
end

--- Decode the printable string produced by LibDeflate:EncodeForPrint.
-- "str" will have its prefixed and trailing control characters or space
-- removed before it is decoded, so it is easier to use if "str" comes form
-- user copy and paste with some prefixed or trailing spaces.
-- Then decode fails if the string contains any characters cant be produced by
-- LibDeflate:EncodeForPrint. That means, decode fails if the string contains a
-- characters NOT one of 26 lowercase letters, 26 uppercase letters,
-- 10 numbers digits, left parenthese, or right parenthese.
-- @param str [string] The string to be decoded
-- @return [string/nil] The decoded string if succeeds. nil if fails.
function LibDeflate:DecodeForPrint( str )
  if type( str ) ~= "string" then
    error( string.format( "Usage: LibDeflate:DecodeForPrint(str):"
      .. " 'str' - string expected got '%s'.", type( str ) ), 2 )
  end
  str = string.gsub( str, "^[%c ]+", "" )
  str = string.gsub( str, "[%c ]+$", "" )

  local strlen = string.len( str )
  if strlen == 1 then
    return nil
  end
  local strlenMinus3 = strlen - 3
  local i = 1
  local buffer = {}
  local buffer_size = 0
  while i <= strlenMinus3 do
    local x1, x2, x3, x4 = string_byte( str, i, i + 3 )
    x1 = _6bit_to_byte[ x1 ]
    x2 = _6bit_to_byte[ x2 ]
    x3 = _6bit_to_byte[ x3 ]
    x4 = _6bit_to_byte[ x4 ]
    if not (x1 and x2 and x3 and x4) then
      return nil
    end
    i = i + 4
    local cache = x1 + x2 * 64 + x3 * 4096 + x4 * 262144
    local b1 = mod( cache, 256 )
    cache = (cache - b1) / 256
    local b2 = mod( cache, 256 )
    local b3 = (cache - b2) / 256
    buffer_size = buffer_size + 1
    buffer[ buffer_size ] =
        _byte_to_char[ b1 ] .. _byte_to_char[ b2 ] .. _byte_to_char[ b3 ]
  end

  local cache        = 0
  local cache_bitlen = 0
  while i <= strlen do
    local x = string_byte( str, i, i )
    x = _6bit_to_byte[ x ]
    if not x then
      return nil
    end
    cache = cache + x * _pow2[ cache_bitlen ]
    cache_bitlen = cache_bitlen + 6
    i = i + 1
  end

  while cache_bitlen >= 8 do
    local byte = mod( cache, 256 )
    buffer_size = buffer_size + 1
    buffer[ buffer_size ] = _byte_to_char[ byte ]
    cache = (cache - byte) / 256
    cache_bitlen = cache_bitlen - 8
  end

  return table_concat( buffer )
end

local function InternalClearCache()
  _chat_channel_codec = nil
  _addon_channel_codec = nil
end

-- For test. Don't use the functions in this table for real application.
-- Stuffs in this table is subject to change.
LibDeflate.internals = {
  LoadStringToTable = LoadStringToTable,
  IsValidDictionary = IsValidDictionary,
  IsEqualAdler32 = IsEqualAdler32,
  _byte_to_6bit_char = _byte_to_6bit_char,
  _6bit_to_byte = _6bit_to_byte,
  InternalClearCache = InternalClearCache,
}

--[[-- Commandline options
@class table
@name CommandlineOptions
@usage lua LibDeflate.lua [OPTION] [INPUT] [OUTPUT]
\-0    store only. no compression.
\-1    fastest compression.
\-9    slowest and best compression.
\-d    do decompression instead of compression.
\--dict <filename> specify the file that contains
the entire preset dictionary.
\-h    give this help.
\--strategy <fixed/huffman_only/dynamic> specify a special compression strategy.
\-v    print the version and copyright info.
\--zlib  use zlib format instead of raw deflate.
]]

-- currently no plan to support stdin and stdout.
-- Because Lua in Windows does not set stdout with binary mode.
if io and os and debug and _G.arg then
  local io = io
  local os = os
  local debug = debug
  local arg = _G.arg
  local debug_info = debug.getinfo( 1 )
  if debug_info.source == arg[ 0 ]
      or debug_info.short_src == arg[ 0 ] then
    -- We are indeed runnning THIS file from the commandline.
    local input
    local output
    local i = 1
    local status
    local is_zlib = false
    local is_decompress = false
    local level
    local strategy
    local dictionary
    while (arg[ i ]) do
      local a = arg[ i ]
      if a == "-h" then
        print( LibDeflate._COPYRIGHT
          .. "\nUsage: lua LibDeflate.lua [OPTION] [INPUT] [OUTPUT]\n"
          .. "  -0    store only. no compression.\n"
          .. "  -1    fastest compression.\n"
          .. "  -9    slowest and best compression.\n"
          .. "  -d    do decompression instead of compression.\n"
          .. "  --dict <filename> specify the file that contains"
          .. " the entire preset dictionary.\n"
          .. "  -h    give this help.\n"
          .. "  --strategy <fixed/huffman_only/dynamic>"
          .. " specify a special compression strategy.\n"
          .. "  -v    print the version and copyright info.\n"
          .. "  --zlib  use zlib format instead of raw deflate.\n" )
        os.exit( 0 )
      elseif a == "-v" then
        print( LibDeflate._COPYRIGHT )
        os.exit( 0 )
      elseif string.find( a, "^%-[0-9]$" ) then
        level = tonumber( string.sub( a, 2, 2 ) )
      elseif a == "-d" then
        is_decompress = true
      elseif a == "--dict" then
        i = i + 1
        local dict_filename = arg[ i ]
        if not dict_filename then
          io.stderr:write( "You must speicify the dict filename" )
          os.exit( 1 )
        end
        local dict_file, dict_status = io.open( dict_filename, "rb" )
        if not dict_file then
          io.stderr:write(
            string.format( "LibDeflate: Cannot read the dictionary file '%s': %s", dict_filename, dict_status ) )
          os.exit( 1 )
        end
        local dict_str = dict_file:read( "*all" )
        dict_file:close()
        -- In your lua program, you should pass in adler32 as a CONSTANT
        -- , so it actually prevent you from modifying dictionary
        -- unintentionally during the program development. I do this
        -- here just because no convenient way to verify in commandline.
        dictionary = LibDeflate:CreateDictionary( dict_str,
          string.len( dict_str ), LibDeflate:Adler32( dict_str ) )
      elseif a == "--strategy" then
        -- Not sure if I should check error here
        -- If I do, redudant code.
        i = i + 1
        strategy = arg[ i ]
      elseif a == "--zlib" then
        is_zlib = true
      elseif string.find( a, "^%-" ) then
        io.stderr:write( string.format( "LibDeflate: Invalid argument: %s", a ) )
        os.exit( 1 )
      else
        if not input then
          input, status = io.open( a, "rb" )
          if not input then
            io.stderr:write(
              string.format( "LibDeflate: Cannot read the file '%s': %s", a, tostring( status ) ) )
            os.exit( 1 )
          end
        elseif not output then
          output, status = io.open( a, "wb" )
          if not output then
            io.stderr:write(
              string.format( "LibDeflate: Cannot write the file '%s': %s", a, tostring( status ) ) )
            os.exit( 1 )
          end
        end
      end
      i = i + 1
    end -- while (arg[i])

    if not input or not output then
      io.stderr:write( "LibDeflate:"
        .. " You must specify both input and output files." )
      os.exit( 1 )
    end

    local input_data = input:read( "*all" )
    local configs = {
      level = level,
      strategy = strategy,
    }
    local output_data
    if not is_decompress then
      if not is_zlib then
        if not dictionary then
          output_data =
              LibDeflate:CompressDeflate( input_data, configs )
        else
          output_data =
              LibDeflate:CompressDeflateWithDict( input_data, dictionary
              , configs )
        end
      else
        if not dictionary then
          output_data =
              LibDeflate:CompressZlib( input_data, configs )
        else
          output_data =
              LibDeflate:CompressZlibWithDict( input_data, dictionary
              , configs )
        end
      end
    else
      if not is_zlib then
        if not dictionary then
          output_data = LibDeflate:DecompressDeflate( input_data )
        else
          output_data = LibDeflate:DecompressDeflateWithDict(
            input_data, dictionary )
        end
      else
        if not dictionary then
          output_data = LibDeflate:DecompressZlib( input_data )
        else
          output_data = LibDeflate:DecompressZlibWithDict(
            input_data, dictionary )
        end
      end
    end

    if not output_data then
      io.stderr:write( "LibDeflate: Decompress fails." )
      os.exit( 1 )
    end

    output:write( output_data )
    if input and input ~= io.stdin then
      input:close()
    end
    if output and output ~= io.stdout then
      output:close()
    end

    io.stderr:write( string.format( "Successfully writes %d bytes", output_data:len() ) )
    os.exit( 0 )
  end
end

return LibDeflate

================
File: Libs/vanilla/LibDeflate/LibDeflate.toc
================
## Interface: 80300
## Title: Lib: LibDeflate
## Notes: Compressor and decompressor with high compression ratio using DEFLATE/zlib format.
## Author: Haoqian He (WoW: Safetyy at Illidan-US (Horde))
## Version: @project-version@
## X-Website: https://wow.curseforge.com/projects/libdeflate
## X-Category: Library
## X-License: zlib

LibStub\LibStub.lua
lib.xml

================
File: Libs/vanilla/LibDeflate/tests/LibCompress/LibCompress.lua
================
----------------------------------------------------------------------------------
-- The author of LibDeflate does NOT write this file (LibCompress.lua)
-- The official website of LibCompress is
-- https://www.wowace.com/projects/libcompress/files
-- This file comes from r84-release, as listed on the URL below.
-- https://www.wowace.com/projects/libcompress/files/2578977
-- (The origin author forgot to bump version number. So you can see
-- "Revision: $Revision: 83 $" in the comments below.)
--
-- However, since LibCompress calls several World of Warcraft APIs, the author
-- of LibDeflate does a small modification to this file,
-- so this file can be run in a standard Lua 5.1.5 or LuaJIT interpreter.
--
-- Note that this file does NOT support Lua 5.2 and Lua 5.3.
--
-- LibDeflate does not use LibCompress to check the correctness of LibDeflate.
-- LibCompress is used for performance evaluation purposes.
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--
-- LibCompress.lua
--
-- Authors: jjsheets and Galmok of European Stormrage (Horde)
-- Email : sheets.jeff@gmail.com and galmok@gmail.com
-- Licence: GPL version 2 (General Public License)
-- Revision: $Revision: 83 $
-- Date: $Date: 2018-07-03 14:33:48 +0000 (Tue, 03 Jul 2018) $
----------------------------------------------------------------------------------


--local LibCompress = LibStub:NewLibrary("LibCompress", 90000 + tonumber(("$Revision: 83 $"):match("%d+")))

--if not LibCompress then return end

local LibCompress = {}

-- list of codecs in this file:
-- \000 - Never used
-- \001 - Uncompressed
-- \002 - LZW
-- \003 - Huffman


-- local is faster than global
--local CreateFrame = CreateFrame
local type = type
local tostring = tostring
local select = select
local next = next
local loadstring = loadstring
local setmetatable = setmetatable
local rawset = rawset
local assert = assert
local table_insert = table.insert
local table_remove = table.remove
local table_concat = table.concat
local table_sort = table.sort
local string_char = string.char
local string_byte = string.byte
local string_len = string.len
local string_sub = string.sub
local unpack = unpack
local pairs = pairs
local math_modf = math.modf

local bit = require("bit")
local bit_band = bit.band
local bit_bor = bit.bor
local bit_bxor = bit.bxor
local bit_bnot = bit.bnot
local bit_lshift = bit.lshift
local bit_rshift = bit.rshift

--------------------------------------------------------------------------------
-- Cleanup

local tables = {} -- tables that may be cleaned have to be kept here
local tables_to_clean = {} -- list of tables by name (string) that may be reset to {} after a timeout

-- tables that may be erased
local function cleanup()
	for k,v in pairs(tables_to_clean) do
		tables[k] = {}
		tables_to_clean[k] = nil
	end
end

local timeout = -1
local function onUpdate(frame, elapsed)
	--frame:Hide()
	timeout = timeout - elapsed
	if timeout <= 0 then
		cleanup()
	end
end

--LibCompress.frame = LibCompress.frame or CreateFrame("frame", nil, UIParent) -- reuse the old frame
--LibCompress.frame:SetScript("OnUpdate", onUpdate)
--LibCompress.frame:Hide()

local function setCleanupTables(...)
	timeout = 15 -- empty tables after 15 seconds
	--if not LibCompress.frame:IsShown() then
		--LibCompress.frame:Show()
	--end
	for i = 1, select("#",...) do
		tables_to_clean[(select(i, ...))] = true
	end
end

----------------------------------------------------------------------
----------------------------------------------------------------------
--
-- compression algorithms

--------------------------------------------------------------------------------
-- LZW codec
-- implemented by sheets.jeff@gmail.com

-- encode is used to uniquely encode a number into a sequence of bytes that can be decoded using decode()
-- the bytes returned by this do not contain "\000"
local bytes = {}
local function encode(x)
	for k = 1, #bytes do
		bytes[k] = nil
	end

	bytes[#bytes + 1] = x % 255
	x=math.floor(x/255)

	while x > 0 do
		bytes[#bytes + 1] = x % 255
		x=math.floor(x/255)
	end
	if #bytes == 1 and bytes[1] > 0 and bytes[1] < 250 then
		return string_char(bytes[1])
	else
		for i = 1, #bytes do
			bytes[i] = bytes[i] + 1
		end
		return string_char(256 - #bytes, unpack(bytes))
	end
end

--decode converts a unique character sequence into its equivalent number, from ss, beginning at the ith char.
-- returns the decoded number and the count of characters used in the decode process.
local function decode(ss, i)
	i = i or 1
	local a = string_byte(ss, i, i)
	if a > 249 then
		local r = 0
		a = 256 - a
		for n = i + a, i + 1, -1 do
			r = r * 255 + string_byte(ss, n, n) - 1
		end
		return r, a + 1
	else
		return a, 1
	end
end

-- Compresses the given uncompressed string.
-- Unless the uncompressed string starts with "\002", this is guaranteed to return a string equal to or smaller than
-- the passed string.
-- the returned string will only contain "\000" characters in rare circumstances, and will contain none if the
-- source string has none.
local dict = {}
function LibCompress:CompressLZW(uncompressed)
	if type(uncompressed) == "string" then
		local dict_size = 256
		for k in pairs(dict) do
			dict[k] = nil
		end

		local result = {"\002"}
		local w = ''
		local ressize = 1

		for i = 0, 255 do
			dict[string_char(i)] = i
		end

		for i = 1, #uncompressed do
			local c = uncompressed:sub(i, i)
			local wc = w..c
			if dict[wc] then
				w = wc
			else
				dict[wc] = dict_size
				dict_size = dict_size + 1
				local r = encode(dict[w])
				ressize = ressize + #r
				result[#result + 1] = r
				w = c
			end
		end

		if w then
			local r = encode(dict[w])
			ressize = ressize + #r
			result[#result + 1] = r
		end

		if (#uncompressed + 1) > ressize then
			return table_concat(result)
		else
			return string_char(1)..uncompressed
		end
	else
		return nil, "Can only compress strings"
	end
end

-- if the passed string is a compressed string, this will decompress it and return the decompressed string.
-- Otherwise it return an error message
-- compressed strings are marked by beginning with "\002"
function LibCompress:DecompressLZW(compressed)
	if type(compressed) == "string" then
		if compressed:sub(1, 1) ~= "\002" then
			return nil, "Can only decompress LZW compressed data ("..tostring(compressed:sub(1, 1))..")"
		end

		compressed = compressed:sub(2)
		local dict_size = 256

		for k in pairs(dict) do
			dict[k] = nil
		end

		for i = 0, 255 do
			dict[i] = string_char(i)
		end

		local result = {}
		local t = 1
		local delta, k
		k, delta = decode(compressed, t)
		t = t + delta
		result[#result + 1] = dict[k]

		local w = dict[k]
		local entry
		while t <= #compressed do
			k, delta = decode(compressed, t)
			t = t + delta
			entry = dict[k] or (w..w:sub(1, 1))
			result[#result + 1] = entry
			dict[dict_size] = w..entry:sub(1, 1)
			dict_size = dict_size + 1
			w = entry
		end
		return table_concat(result)
	else
		return nil, "Can only uncompress strings"
	end
end


--------------------------------------------------------------------------------
-- Huffman codec
-- implemented by Galmok of European Stormrage (Horde), galmok@gmail.com

local function addCode(tree, bcode, length)
	if tree then
		tree.bcode = bcode
		tree.blength = length
		if tree.c1 then
			addCode(tree.c1, bit_bor(bcode, bit_lshift(1, length)), length + 1)
		end
		if tree.c2 then
			addCode(tree.c2, bcode, length + 1)
		end
	end
end

local function escape_code(code, length)
	local escaped_code = 0
	local b
	local l = 0
	for i = length -1, 0, - 1 do
		b = bit_band(code, bit_lshift(1, i)) == 0 and 0 or 1
		escaped_code = bit_lshift(escaped_code, 1 + b) + b
		l = l + b
	end
	if length + l > 32 then
		return nil, "escape overflow ("..(length + l)..")"
	end
	return escaped_code, length + l
end

tables.Huffman_compressed = {}
tables.Huffman_large_compressed = {}

local compressed_size = 0
local remainder
local remainder_length
local function addBits(tbl, code, length)
	if remainder_length+length >= 32 then
		-- we have at least 4 bytes to store; bulk it
		remainder = remainder + bit_lshift(code, remainder_length) -- this overflows! Top part of code is lost (but we handle it below)
		-- remainder now holds 4 full bytes to store. So lets do it.
		compressed_size = compressed_size + 1
		tbl[compressed_size] = string_char(bit_band(remainder, 255)) ..
			string_char(bit_band(bit_rshift(remainder, 8), 255)) ..
			string_char(bit_band(bit_rshift(remainder, 16), 255)) ..
			string_char(bit_band(bit_rshift(remainder, 24), 255))
		remainder = 0
		code = bit_rshift(code, 32 - remainder_length)
		length =  remainder_length + length - 32
		remainder_length = 0
	end
	if remainder_length+length >= 16 then
		-- we have at least 2 bytes to store; bulk it
		remainder = remainder + bit_lshift(code, remainder_length)
		remainder_length = length + remainder_length
		-- remainder now holds at least 2 full bytes to store. So lets do it.
		compressed_size = compressed_size + 1
		tbl[compressed_size] = string_char(bit_band(remainder, 255)) .. string_char(bit_band(bit_rshift(remainder, 8), 255))
		remainder = bit_rshift(remainder, 16)
		code = remainder
		length = remainder_length - 16
		remainder = 0
		remainder_length = 0
	end
	remainder = remainder + bit_lshift(code, remainder_length)
	remainder_length = length + remainder_length
	if remainder_length >= 8 then
		compressed_size = compressed_size + 1
		tbl[compressed_size] = string_char(bit_band(remainder, 255))
		remainder = bit_rshift(remainder, 8)
		remainder_length = remainder_length -8
	end
end

-- word size for this huffman algorithm is 8 bits (1 byte).
-- this means the best compression is representing 1 byte with 1 bit, i.e. compress to 0.125 of original size.
function LibCompress:CompressHuffman(uncompressed)
	if type(uncompressed) ~= "string" then
		return nil, "Can only compress strings"
	end
	if #uncompressed == 0 then
		return "\001"
	end

	-- make histogram
	local hist = {}
	-- don't have to use all data to make the histogram
	local uncompressed_size = string_len(uncompressed)
	local c
	for i = 1, uncompressed_size do
		c = string_byte(uncompressed, i)
		hist[c] = (hist[c] or 0) + 1
	end

	--Start with as many leaves as there are symbols.
	local leafs = {}
	local leaf
	local symbols = {}
	for symbol, weight in pairs(hist) do
		leaf = { symbol=string_char(symbol), weight=weight }
		symbols[symbol] = leaf
		table_insert(leafs, leaf)
	end

	-- Enqueue all leaf nodes into the first queue (by probability in increasing order,
	-- so that the least likely item is in the head of the queue).
	table_sort(leafs, function(a, b)
		if a.weight < b.weight then
			return true
		elseif a.weight > b.weight then
			return false
		else
			return nil
		end
	end)

	local nLeafs = #leafs

	-- create tree
	local huff = {}
	--While there is more than one node in the queues:
	local length, height, li, hi, leaf1, leaf2
	local newNode
	while (#leafs + #huff > 1) do
		-- Dequeue the two nodes with the lowest weight.
		-- Dequeue first
		if not next(huff) then
			li, leaf1 = next(leafs)
			table_remove(leafs, li)
		elseif not next(leafs) then
			hi, leaf1 = next(huff)
			table_remove(huff, hi)
		else
			li, length = next(leafs)
			hi, height = next(huff)
			if length.weight <= height.weight then
				leaf1 = length
				table_remove(leafs, li)
			else
				leaf1 = height
				table_remove(huff, hi)
			end
		end

		-- Dequeue second
		if not next(huff) then
			li, leaf2 = next(leafs)
			table_remove(leafs, li)
		elseif not next(leafs) then
			hi, leaf2 = next(huff)
			table_remove(huff, hi)
		else
			li, length = next(leafs)
			hi, height = next(huff)
			if length.weight <= height.weight then
				leaf2 = length
				table_remove(leafs, li)
			else
				leaf2 = height
				table_remove(huff, hi)
			end
		end

		--Create a new internal node, with the two just-removed nodes as children (either node can be either child) and the sum of their weights as the new weight.
		newNode = {
			c1 = leaf1,
			c2 = leaf2,
			weight = leaf1.weight + leaf2.weight
		}
		table_insert(huff,newNode)
	end

	if #leafs > 0 then
		li, length = next(leafs)
		table_insert(huff, length)
		table_remove(leafs, li)
	end
	huff = huff[1]

	-- assign codes to each symbol
	-- c1 = "0", c2 = "1"
	-- As a common convention, bit '0' represents following the left child and bit '1' represents following the right child.
	-- c1 = left, c2 = right

	addCode(huff, 0, 0)
	if huff then
		huff.bcode = 0
		huff.blength = 1
	end

	-- READING
	-- bitfield = 0
	-- bitfield_len = 0
	-- read byte1
	-- bitfield = bitfield + bit_lshift(byte1, bitfield_len)
	-- bitfield_len = bitfield_len + 8
	-- read byte2
	-- bitfield = bitfield + bit_lshift(byte2, bitfield_len)
	-- bitfield_len = bitfield_len + 8
	-- (use 5 bits)
	--	word = bit_band( bitfield, bit_lshift(1,5)-1)
	--	bitfield = bit_rshift( bitfield, 5)
	--	bitfield_len = bitfield_len - 5
	-- read byte3
	-- bitfield = bitfield + bit_lshift(byte3, bitfield_len)
	-- bitfield_len = bitfield_len + 8

	-- WRITING
	remainder = 0
	remainder_length = 0

	local compressed = tables.Huffman_compressed
	--compressed_size = 0

	-- first byte is version info. 0 = uncompressed, 1 = 8 - bit word huffman compressed
	compressed[1] = "\003"

	-- Header: byte 0 = #leafs, bytes 1-3 = size of uncompressed data
	-- max 2^24 bytes
	length = string_len(uncompressed)
	compressed[2] = string_char(bit_band(nLeafs -1, 255))	-- number of leafs
	compressed[3] = string_char(bit_band(length, 255))			-- bit 0-7
	compressed[4] = string_char(bit_band(bit_rshift(length, 8), 255))	-- bit 8-15
	compressed[5] = string_char(bit_band(bit_rshift(length, 16), 255))	-- bit 16-23
	compressed_size = 5

	-- create symbol/code map
	local escaped_code, escaped_code_len, success, msg
	for symbol, leaf in pairs(symbols) do
		addBits(compressed, symbol, 8)
		escaped_code, escaped_code_len = escape_code(leaf.bcode, leaf.blength)
		if not escaped_code then
			return nil, escaped_code_len
		end
		addBits(compressed, escaped_code, escaped_code_len)
		addBits(compressed, 3, 2)
	end

	-- create huffman code
	local large_compressed = tables.Huffman_large_compressed
	local large_compressed_size = 0
	local ulimit
	for i = 1, length, 200 do
		ulimit = length < (i + 199) and length or (i + 199)

		for sub_i = i, ulimit do
			c = string_byte(uncompressed, sub_i)
			addBits(compressed, symbols[c].bcode, symbols[c].blength)
		end

		large_compressed_size = large_compressed_size + 1
		large_compressed[large_compressed_size] = table_concat(compressed, "", 1, compressed_size)
		compressed_size = 0
	end

	-- add remaining bits (if any)
	if remainder_length > 0 then
		large_compressed_size = large_compressed_size + 1
		large_compressed[large_compressed_size] = string_char(remainder)
	end
	local compressed_string = table_concat(large_compressed, "", 1, large_compressed_size)

	-- is compression worth it? If not, return uncompressed data.
	if (#uncompressed + 1) <= #compressed_string then
		return "\001"..uncompressed
	end

	setCleanupTables("Huffman_compressed", "Huffman_large_compressed")
	return compressed_string
end

-- lookuptable (cached between calls)
local lshiftMask = {}
setmetatable(lshiftMask, {
	__index = function (t, k)
		local v = bit_lshift(1, k)
		rawset(t, k, v)
		return v
	end
})

-- lookuptable (cached between calls)
local lshiftMinusOneMask = {}
setmetatable(lshiftMinusOneMask, {
	__index = function (t, k)
		local v = bit_lshift(1, k) -  1
		rawset(t, k, v)
		return v
	end
})

local function bor64(valueA_high, valueA, valueB_high, valueB)
	return bit_bor(valueA_high, valueB_high),
		bit_bor(valueA, valueB)
end

local function band64(valueA_high, valueA, valueB_high, valueB)
	return bit_band(valueA_high, valueB_high),
		bit_band(valueA, valueB)
end

local function lshift64(value_high, value, lshift_amount)
	if lshift_amount == 0 then
		return value_high, value
	end
	if lshift_amount >= 64 then
		return 0, 0
	end
	if lshift_amount < 32 then
		return bit_bor(bit_lshift(value_high, lshift_amount), bit_rshift(value, 32-lshift_amount)),
			bit_lshift(value, lshift_amount)
	end
	-- 32-63 bit shift
	return bit_lshift(value, lshift_amount), -- builtin modulus 32 on shift amount
		0
end

local function rshift64(value_high, value, rshift_amount)
	if rshift_amount == 0 then
		return value_high, value
	end
	if rshift_amount >= 64 then
		return 0, 0
	end
	if rshift_amount < 32 then
		return bit_rshift(value_high, rshift_amount),
			bit_bor(bit_lshift(value_high, 32-rshift_amount), bit_rshift(value, rshift_amount))
	end
	-- 32-63 bit shift
	return 0,
		bit_rshift(value_high, rshift_amount)
end

local function getCode2(bitfield_high, bitfield, field_len)
	if field_len >= 2 then
		-- [bitfield_high..bitfield]: bit 0 is right most in bitfield. bit <field_len-1> is left most in bitfield_high
		local b1, b2, remainder_high, remainder
		for i = 0, field_len - 2 do
			b1 = i <= 31 and bit_band(bitfield, bit_lshift(1, i)) or bit_band(bitfield_high, bit_lshift(1, i)) -- for shifts, 32 = 0 (5 bit used)
			b2 = (i+1) <= 31 and bit_band(bitfield, bit_lshift(1, i+1)) or bit_band(bitfield_high, bit_lshift(1, i+1))
			if not (b1 == 0) and not (b2 == 0) then
				-- found 2 bits set right after each other (stop bits) with i pointing at the first stop bit
				-- return the two bitfields separated by the two stopbits (3 values for each: bitfield_high, bitfield, field_len)
				-- bits left: field_len - (i+2)
				remainder_high, remainder = rshift64(bitfield_high, bitfield, i+2)
				-- first bitfield is the lower part
				return (i-1) >= 32 and bit_band(bitfield_high, bit_lshift(1, i) - 1) or 0,
					i >= 32 and bitfield or bit_band(bitfield, bit_lshift(1, i) - 1),
					i,
					remainder_high,
					remainder,
					field_len-(i+2)
			end
		end
	end
	return nil
end

local function unescape_code(code, code_len)
	local unescaped_code = 0
	local b
	local l = 0
	local i = 0
	while i < code_len do
		b = bit_band( code, lshiftMask[i])
		if not (b == 0) then
			unescaped_code = bit_bor(unescaped_code, lshiftMask[l])
			i = i + 1
		end
		i = i + 1
		l = l + 1
	end
	return unescaped_code, l
end

tables.Huffman_uncompressed = {}
tables.Huffman_large_uncompressed = {} -- will always be as big as the largest string ever decompressed. Bad, but clearing it every time takes precious time.

function LibCompress:DecompressHuffman(compressed)
	if not type(compressed) == "string" then
		return nil, "Can only uncompress strings"
	end

	local compressed_size = #compressed
	--decode header
	local info_byte = string_byte(compressed)
	-- is data compressed
	if info_byte == 1 then
		return compressed:sub(2) --return uncompressed data
	end
	if not (info_byte == 3) then
		return nil, "Can only decompress Huffman compressed data ("..tostring(info_byte)..")"
	end

	local num_symbols = string_byte(string_sub(compressed, 2, 2)) + 1
	local c0 = string_byte(string_sub(compressed, 3, 3))
	local c1 = string_byte(string_sub(compressed, 4, 4))
	local c2 = string_byte(string_sub(compressed, 5, 5))
	local orig_size = c2 * 65536 + c1 * 256 + c0
	if orig_size == 0 then
		return ""
	end

	-- decode code -> symbol map
	local bitfield = 0
	local bitfield_high = 0
	local bitfield_len = 0
	local map = {} -- only table not reused in Huffman decode.
	setmetatable(map, {
		__index = function (t, k)
			local v = {}
			rawset(t, k, v)
			return v
		end
	})

	local i = 6 -- byte 1-5 are header bytes
	local c, cl
	local minCodeLen = 1000
	local maxCodeLen = 0
	local symbol, code_high, code, code_len, temp_high, temp, _bitfield_high, _bitfield, _bitfield_len
	local n = 0
	local state = 0 -- 0 = get symbol (8 bits),  1 = get code (varying bits, ends with 2 bits set)
	while n < num_symbols do
		if i > compressed_size then
			return nil, "Cannot decode map"
		end

		c = string_byte(compressed, i)
		temp_high, temp = lshift64(0, c, bitfield_len)
		bitfield_high, bitfield = bor64(bitfield_high, bitfield, temp_high, temp)
		bitfield_len = bitfield_len + 8

		if state == 0 then
			symbol = bit_band(bitfield, 255)
			bitfield_high, bitfield = rshift64(bitfield_high, bitfield, 8)
			bitfield_len = bitfield_len - 8
			state = 1 -- search for code now
		else
			code_high, code, code_len, _bitfield_high, _bitfield, _bitfield_len = getCode2(bitfield_high, bitfield, bitfield_len)
			if code_high then
				bitfield_high, bitfield, bitfield_len = _bitfield_high, _bitfield, _bitfield_len
				if code_len > 32 then
					return nil, "Unsupported symbol code length ("..code_len..")"
				end
				c, cl = unescape_code(code, code_len)
				map[cl][c] = string_char(symbol)
				minCodeLen = cl < minCodeLen and cl or minCodeLen
				maxCodeLen = cl > maxCodeLen and cl or maxCodeLen
				--print("symbol: "..string_char(symbol).."  code: "..tobinary(c, cl))
				n = n + 1
				state = 0 -- search for next symbol (if any)
			end
		end
		i = i + 1
	end

	-- don't create new subtables for entries not in the map. Waste of space.
	-- But do return an empty table to prevent runtime errors. (instead of returning nil)
	local mt = {}
	setmetatable(map, {
		__index = function (t, k)
			return mt
		end
	})

	local uncompressed = tables.Huffman_uncompressed
	local large_uncompressed = tables.Huffman_large_uncompressed
	local uncompressed_size = 0
	local large_uncompressed_size = 0
	local test_code
	local test_code_len = minCodeLen
	local dec_size = 0
	compressed_size = compressed_size + 1
	local temp_limit = 200 -- first limit of uncompressed data. large_uncompressed will hold strings of length 200
	temp_limit = temp_limit > orig_size and orig_size or temp_limit

	while true do
		if test_code_len <= bitfield_len then
			test_code = bit_band( bitfield, lshiftMinusOneMask[test_code_len])
			symbol = map[test_code_len][test_code]

			if symbol then
				uncompressed_size = uncompressed_size + 1
				uncompressed[uncompressed_size] = symbol
				dec_size = dec_size + 1
				if dec_size >= temp_limit then
					if dec_size >= orig_size then -- checked here for speed reasons
						break
					end
					-- process compressed bytes in smaller chunks
					large_uncompressed_size = large_uncompressed_size + 1
					large_uncompressed[large_uncompressed_size] = table_concat(uncompressed, "", 1, uncompressed_size)
					uncompressed_size = 0
					temp_limit = temp_limit + 200 -- repeated chunk size is 200 uncompressed bytes
					temp_limit = temp_limit > orig_size and orig_size or temp_limit
				end

				bitfield = bit_rshift(bitfield, test_code_len)
				bitfield_len = bitfield_len - test_code_len
				test_code_len = minCodeLen
			else
				test_code_len = test_code_len + 1
				if test_code_len > maxCodeLen then
					return nil, "Decompression error at "..tostring(i).."/"..tostring(#compressed)
				end
			end
		else
			c = string_byte(compressed, i)
			bitfield = bitfield + bit_lshift(c or 0, bitfield_len)
			bitfield_len = bitfield_len + 8
			if i > compressed_size then
				break
			end
			i = i + 1
		end
	end

	setCleanupTables("Huffman_uncompressed", "Huffman_large_uncompressed")
	return table_concat(large_uncompressed, "", 1, large_uncompressed_size)..table_concat(uncompressed, "", 1, uncompressed_size)
end

--------------------------------------------------------------------------------
-- Generic codec interface

function LibCompress:Store(uncompressed)
	if type(uncompressed) ~= "string" then
		return nil, "Can only compress strings"
	end
	return "\001"..uncompressed
end

function LibCompress:DecompressUncompressed(data)
	if type(data) ~= "string" then
		return nil, "Can only handle strings"
	end
	if string_byte(data) ~= 1 then
		return nil, "Can only handle uncompressed data"
	end
	return data:sub(2)
end

local compression_methods = {
	[2] = LibCompress.CompressLZW,
	[3] = LibCompress.CompressHuffman
}

local decompression_methods = {
	[1] = LibCompress.DecompressUncompressed,
	[2] = LibCompress.DecompressLZW,
	[3] = LibCompress.DecompressHuffman
}

-- try all compression codecs and return best result
function LibCompress:Compress(data)
	local method = next(compression_methods)
	local result = compression_methods[method](self, data)
	local n
	method = next(compression_methods, method)
	while method do
		n = compression_methods[method](self, data)
		if #n < #result then
			result = n
		end
		method = next(compression_methods, method)
	end
	return result
end

function LibCompress:Decompress(data)
	local header_info = string_byte(data)
	if decompression_methods[header_info] then
		return decompression_methods[header_info](self, data)
	else
		return nil, "Unknown compression method ("..tostring(header_info)..")"
	end
end

----------------------------------------------------------------------
----------------------------------------------------------------------
--
-- Encoding algorithms

--------------------------------------------------------------------------------
-- Prefix encoding algorithm
-- implemented by Galmok of European Stormrage (Horde), galmok@gmail.com

--[[
	Howto: Encode and Decode:

	3 functions are supplied, 2 of them are variants of the first.  They return a table with functions to encode and decode text.

	table, msg = LibCompress:GetEncodeTable(reservedChars, escapeChars,  mapChars)

		reservedChars: The characters in this string will not appear in the encoded data.
		escapeChars: A string of characters used as escape-characters (don't supply more than needed). #escapeChars >= 1
		mapChars: First characters in reservedChars maps to first characters in mapChars.  (#mapChars <= #reservedChars)

	return value:
		table
			if nil then msg holds an error message, otherwise use like this:

			encoded_message = table:Encode(message)
			message = table:Decode(encoded_message)

	GetAddonEncodeTable: Sets up encoding for the addon channel (\000 is encoded)
	GetChatEncodeTable: Sets up encoding for the chat channel (many bytes encoded, see the function for details)

	Except for the mapped characters, all encoding will be with 1 escape character followed by 1 suffix, i.e. 2 bytes.
]]
-- to be able to match any requested byte value, the search string must be preprocessed
-- characters to escape with %:
-- ( ) . % + - * ? [ ] ^ $
-- "illegal" byte values:
-- 0 is replaces %z
local gsub_escape_table = {
	['\000'] = "%z",
	[('(')] = "%(",
	[(')')] = "%)",
	[('.')] = "%.",
	[('%')] = "%%",
	[('+')] = "%+",
	[('-')] = "%-",
	[('*')] = "%*",
	[('?')] = "%?",
	[('[')] = "%[",
	[(']')] = "%]",
	[('^')] = "%^",
	[('$')] = "%$"
}

local function escape_for_gsub(str)
	return str:gsub("([%z%(%)%.%%%+%-%*%?%[%]%^%$])",  gsub_escape_table)
end

function LibCompress:GetEncodeTable(reservedChars, escapeChars, mapChars)
	reservedChars = reservedChars or ""
	escapeChars = escapeChars or ""
	mapChars = mapChars or ""

	-- select a default escape character
	if escapeChars == "" then
		return nil, "No escape characters supplied"
	end

	if #reservedChars < #mapChars then
		return nil, "Number of reserved characters must be at least as many as the number of mapped chars"
	end

	if reservedChars == "" then
		return nil, "No characters to encode"
	end

	-- list of characters that must be encoded
	local encodeBytes = reservedChars..escapeChars..mapChars

	-- build list of bytes not available as a suffix to a prefix byte
	local taken = {}
	for i = 1, string_len(encodeBytes) do
		taken[string_sub(encodeBytes, i, i)] = true
	end

	-- allocate a table to hold encode/decode strings/functions
	local codecTable = {}

	-- the encoding can be a single gsub, but the decoding can require multiple gsubs
	local decode_func_string = {}

	local encode_search = {}
	local encode_translate = {}
	local encode_func
	local decode_search = {}
	local decode_translate = {}
	local decode_func
	local c, r, to, from
	local escapeCharIndex, escapeChar = 0

	-- map single byte to single byte
	if #mapChars > 0 then
		for i = 1, #mapChars do
			from = string_sub(reservedChars, i, i)
			to = string_sub(mapChars, i, i)
			encode_translate[from] = to
			table_insert(encode_search, from)
			decode_translate[to] = from
			table_insert(decode_search, to)
		end
		codecTable["decode_search"..tostring(escapeCharIndex)] = "([".. escape_for_gsub(table_concat(decode_search)).."])"
		codecTable["decode_translate"..tostring(escapeCharIndex)] = decode_translate
		table_insert(decode_func_string, "str = str:gsub(self.decode_search"..tostring(escapeCharIndex)..", self.decode_translate"..tostring(escapeCharIndex)..");")

	end

	-- map single byte to double-byte
	escapeCharIndex = escapeCharIndex + 1
	escapeChar = string_sub(escapeChars, escapeCharIndex, escapeCharIndex)
	r = 0 -- suffix char value to the escapeChar
	decode_search = {}
	decode_translate = {}
	for i = 1, string_len(encodeBytes) do
		c = string_sub(encodeBytes, i, i)
		if not encode_translate[c] then
			-- this loop will update escapeChar and r
			while r >= 256 or taken[string_char(r)] do
				r = r + 1
				if r > 255 then -- switch to next escapeChar
					codecTable["decode_search"..tostring(escapeCharIndex)] = escape_for_gsub(escapeChar).."([".. escape_for_gsub(table_concat(decode_search)).."])"
					codecTable["decode_translate"..tostring(escapeCharIndex)] = decode_translate
					table_insert(decode_func_string, "str = str:gsub(self.decode_search"..tostring(escapeCharIndex)..", self.decode_translate"..tostring(escapeCharIndex)..");")

					escapeCharIndex  = escapeCharIndex + 1
					escapeChar = string_sub(escapeChars, escapeCharIndex, escapeCharIndex)

					if escapeChar == "" then -- we are out of escape chars and we need more!
						return nil, "Out of escape characters"
					end

					r = 0
					decode_search = {}
					decode_translate = {}
				end
			end
			encode_translate[c] = escapeChar..string_char(r)
			table_insert(encode_search, c)
			decode_translate[string_char(r)] = c
			table_insert(decode_search, string_char(r))
			r = r + 1
		end
	end

	if r > 0 then
		codecTable["decode_search"..tostring(escapeCharIndex)] = escape_for_gsub(escapeChar).."([".. escape_for_gsub(table_concat(decode_search)).."])"
		codecTable["decode_translate"..tostring(escapeCharIndex)] = decode_translate
		table_insert(decode_func_string, "str = str:gsub(self.decode_search"..tostring(escapeCharIndex)..", self.decode_translate"..tostring(escapeCharIndex)..");")
	end

	-- change last line from "str = ...;" to "return ...;";
	decode_func_string[#decode_func_string] = decode_func_string[#decode_func_string]:gsub("str = (.*);", "return %1;")
	decode_func_string = "return function(self, str) "..table_concat(decode_func_string).." end"

	encode_search = "([".. escape_for_gsub(table_concat(encode_search)).."])"
	decode_search = escape_for_gsub(escapeChars).."([".. escape_for_gsub(table_concat(decode_search)).."])"

	encode_func = assert(loadstring("return function(self, str) return str:gsub(self.encode_search, self.encode_translate); end"))()
	decode_func = assert(loadstring(decode_func_string))()
	codecTable.encode_search = encode_search
	codecTable.encode_translate = encode_translate
	codecTable.Encode = encode_func
	codecTable.decode_search = decode_search
	codecTable.decode_translate = decode_translate
	codecTable.Decode = decode_func

	codecTable.decode_func_string = decode_func_string -- to be deleted
	return codecTable
end

-- Addons: Call this only once and reuse the returned table for all encodings/decodings.
function LibCompress:GetAddonEncodeTable(reservedChars, escapeChars, mapChars )
	reservedChars = reservedChars or ""
	escapeChars = escapeChars or ""
	mapChars = mapChars or ""
	-- Following byte values are not allowed:
	-- \000
	if escapeChars == "" then
		escapeChars = "\001"
	end
	return self:GetEncodeTable( (reservedChars or "").."\000", escapeChars, mapChars)
end

-- Addons: Call this only once and reuse the returned table for all encodings/decodings.
function LibCompress:GetChatEncodeTable(reservedChars, escapeChars, mapChars)
	reservedChars = reservedChars or ""
	escapeChars = escapeChars or ""
	mapChars = mapChars or ""
	-- Following byte values are not allowed:
	-- \000, s, S, \010, \013, \124, %
	-- Because SendChatMessage will error if an UTF8 multibyte character is incomplete,
	-- all character values above 127 have to be encoded to avoid this. This costs quite a bit of bandwidth (about 13-14%)
	-- Also, because drunken status is unknown for the received, strings used with SendChatMessage should be terminated with
	-- an identifying byte value, after which the server MAY add "...hic!" or as much as it can fit(!).
	-- Pass the identifying byte as a reserved character to this function to ensure the encoding doesn't contain that value.
	--  or use this: local message, match = arg1:gsub("^(.*)\029.-$", "%1")
	--  arg1 is message from channel, \029 is the string terminator, but may be used in the encoded datastream as well. :-)
	-- This encoding will expand data anywhere from:
	-- 0% (average with pure ascii text)
	-- 53.5% (average with random data valued zero to 255)
	-- 100% (only encoding data that encodes to two bytes)
	local r = {}

	for i = 128, 255 do
		table_insert(r, string_char(i))
	end

	reservedChars = "sS\000\010\013\124%"..table_concat(r)..(reservedChars or "")
	if escapeChars == "" then
		escapeChars = "\029\031"
	end

	if mapChars == "" then
		mapChars = "\015\020";
	end
	return self:GetEncodeTable(reservedChars, escapeChars, mapChars)
end

--------------------------------------------------------------------------------
-- 7 bit encoding algorithm
-- implemented by Galmok of European Stormrage (Horde), galmok@gmail.com

-- The encoded data holds values from 0 to 127 inclusive. Additional encoding may be necessary.
-- This algorithm isn't exactly fast and be used with care and consideration

tables.encode7bit = {}

function LibCompress:Encode7bit(str)
	local remainder = 0
	local remainder_length = 0
	local tbl = tables.encode7bit
	local encoded_size = 0
	local length = #str
	for i = 1, length do
		local code = string_byte(str, i)
		remainder = remainder + bit_lshift(code, remainder_length)
		remainder_length = 8 + remainder_length
		while remainder_length >= 7 do
			encoded_size = encoded_size + 1
			tbl[encoded_size] = string_char(bit_band(remainder, 127))
			remainder = bit_rshift(remainder, 7)
			remainder_length = remainder_length -7
		end
	end

	if remainder_length > 0 then
		encoded_size = encoded_size + 1
		tbl[encoded_size] = string_char(remainder)
	end
	setCleanupTables("encode7bit")
	return table_concat(tbl, "", 1, encoded_size)
end

tables.decode8bit = {}

function LibCompress:Decode7bit(str)
	local bit8 = tables.decode8bit
	local decoded_size = 0
	local ch
	local i = 1
	local bitfield_len = 0
	local bitfield = 0
	local length = #str
	while true do
		if bitfield_len >= 8 then
			decoded_size = decoded_size + 1
			bit8[decoded_size] = string_char(bit_band(bitfield, 255))
			bitfield = bit_rshift(bitfield, 8)
			bitfield_len = bitfield_len - 8
		end
		ch = string_byte(str, i)
		bitfield=bitfield + bit_lshift(ch or 0, bitfield_len)
		bitfield_len = bitfield_len + 7
		if i > length then
			break
		end
		i = i + 1
	end
	setCleanupTables("decode8bit")
	return table_concat(bit8, "", 1, decoded_size)
end

----------------------------------------------------------------------
----------------------------------------------------------------------
--
-- Checksum/hash algorithms

--------------------------------------------------------------------------------
-- FCS16/32 checksum algorithms
-- converted from C by Galmok of European Stormrage (Horde), galmok@gmail.com
-- usage:
-- 	code = LibCompress:fcs16init()
--	code = LibCompress:fcs16update(code, data1)
--	code = LibCompress:fcs16update(code, data2)
--	code = LibCompress:fcs16update(code, data...)
--	code = LibCompress:fcs16final(code)
--
--	data = string
--	fcs16 provides a 16 bit checksum, fcs32 provides a 32 bit checksum.


--[[/* The following copyright notice concerns only the FCS hash algorithm
---------------------------------------------------------------------------
Copyright (c) 2003, Dominik Reichl <dominik.reichl@t-online.de>, Germany.
All rights reserved.

Distributed under the terms of the GNU General Public License v2.

This software is provided 'as is' with no explicit or implied warranties
in respect of its properties, including, but not limited to, correctness
and/or fitness for purpose.
---------------------------------------------------------------------------
*/]]
--// FCS-16 algorithm implemented as described in RFC 1331
local FCSINIT16 = 65535
--// Fast 16 bit FCS lookup table
local fcs16tab = { [0]=0, 4489, 8978, 12955, 17956, 22445, 25910, 29887,
	35912, 40385, 44890, 48851, 51820, 56293, 59774, 63735,
	4225, 264, 13203, 8730, 22181, 18220, 30135, 25662,
	40137, 36160, 49115, 44626, 56045, 52068, 63999, 59510,
	8450, 12427, 528, 5017, 26406, 30383, 17460, 21949,
	44362, 48323, 36440, 40913, 60270, 64231, 51324, 55797,
	12675, 8202, 4753, 792, 30631, 26158, 21685, 17724,
	48587, 44098, 40665, 36688, 64495, 60006, 55549, 51572,
	16900, 21389, 24854, 28831, 1056, 5545, 10034, 14011,
	52812, 57285, 60766, 64727, 34920, 39393, 43898, 47859,
	21125, 17164, 29079, 24606, 5281, 1320, 14259, 9786,
	57037, 53060, 64991, 60502, 39145, 35168, 48123, 43634,
	25350, 29327, 16404, 20893, 9506, 13483, 1584, 6073,
	61262, 65223, 52316, 56789, 43370, 47331, 35448, 39921,
	29575, 25102, 20629, 16668, 13731, 9258, 5809, 1848,
	65487, 60998, 56541, 52564, 47595, 43106, 39673, 35696,
	33800, 38273, 42778, 46739, 49708, 54181, 57662, 61623,
	2112, 6601, 11090, 15067, 20068, 24557, 28022, 31999,
	38025, 34048, 47003, 42514, 53933, 49956, 61887, 57398,
	6337, 2376, 15315, 10842, 24293, 20332, 32247, 27774,
	42250, 46211, 34328, 38801, 58158, 62119, 49212, 53685,
	10562, 14539, 2640, 7129, 28518, 32495, 19572, 24061,
	46475, 41986, 38553, 34576, 62383, 57894, 53437, 49460,
	14787, 10314, 6865, 2904, 32743, 28270, 23797, 19836,
	50700, 55173, 58654, 62615, 32808, 37281, 41786, 45747,
	19012, 23501, 26966, 30943, 3168, 7657, 12146, 16123,
	54925, 50948, 62879, 58390, 37033, 33056, 46011, 41522,
	23237, 19276, 31191, 26718, 7393, 3432, 16371, 11898,
	59150, 63111, 50204, 54677, 41258, 45219, 33336, 37809,
	27462, 31439, 18516, 23005, 11618, 15595, 3696, 8185,
	63375, 58886, 54429, 50452, 45483, 40994, 37561, 33584,
	31687, 27214, 22741, 18780, 15843, 11370, 7921, 3960 }

function LibCompress:fcs16init()
	return FCSINIT16
end

function LibCompress:fcs16update(uFcs16, pBuffer)
	local length = string_len(pBuffer)
	for i = 1, length do
		uFcs16 = bit_bxor(bit_rshift(uFcs16,8), fcs16tab[bit_band(bit_bxor(uFcs16, string_byte(pBuffer, i)), 255)])
	end
	return uFcs16
end

function LibCompress:fcs16final(uFcs16)
	return bit_bxor(uFcs16,65535)
end
-- END OF FCS16

--[[/*
---------------------------------------------------------------------------
Copyright (c) 2003, Dominik Reichl <dominik.reichl@t-online.de>, Germany.
All rights reserved.

Distributed under the terms of the GNU General Public License v2.

This software is provided 'as is' with no explicit or implied warranties
in respect of its properties, including, but not limited to, correctness
and/or fitness for purpose.
---------------------------------------------------------------------------
*/]]

--// FCS-32 algorithm implemented as described in RFC 1331

local FCSINIT32 = -1

--// Fast 32 bit FCS lookup table
local fcs32tab = { [0] = 0, 1996959894, -301047508, -1727442502, 124634137, 1886057615, -379345611, -1637575261,
	249268274, 2044508324, -522852066, -1747789432, 162941995, 2125561021, -407360249, -1866523247,
	498536548, 1789927666, -205950648, -2067906082, 450548861, 1843258603, -187386543, -2083289657,
	325883990, 1684777152, -43845254, -1973040660, 335633487, 1661365465, -99664541, -1928851979,
	997073096, 1281953886, -715111964, -1570279054, 1006888145, 1258607687, -770865667, -1526024853,
	901097722, 1119000684, -608450090, -1396901568, 853044451, 1172266101, -589951537, -1412350631,
	651767980, 1373503546, -925412992, -1076862698, 565507253, 1454621731, -809855591, -1195530993,
	671266974, 1594198024, -972236366, -1324619484, 795835527, 1483230225, -1050600021, -1234817731,
	1994146192, 31158534, -1731059524, -271249366, 1907459465, 112637215, -1614814043, -390540237,
	2013776290, 251722036, -1777751922, -519137256, 2137656763, 141376813, -1855689577, -429695999,
	1802195444, 476864866, -2056965928, -228458418, 1812370925, 453092731, -2113342271, -183516073,
	1706088902, 314042704, -1950435094, -54949764, 1658658271, 366619977, -1932296973, -69972891,
	1303535960, 984961486, -1547960204, -725929758, 1256170817, 1037604311, -1529756563, -740887301,
	1131014506, 879679996, -1385723834, -631195440, 1141124467, 855842277, -1442165665, -586318647,
	1342533948, 654459306, -1106571248, -921952122, 1466479909, 544179635, -1184443383, -832445281,
	1591671054, 702138776, -1328506846, -942167884, 1504918807, 783551873, -1212326853, -1061524307,
	-306674912, -1698712650, 62317068, 1957810842, -355121351, -1647151185, 81470997, 1943803523,
	-480048366, -1805370492, 225274430, 2053790376, -468791541, -1828061283, 167816743, 2097651377,
	-267414716, -2029476910, 503444072, 1762050814, -144550051, -2140837941, 426522225, 1852507879,
	-19653770, -1982649376, 282753626, 1742555852, -105259153, -1900089351, 397917763, 1622183637,
	-690576408, -1580100738, 953729732, 1340076626, -776247311, -1497606297, 1068828381, 1219638859,
	-670225446, -1358292148, 906185462, 1090812512, -547295293, -1469587627, 829329135, 1181335161,
	-882789492, -1134132454, 628085408, 1382605366, -871598187, -1156888829, 570562233, 1426400815,
	-977650754, -1296233688, 733239954, 1555261956, -1026031705, -1244606671, 752459403, 1541320221,
	-1687895376, -328994266, 1969922972, 40735498, -1677130071, -351390145, 1913087877, 83908371,
	-1782625662, -491226604, 2075208622, 213261112, -1831694693, -438977011, 2094854071, 198958881,
	-2032938284, -237706686, 1759359992, 534414190, -2118248755, -155638181, 1873836001, 414664567,
	-2012718362, -15766928, 1711684554, 285281116, -1889165569, -127750551, 1634467795, 376229701,
	-1609899400, -686959890, 1308918612, 956543938, -1486412191, -799009033, 1231636301, 1047427035,
	-1362007478, -640263460, 1088359270, 936918000, -1447252397, -558129467, 1202900863, 817233897,
	-1111625188, -893730166, 1404277552, 615818150, -1160759803, -841546093, 1423857449, 601450431,
	-1285129682, -1000256840, 1567103746, 711928724, -1274298825, -1022587231, 1510334235, 755167117 }

function LibCompress:fcs32init()
	return FCSINIT32
end

function LibCompress:fcs32update(uFcs32, pBuffer)
	local length = string_len(pBuffer)
	for i = 1, length do
		uFcs32 = bit_bxor(bit_rshift(uFcs32, 8), fcs32tab[bit_band(bit_bxor(uFcs32, string_byte(pBuffer, i)), 255)])
	end
	return uFcs32
end

function LibCompress:fcs32final(uFcs32)
	return bit_bnot(uFcs32)
end

return LibCompress

================
File: Libs/vanilla/LibDeflate/tests/Test.lua
================
--[[
zlib License

(C) 2018-2020 Haoqian He

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

--]]


-- Run this tests at the folder where LibDeflate.lua located, like this.
-- lua tests/Test.lua
-- Don't run two "tests/Test.lua" at the same time,
-- because they will conflict!!!

package.path = ("?.lua;tests/LibCompress/?.lua;")..(package.path or "")

do
	local test_lua = io.open("tests/Test.lua")
	assert(test_lua
		, "Must run this script in the root folder of LibDeflate repository")
	test_lua:close()
end

local old_globals = {}
for k, v in pairs(_G) do
	old_globals[k] = v
end
local LibDeflate = require("LibDeflate")
for k, v in pairs(_G) do
	assert(v == old_globals[k], "LibDeflate global leak at key: "..tostring(k))
end
for k, v in pairs(old_globals) do
	assert(v == _G[k], "LibDeflate global leak at key: "..tostring(k))
end

-- UnitTests
local lu = require("luaunit")
assert(lu)

local assert = assert
local loadstring = loadstring or load
local math = math
local string = string
local table = table
local collectgarbage = collectgarbage
local os = os
local type = type
local io = io
local print = print
local tostring = tostring
local string_char = string.char
local string_byte = string.byte
local string_len = string.len
local string_sub = string.sub
local unpack = unpack or table.unpack
local table_insert = table.insert
local table_concat = table.concat

math.randomseed(0) -- I don't like true random tests that I cant 100% reproduce.

local _pow2 = {}
do
	local pow = 1
	for i = 0, 32 do
		_pow2[i] = pow
		pow = pow * 2
	end
end

local function DeepCopy(obj)
    local SearchTable = {} -- luacheck: ignore

    local function Func(object)
        if type(object) ~= "table" then
            return object
        end
        local NewTable = {}
        SearchTable[object] = NewTable
        for k, v in pairs(object) do
            NewTable[Func(k)] = Func(v)
        end

        return setmetatable(NewTable, getmetatable(object))
    end

    return Func(obj)
end

local function GetTableSize(t)
	local size = 0
	for _, _ in pairs(t) do
		size = size + 1
	end
	return size
end

local HexToString
local HalfByteToHex
do
	local _byte0 = string_byte("0", 1)
	local _byte9 = string_byte("9", 1)
	local _byteA = string_byte("A", 1)
	local _byteF = string_byte("F", 1)
	local _bytea = string_byte("a", 1)
	local _bytef = string_byte("f", 1)
	function HexToString(str)
		local t = {}
		local val = 1
		for i=1, str:len()+1 do
			local b = string_byte(str, i, i) or -1
			if b >= _byte0 and b <= _byte9 then
				val = val*16 + b - _byte0
			elseif b >= _byteA and b <= _byteF then
				val = val*16 + b - _byteA + 10
			elseif b >= _bytea and b <= _bytef then
				val = val*16 + b - _bytea + 10
			elseif val ~= 1 and val < 32 then  -- one digit followed by delimiter
	            val = val + 240                 -- make it look like two digits
			end
			if val > 255 then
				t[#t+1] = string_char(val % 256)
				val = 1
			end
		end
		return table.concat(t)
	end
	assert(HexToString("f") == string_char(15))
	assert(HexToString("1f") == string_char(31))
	assert(HexToString("1f 2") == string_char(31)..string_char(2))
	assert(HexToString("1f 22") == string_char(31)..string_char(34))
	assert(HexToString("F") == string_char(15))
	assert(HexToString("1F") == string_char(31))
	assert(HexToString("1F 2") == string_char(31)..string_char(2))
	assert(HexToString("1F 22") == string_char(31)..string_char(34))

	assert(HexToString("a") == string_char(10))
	assert(HexToString("1a") == string_char(26))
	assert(HexToString("1a 90") == string_char(26)..string_char(144))
	assert(HexToString("1a 9") == string_char(26)..string_char(9))
	assert(HexToString("A") == string_char(10))
	assert(HexToString("1A") == string_char(26))
	assert(HexToString("1A 09") == string_char(26)..string_char(9))
	assert(HexToString("1A 00") == string_char(26)..string_char(0))

	function HalfByteToHex(half_byte)
		assert (half_byte >= 0 and half_byte < 16)
		if half_byte < 10 then
			return string_char(_byte0 + half_byte)
		else
			return string_char(_bytea + half_byte-10)
		end
	end
end

local function StringToHex(str)
	if not str then
		return "nil"
	end
	local tmp = {}
	for i = 1, str:len() do
		local b = string_byte(str, i, i)
		if b < 16 then
			tmp[#tmp+1] = "0"..HalfByteToHex(b)
		else
			tmp[#tmp+1] = HalfByteToHex((b-b%16)/16)..HalfByteToHex(b%16)
		end
	end
	return table.concat(tmp, " ")
end
assert (StringToHex("\000"), "00")
assert (StringToHex("\000\255"), "00 ff")
assert (StringToHex(HexToString("05 e0 81 91 24 cb b2 2c 49 e2 0f 2e 8b 9a"
	.." 47 56 9f fb fe ec d2 ff 1f"))
	== "05 e0 81 91 24 cb b2 2c 49 e2 0f 2e 8b 9a 47 56 9f fb fe ec d2 ff 1f")

-- Return a string with limited size
local function StringForPrint(str)
	if str:len() < 101 then
		return str
	else
		return str:sub(1, 101)..(" (%d more characters not shown)")
			:format(str:len()-101)
	end
end

local function OpenFile(filename, mode)
	local f = io.open(filename, mode)
	lu.assertNotNil(f, ("Cannot open the file: %s, with mode: %s")
		:format(filename, mode))
	return f
end

local function GetFileData(filename)
	local f = OpenFile(filename, "rb")
	local str = f:read("*all")
	f:close()
	return str
end

local function WriteToFile(filename, data)
	local f = io.open(filename, "wb")
	lu.assertNotNil(f, ("Cannot open the file: %s, with mode: %s")
		:format(filename, "wb"))
	f:write(data)
	f:flush()
	f:close()
end

local function GetLimitedRandomString(strlen)
	local randoms = {}
	for _=1, 7 do
		randoms[#randoms+1] = string.char(math.random(1, 255))
	end
	local tmp = {}
	for _=1, strlen do
		tmp[#tmp+1] = randoms[math.random(1, 7)]
	end
	return table.concat(tmp)
end

local function GetRandomString(strlen)
	local tmp = {}
	for _=1, strlen do
		tmp[#tmp+1] = string_char(math.random(0, 255))
	end
	return table.concat(tmp)
end

-- Get a random string with at least 256 len which includes all characters
local function GetRandomStringUniqueChars(strlen)
	local taken = {}
	local tmp = {}
	for i=0, (strlen < 256) and strlen-1 or 255 do
		local rand = math.random(1, 256-i)
		local count = 0
		for j=0, 255 do
			if (not taken[j]) then
				count = count + 1
			end
			if count == rand then
				taken[j] = true
				tmp[#tmp+1] = string_char(j)
				break
			end
		end
	end
	if strlen > 256 then
		for _=1, strlen-256 do
			table_insert(tmp, math.random(1, #tmp+1)
				, string_char(math.random(0, 255)))
		end
	end
	return table_concat(tmp)
end
assert(GetRandomStringUniqueChars(3):len() == 3)
assert(GetRandomStringUniqueChars(255):len() == 255)
assert(GetRandomStringUniqueChars(256):len() == 256)
assert(GetRandomStringUniqueChars(500):len() == 500)
do
	local taken = {}
	local str = GetRandomStringUniqueChars(256)
	for i=1, 256 do
		local byte = string_byte(str, i, i)
		assert(not taken[byte])
		taken[byte] = true
	end
end

-- Repeatedly collect memory garbarge until memory usage no longer changes
local function FullMemoryCollect()
	local memory_used = collectgarbage("count")
	local last_memory_used
	local stable_count = 0
	repeat
		last_memory_used = memory_used
		collectgarbage("collect")
		memory_used = collectgarbage("count")

		if memory_used >= last_memory_used then
			stable_count = stable_count + 1
		else
			stable_count = 0
		end
	until stable_count == 10
	-- Stop full memory collect until memory does not decrease for 10 times.
end

local function RunProgram(program, input_filename, stdout_filename)
	local stderr_filename = stdout_filename..".stderr"
	local status, _, ret = os.execute(program.." "..input_filename
		.. "> "..stdout_filename.." 2> "..stderr_filename)
	local returned_status
	if type(status) == "number" then -- lua 5.1
		returned_status = status
	else -- Lua 5.2/5.3
		returned_status = ret
		if not status and ret == 0 then
			returned_status = -1
			-- Lua bug on Windows when the returned value is -1, ret is 0
		end
	end
	local stdout = GetFileData(stdout_filename)
	local stderr = GetFileData(stderr_filename)
	return returned_status, stdout, stderr
end

local function AssertLongStringEqual(actual, expected, msg)
	if actual ~= expected then
		lu.assertNotNil(actual, ("%s actual is nil"):format(msg or ""))
		lu.assertNotNil(expected, ("%s expected is nil"):format(msg or ""))
		local diff_index = 1
		for i=1, math.max(expected:len(), actual:len()) do
			if string_byte(actual, i, i) ~= string_byte(expected, i, i) then
				diff_index = i
				break
			end
		end
		local actual_msg = string.format(
			"%s actualLen: %d, expectedLen:%d, first difference at: %d,"
			.." actualByte: %s, expectByte: %s", msg or "", actual:len()
			, expected:len(), diff_index,
			string.byte(actual, diff_index) or "nil",
			string.byte(expected, diff_index) or "nil")
		lu.assertTrue(false, actual_msg)
	end
end

local function MemCheckAndBenchmarkFunc(lib, func_name, ...)
	local memory_before
	local memory_running
	local memory_after
	local start_time
	local elapsed_time
	local ret
	FullMemoryCollect()
	memory_before =  math.floor(collectgarbage("count")*1024)
	FullMemoryCollect()
	start_time = os.clock()
	elapsed_time = -1
	local repeat_count = 0
	while elapsed_time < 0.015 do
		ret = {lib[func_name](lib, ...)}
		elapsed_time = os.clock() - start_time
		repeat_count = repeat_count + 1
	end
	memory_running = math.floor(collectgarbage("count")*1024)
	FullMemoryCollect()
	memory_after = math.floor(collectgarbage("count")*1024)
	local memory_used = memory_running - memory_before
	local memory_leaked = memory_after - memory_before

	return memory_leaked, memory_used
		, elapsed_time*1000/repeat_count, unpack(ret)
end

local function GetFirstBlockType(compressed_data, isZlib)
	local first_block_byte_index = 1
	if isZlib then
		local byte2 = string.byte(compressed_data, 2, 2)
		local has_dict = ((byte2-byte2%32)/32)%2
		if has_dict == 1 then
			first_block_byte_index = 7
		else
			first_block_byte_index = 3
		end
	end
	local first_byte = string.byte(compressed_data
		, first_block_byte_index, first_block_byte_index)
	local bit3 = first_byte % 8
	return (bit3 - bit3 % 2) / 2
end

local function PutRandomBitsInPaddingBits(compressed_data, padding_bitlen)
	if padding_bitlen > 0 then
		local len = #compressed_data
		local last_byte = string.byte(compressed_data, len)
		local random_last_byte = math.random(0, 255)
		random_last_byte = random_last_byte
			- random_last_byte % _pow2[8-padding_bitlen]
		random_last_byte = random_last_byte
			+ last_byte % _pow2[8-padding_bitlen]
		compressed_data = compressed_data:sub(1, len-1)
			..string.char(random_last_byte)
	end
	return compressed_data
end

local dictionary32768_str = GetFileData("tests/dictionary32768.txt")
local dictionary32768 = LibDeflate:CreateDictionary(dictionary32768_str
	, 32768, 4072834167)

local _CheckCompressAndDecompressCounter = 0
local function CheckCompressAndDecompress(string_or_filename, is_file, levels
	, strategy, output_prefix)

	-- For 100% code coverage
	if _CheckCompressAndDecompressCounter % 3 == 0 then
		LibDeflate.internals.InternalClearCache()
	end
	if _CheckCompressAndDecompressCounter % 2 == 0 then
		-- Init cache table in these functions
		-- , to help memory leak check in the following codes.
		LibDeflate:EncodeForWoWAddonChannel("")
		LibDeflate:EncodeForWoWChatChannel("")
	else
		LibDeflate:DecodeForWoWAddonChannel("")
		LibDeflate:DecodeForWoWChatChannel("")
	end
	_CheckCompressAndDecompressCounter = _CheckCompressAndDecompressCounter + 1

	local origin
	if is_file then
		origin = GetFileData(string_or_filename)
	else
		origin = string_or_filename
	end

	FullMemoryCollect()
	local total_memory_before = math.floor(collectgarbage("count")*1024)

	do
		if levels == "all" then
			levels = {0,1,2,3,4,5,6,7,8,9}
		else
			levels = levels or {1}
		end

		local compress_filename
		local decompress_filename

		if output_prefix then
			compress_filename = output_prefix..".compress"
			decompress_filename = output_prefix..".decompress"
		else
			if is_file then
				compress_filename = string_or_filename..".compress"
			else
				compress_filename = "tests/string.compress"
			end
			decompress_filename = compress_filename..".decompress"
		end

		for i=1, #levels+1 do -- also test level == nil
			local level = levels[i]
			local configs = {level = level, strategy = strategy}

			print(
				(">>>>> %s: %s size: %d B Level: %s Strategy: %s")
				:format(is_file and "File" or "String",
					string_or_filename:sub(1, 40),  origin:len()
					,tostring(level), tostring(strategy)
				))
			local compress_to_run = {
				{"CompressDeflate", origin, configs},
				{"CompressDeflateWithDict", origin, dictionary32768
					, configs},
				{"CompressZlib", origin, configs},
				{"CompressZlibWithDict", origin, dictionary32768, configs},
			}

			for j, compress_running in ipairs(compress_to_run) do
			-- Compress by raw deflate
				local compress_func_name = compress_running[1]
				local compress_memory_leaked, compress_memory_used
					, compress_time, compress_data, compress_pad_bitlen =
					MemCheckAndBenchmarkFunc(LibDeflate
						, unpack(compress_running))

				if compress_running[1]:find("Deflate") then
					lu.assertTrue(0 <= compress_pad_bitlen
						and compress_pad_bitlen < 8
						, compress_func_name)
					-- put random value in the padding bits,
					-- to see if it is still okay to decompress

				else
					lu.assertEquals(compress_pad_bitlen, 0
						, compress_func_name)
				end

				-- Test encoding
				local compress_data_WoW_addon_encoded =
					LibDeflate:EncodeForWoWAddonChannel(compress_data)
				AssertLongStringEqual(
					LibDeflate:DecodeForWoWAddonChannel(
						compress_data_WoW_addon_encoded), compress_data
						, compress_func_name)

				local compress_data_data_WoW_chat_encoded =
					LibDeflate:EncodeForWoWChatChannel(compress_data)
				AssertLongStringEqual(
					LibDeflate:DecodeForWoWChatChannel(
						compress_data_data_WoW_chat_encoded), compress_data
						, compress_func_name)

				-- Put random bits in the padding bits of compressed data.
				-- to see if decompression still works.
				compress_data = PutRandomBitsInPaddingBits(compress_data
					, compress_pad_bitlen)
				local isZlib = compress_func_name:find("Zlib")
				if strategy == "fixed" then
					lu.assertEquals(GetFirstBlockType(compress_data, isZlib)
					, (level == 0) and 0 or 1,
					compress_func_name.." "..tostring(level))
				elseif strategy == "dynamic" then
					lu.assertEquals(GetFirstBlockType(compress_data, isZlib)
					, (level == 0) and 0 or 2,
					compress_func_name.." "..tostring(level))
				elseif strategy == "huffman_only" then  -- luacheck: ignore
					-- Emtpy
				elseif strategy == nil then -- luacheck: ignore
					-- Empty
				else
					lu.assertTrue(false, "Unexpected strategy: "
						..tostring(strategy))
				end
				WriteToFile(compress_filename, compress_data)

				if not compress_running[1] == "CompressDeflate" then
					local returnedStatus_puff, stdout_puff =
						RunProgram("puff -w ", compress_filename
							, decompress_filename)
					lu.assertEquals(returnedStatus_puff, 0
						, compress_func_name
						.." puff decompression failed with code "
						..returnedStatus_puff)
					AssertLongStringEqual(stdout_puff, origin
						, "puff fails with "..compress_func_name)
				end

				local decompress_to_run = {
					{"DecompressDeflate", compress_data},
					{"DecompressDeflateWithDict", compress_data
						, dictionary32768, configs},

					{"DecompressZlib", compress_data, configs},
					{"DecompressZlibWithDict", compress_data
						, dictionary32768, configs},
				}
				lu.assertEquals(#decompress_to_run, #compress_to_run)

				local zdeflate_decompress_to_run = {
					"zdeflate -d <",
					"zdeflate -d --dict tests/dictionary32768.txt <",
					"zdeflate --zlib -d <",
					"zdeflate --zlib -d --dict tests/dictionary32768.txt <",
				}
				lu.assertEquals(#zdeflate_decompress_to_run, #compress_to_run)

				-- Try decompress by zdeflate
				-- zdeflate is a C program calling zlib library
				-- which is modifed from zlib example.
				-- zdeflate can do all compression and decompression doable
				-- by LibDeflate (except encode and decode)
				local returnedStatus_zdeflate, stdout_zdeflate
					, stderr_zdeflate =
					RunProgram(zdeflate_decompress_to_run[j], compress_filename
						, decompress_filename)
				lu.assertEquals(returnedStatus_zdeflate, 0
					, compress_func_name
					..":zdeflate decompression failed with msg "
					..stderr_zdeflate)
				AssertLongStringEqual(stdout_zdeflate, origin
					, compress_func_name
					.."zdeflate decompress result not match origin string.")

				-- Try decompress by LibDeflate
				local decompress_memory_leaked, decompress_memory_used,
					decompress_time, decompress_data,
					decompress_unprocess_byte =
					MemCheckAndBenchmarkFunc(LibDeflate
						, unpack(decompress_to_run[j]))
				AssertLongStringEqual(decompress_data, origin
					, compress_func_name
					.." LibDeflate decompress result not match origin string.")
				lu.assertEquals(decompress_unprocess_byte, 0
					, compress_func_name
					.." Unprocessed bytes after LibDeflate decompression "
						..tostring(decompress_unprocess_byte))

				print(
					("%s:   Size : %d B,Time: %.3f ms, "
						.."Speed: %.0f KB/s, Memory: %d B,"
						.." Mem/input: %.2f, (memleak?: %d B) padbit: %d\n")
						:format(compress_func_name
						, compress_data:len(), compress_time
						, compress_data:len()/compress_time
						, compress_memory_used
						, compress_memory_used/origin:len()
						, compress_memory_leaked
						, compress_pad_bitlen
					),
					("%s:   cRatio: %.2f,Time: %.3f ms"
						..", Speed: %.0f KB/s, Memory: %d B,"
						.." Mem/input: %.2f, (memleak?: %d B)"):format(
						decompress_to_run[j][1]
						, origin:len()/compress_data:len(), decompress_time
						, decompress_data:len()/decompress_time
						, decompress_memory_used
						, decompress_memory_used/origin:len()
						, decompress_memory_leaked
					)
				)
			end
			print("")
		end

		-- Use all avaiable strategies of zdeflate to compress the data
		-- , and see if LibDeflate can decompress it.
		local tmp_filename = "tests/tmp.tmp"
		WriteToFile(tmp_filename, origin)

		local zdeflate_level, zdeflate_strategy
		local strategies = {"--filter", "--huffman", "--rle"
			, "--fix", "--default"}
		local unique_compress = {}
		local uniques_compress_count = 0
		for level=0, 8 do
			zdeflate_level = "-"..level
			for j=1, #strategies do
				zdeflate_strategy = strategies[j]
				local status, stdout, stderr =
					RunProgram("zdeflate "..zdeflate_level
					.." "..zdeflate_strategy
					.." < ", tmp_filename, tmp_filename..".out")
				lu.assertEquals(status, 0
				, ("zdeflate cant compress the file? "
					.."stderr: %s level: %s, strategy: %s")
					:format(stderr, zdeflate_level, zdeflate_strategy))
				if not unique_compress[stdout] then
					unique_compress[stdout] = true
					uniques_compress_count = uniques_compress_count + 1
					local decompressData =
						LibDeflate:DecompressDeflate(stdout)
					AssertLongStringEqual(decompressData, origin,
						("My decompress fail to decompress "
						.."at zdeflate level: %s, strategy: %s")
						:format(level, zdeflate_strategy))
				end
			end
		end
		print(
			(">>>>> %s: %s size: %d B\n")
				:format(is_file and "File" or "String"
				, string_or_filename:sub(1, 40), origin:len()),
			("Full decompress coverage test ok. unique compresses: %d\n")
				:format(uniques_compress_count),
			"\n")
	end

	FullMemoryCollect()
	local total_memory_after = math.floor(collectgarbage("count")*1024)

	local total_memory_difference = total_memory_before - total_memory_after

	if total_memory_difference > 0 then
		local ignore_leak_jit = ""
		if _G.jit then
			ignore_leak_jit = " (Ignore when the test is run by LuaJIT)"
		end
		print(
			(">>>>> %s: %s size: %d B\n")
				:format(is_file and "File" or "String"
				, string_or_filename:sub(1, 40), origin:len()),
			("Actual Memory Leak in the test: %d"..ignore_leak_jit.."\n")
				:format(total_memory_difference),
			"\n")
		-- ^If above "leak" is very small
		-- , it is very likely that it is false positive.
		if not _G.jit and total_memory_difference > 64 then
			-- Lua JIT has some problems to garbage collect stuffs
			-- , so don't consider as failure.
			lu.assertTrue(false
			, ("Fail the test because too many actual "
				.."Memory Leak in the test: %d")
				:format(total_memory_difference))
		end
	end

	return 0
end

local function CheckCompressAndDecompressString(str, levels, strategy)
	return CheckCompressAndDecompress(str, false, levels, strategy)
end

local function CheckCompressAndDecompressFile(inputFileName, levels, strategy
	, output_prefix)
	return CheckCompressAndDecompress(inputFileName, true, levels, strategy
									  , output_prefix)
end

local function CheckDecompressIncludingError(compress, decompress, is_zlib)
	assert (is_zlib == true or is_zlib == nil)
	local d, decompress_status
	if is_zlib then
		d, decompress_status = LibDeflate:DecompressZlib(compress)
	else
		d, decompress_status = LibDeflate:DecompressDeflate(compress)
	end
	lu.assertTrue(type(d) == "string" or type(d) == "nil")
	lu.assertEquals(type(decompress_status), "number")
	lu.assertEquals(decompress_status % 1, 0)
	if d ~= decompress then
		lu.assertTrue(false, ("My decompress does not match expected result."
			.."expected: %s, actual: %s, Returned status of decompress: %d")
			:format(StringForPrint(StringToHex(d))
			, StringForPrint(StringToHex(decompress)), decompress_status))
	else
		-- Check my decompress result with "puff"
		local input_filename = "tests/tmpFile"
		local inputFile = io.open(input_filename, "wb")
		inputFile:setvbuf("full")
		inputFile:write(compress)
		inputFile:flush()
		inputFile:close()
		local returned_status_puff, stdout_puff =
			RunProgram("puff -w", input_filename
			, input_filename..".decompress")
		local returnedStatus_zdeflate, stdout_zdeflate =
			RunProgram(is_zlib and "zdeflate --zlib -d <"
			or "zdeflate -d <", input_filename, input_filename..".decompress")
		if not d then
			if not is_zlib then
				if returned_status_puff ~= 0
					and returnedStatus_zdeflate ~= 0 then
					print((">>>> %q cannot be decompress as expected")
					:format((StringForPrint(StringToHex(compress)))))
				elseif returned_status_puff ~= 0
					and returnedStatus_zdeflate == 0 then
					lu.assertTrue(false,
					(">>>> %q puff error but not zdeflate?")
					:format((StringForPrint(StringToHex(compress)))))
				elseif returned_status_puff == 0
					and returnedStatus_zdeflate ~= 0 then
					lu.assertTrue(false,
					(">>>> %q zdeflate error but not puff?")
					:format((StringForPrint(StringToHex(compress)))))
				else
					lu.assertTrue(false,
					(">>>> %q my decompress error, but not puff or zdeflate")
					:format((StringForPrint(StringToHex(compress)))))
				end
			else
				if returnedStatus_zdeflate ~= 0 then
					print((">>>> %q cannot be zlib decompress as expected")
					:format(StringForPrint(StringToHex(compress))))
				else
					lu.assertTrue(false,
					(">>>> %q my decompress error, but not zdeflate")
					:format((StringForPrint(StringToHex(compress)))))
				end
			end

		else
			AssertLongStringEqual(d, stdout_zdeflate)
			if not is_zlib then
				AssertLongStringEqual(d, stdout_puff)
			end
			print((">>>> %q is decompressed to %q as expected")
				:format(StringForPrint(StringToHex(compress))
				, StringForPrint(StringToHex(d))))
		end
	end
end

local function CheckZlibDecompressIncludingError(compress, decompress)
	return CheckDecompressIncludingError(compress, decompress, true)
end

local function CreateDictionaryWithoutVerify(str)
	-- Dont do this in the real program.
	-- Dont calculate adler32 in runtime. Do hardcode it as constant.
	-- This is just for test purpose
	local dict = LibDeflate:CreateDictionary(str, #str, LibDeflate:Adler32(str))
	return dict
end

local function CreateAndCheckDictionary(str)
	local strlen = #str
	local dictionary = CreateDictionaryWithoutVerify(str)

	lu.assertTrue(LibDeflate.internals.IsValidDictionary(dictionary))
	for i=1, strlen do
		lu.assertEquals(dictionary.string_table[i], string_byte(str, i, i))
	end
	lu.assertEquals(dictionary.strlen, str:len())
	for i=1, strlen-2 do
		local hash = string_byte(str, i, i)*65536
			+ string_byte(str, i+1, i+1)*256
			+ string_byte(str, i+2, i+2)
		local hash_chain = dictionary.hash_tables[hash]
		lu.assertNotNil(hash_chain, "nil hash_chain?")
		local found = false
		for j = 1, #hash_chain do
			if hash_chain[j] == i-strlen then
				found = true
				break
			end
		end
		lu.assertTrue(found
		, ("hash index %d not found in dictionary hash_table."):format(i))
	end
	return dictionary
end



-- the input dictionary must can make compressed data smaller.
-- otherwise, set dontCheckEffectivenss
local function CheckDictEffectiveness(str, dictionary, dict_str
	, dontCheckEffectiveness)
	local configs = {level = 7}
	local compress_dict = LibDeflate:CompressDeflateWithDict(str
		, dictionary, configs)
	local decompressed_dict =
		LibDeflate:DecompressDeflateWithDict(compress_dict, dictionary)
	AssertLongStringEqual(decompressed_dict, str)

	local compress_no_dict = LibDeflate:CompressDeflate(str, configs)
	local decompressed_no_dict =
		LibDeflate:DecompressDeflate(compress_no_dict)
	AssertLongStringEqual(decompressed_no_dict, str)

	local byte_smaller_with_dict = compress_no_dict:len()
		- compress_dict:len()
	if not dontCheckEffectiveness then
		lu.assertTrue(byte_smaller_with_dict > 0)
		print((">>> %d bytes smaller with (deflate dict) "..
			"DICT: %s, DATA: %s")
			:format(byte_smaller_with_dict
				, StringForPrint(dict_str), StringForPrint(str)))
	end

	local zlib_compress_dict = LibDeflate:
		CompressZlibWithDict(str, dictionary, configs)
	local zlib_decompressed_dict =
		LibDeflate:DecompressZlibWithDict(zlib_compress_dict, dictionary)
	AssertLongStringEqual(zlib_decompressed_dict, str)

	local zlib_compress_no_dict = LibDeflate:CompressZlib(str, configs)
	local zlib_decompressed_no_dict =
		LibDeflate:DecompressZlib(zlib_compress_no_dict)
	AssertLongStringEqual(zlib_decompressed_no_dict, str)

	local zlib_byte_smaller_with_dict = zlib_compress_no_dict:len()
		- zlib_compress_dict:len()
	-- for zlib with dict, 4 extra bytes needed to store
	-- the adler32 of dictionary
	if not dontCheckEffectiveness then
		lu.assertTrue(zlib_byte_smaller_with_dict > -4)
		print((">>> %d bytes smaller with (zlib dict) DICT: %s DATA: %s")
			:format(zlib_byte_smaller_with_dict
			, StringForPrint(dict_str), StringForPrint(str)))
	end

	return compress_dict, compress_no_dict
		, zlib_compress_dict, zlib_compress_no_dict
end

-- Commandline
local arg = _G.arg
if arg and #arg >= 1 and type(arg[0]) == "string" then
	if #arg >= 2 and arg[1] == "-o" then
	-- For testing purpose (test_from_random_files_in_disk.py),
	-- check if the file can be opened by lua
		local input = arg[2]
		local inputFile = io.open(input, "rb")
		if not inputFile then
			os.exit(1)
		end
		inputFile.close()
		os.exit(0)
	elseif #arg >= 3 and arg[1] == "-c" then
	-- For testing purpose (test_from_random_files_in_disk.py)
	-- , check the if a file can be correctly compress and decompress to origin
		os.exit(CheckCompressAndDecompressFile(arg[2], "all", nil
				, "tests/tmp"))
	end
end

-------------------------------------------------------------------------
-- LibCompress encode code to help verity encode code in LibDeflate -----
-------------------------------------------------------------------------
local LibCompressEncoder = {}
do
	local gsub_escape_table = {
		['\000'] = "%z",
		[('(')] = "%(",
		[(')')] = "%)",
		[('.')] = "%.",
		[('%')] = "%%",
		[('+')] = "%+",
		[('-')] = "%-",
		[('*')] = "%*",
		[('?')] = "%?",
		[('[')] = "%[",
		[(']')] = "%]",
		[('^')] = "%^",
		[('$')] = "%$"
	}

	local function escape_for_gsub(str)
		return str:gsub("([%z%(%)%.%%%+%-%*%?%[%]%^%$])",  gsub_escape_table)
	end

	function LibCompressEncoder:GetEncodeTable(reservedChars, escapeChars
			, mapChars)
		reservedChars = reservedChars or ""
		escapeChars = escapeChars or ""
		mapChars = mapChars or ""

		-- select a default escape character
		if escapeChars == "" then
			return nil, "No escape characters supplied"
		end

		if #reservedChars < #mapChars then
			return nil, "Number of reserved characters must be at least "
				.."as many as the number of mapped chars"
		end

		if reservedChars == "" then
			return nil, "No characters to encode"
		end

		-- list of characters that must be encoded
		local encodeBytes = reservedChars..escapeChars..mapChars

		-- build list of bytes not available as a suffix to a prefix byte
		local taken = {}
		for i = 1, string_len(encodeBytes) do
			taken[string_sub(encodeBytes, i, i)] = true
		end

		-- allocate a table to hold encode/decode strings/functions
		local codecTable = {}

		-- the encoding can be a single gsub,
		-- but the decoding can require multiple gsubs
		local decode_func_string = {}

		local encode_search = {}
		local encode_translate = {}
		local encode_func
		local decode_search = {}
		local decode_translate = {}
		local decode_func
		local c, r, to, from
		local escapeCharIndex, escapeChar = 0

		-- map single byte to single byte
		if #mapChars > 0 then
			for i = 1, #mapChars do
				from = string_sub(reservedChars, i, i)
				to = string_sub(mapChars, i, i)
				encode_translate[from] = to
				table_insert(encode_search, from)
				decode_translate[to] = from
				table_insert(decode_search, to)
			end
			codecTable["decode_search"..tostring(escapeCharIndex)]
				= "([".. escape_for_gsub(table_concat(decode_search)).."])"
			codecTable["decode_translate"..tostring(escapeCharIndex)] =
				decode_translate
			table_insert(decode_func_string, "str = str:gsub(self.decode_search"
				..tostring(escapeCharIndex)..", self.decode_translate"
				..tostring(escapeCharIndex)..");")
		end

		-- map single byte to double-byte
		escapeCharIndex = escapeCharIndex + 1
		escapeChar = string_sub(escapeChars, escapeCharIndex, escapeCharIndex)
		r = 0 -- suffix char value to the escapeChar
		decode_search = {}
		decode_translate = {}
		for i = 1, string_len(encodeBytes) do
			c = string_sub(encodeBytes, i, i)
			if not encode_translate[c] then
				-- this loop will update escapeChar and r
				while r >= 256 or taken[string_char(r)] do -- Defliate patch
				-- bug in LibCompress r81
				-- while r < 256 and taken[string_char(r)] do
					r = r + 1
					if r > 255 then -- switch to next escapeChar
						if escapeChar == "" then
							-- we are out of escape chars and we need more!
							return nil, "Out of escape characters"
						end

						codecTable["decode_search"..tostring(escapeCharIndex)] =
							escape_for_gsub(escapeChar)
							.."(["..
							escape_for_gsub(table_concat(decode_search)).."])"
						codecTable["decode_translate"
							..tostring(escapeCharIndex)] = decode_translate
						table_insert(decode_func_string,
							"str = str:gsub(self.decode_search"
							..tostring(escapeCharIndex)
							..", self.decode_translate"
							..tostring(escapeCharIndex)..");")

						escapeCharIndex  = escapeCharIndex + 1
						escapeChar = string_sub(escapeChars
							, escapeCharIndex, escapeCharIndex)

						r = 0
						decode_search = {}
						decode_translate = {}
					end
				end
				encode_translate[c] = escapeChar..string_char(r)
				table_insert(encode_search, c)
				decode_translate[string_char(r)] = c
				table_insert(decode_search, string_char(r))
				r = r + 1
			end
		end

		if r > 0 then
			codecTable["decode_search"..tostring(escapeCharIndex)] =
				escape_for_gsub(escapeChar)
				.."([".. escape_for_gsub(table_concat(decode_search)).."])"
			codecTable["decode_translate"..tostring(escapeCharIndex)] =
				decode_translate
			table_insert(decode_func_string,
				"str = str:gsub(self.decode_search"..tostring(escapeCharIndex)
				..", self.decode_translate"..tostring(escapeCharIndex)..");")
		end

		-- change last line from "str = ...;" to "return ...;";
		decode_func_string[#decode_func_string] =
			decode_func_string[#decode_func_string]
			:gsub("str = (.*);", "return %1;")
		decode_func_string = "return function(self, str) "
			..table_concat(decode_func_string).." end"

		encode_search = "(["
			.. escape_for_gsub(table_concat(encode_search)).."])"
		decode_search = escape_for_gsub(escapeChars)
			.."([".. escape_for_gsub(table_concat(decode_search)).."])"

		encode_func = assert(loadstring(
			"return function(self, str) "
			.."return str:gsub(self.encode_search, "
			.."self.encode_translate); end"))()
		decode_func = assert(loadstring(decode_func_string))()

		codecTable.encode_search = encode_search
		codecTable.encode_translate = encode_translate
		codecTable.Encode = encode_func
		codecTable.decode_search = decode_search
		codecTable.decode_translate = decode_translate
		codecTable.Decode = decode_func

		codecTable.decode_func_string = decode_func_string -- to be deleted
		return codecTable
	end

	-- Addons: Call this only once and reuse the returned
	-- table for all encodings/decodings.
	function LibCompressEncoder:GetAddonEncodeTable(reservedChars
		, escapeChars, mapChars )
		reservedChars = reservedChars or ""
		escapeChars = escapeChars or ""
		mapChars = mapChars or ""
		-- Following byte values are not allowed:
		-- \000
		if escapeChars == "" then
			escapeChars = "\001"
		end
		return self:GetEncodeTable( (reservedChars or "").."\000"
			, escapeChars, mapChars)
	end

	-- Addons: Call this only once and reuse the returned
	-- table for all encodings/decodings.
	function LibCompressEncoder:GetChatEncodeTable(reservedChars
		, escapeChars, mapChars)
		reservedChars = reservedChars or ""
		escapeChars = escapeChars or ""
		mapChars = mapChars or ""
		local r = {}
		for i = 128, 255 do
			table_insert(r, string_char(i))
		end
		reservedChars = "sS\000\010\013\124%"
			..table_concat(r)..(reservedChars or "")
		if escapeChars == "" then
			escapeChars = "\029\031"
		end
		if mapChars == "" then
			mapChars = "\015\020";
		end
		return self:GetEncodeTable(reservedChars, escapeChars, mapChars)
	end
end

local _libcompress_addon_codec = LibCompressEncoder:GetAddonEncodeTable()
local _libcompress_chat_codec = LibCompressEncoder:GetChatEncodeTable()

-- Check if LibDeflate's encoding works properly
local function CheckEncodeAndDecode(str, reserved_chars, escape_chars
	, map_chars)
	if reserved_chars then
		local encode_decode_table_libcompress =
			LibCompressEncoder:GetEncodeTable(reserved_chars
			, escape_chars, map_chars)
		local encode_decode_table, message =
			LibDeflate:CreateCodec(reserved_chars
			, escape_chars, map_chars)
		if not encode_decode_table then
			print(message)
		end
		local encoded_libcompress = encode_decode_table_libcompress:Encode(str)
		local encoded = encode_decode_table:Encode(str)
		AssertLongStringEqual(encoded, encoded_libcompress
			, "Encoded result does not match libcompress")
		AssertLongStringEqual(encode_decode_table:Decode(encoded), str
			, "Encoded str cant be decoded to origin")
	end

	local encoded_addon = LibDeflate:EncodeForWoWAddonChannel(str)
	local encoded_addon_libcompress =
		_libcompress_addon_codec:Encode(str)
	AssertLongStringEqual(encoded_addon, encoded_addon_libcompress
		, "Encoded addon channel result does not match libcompress")
	AssertLongStringEqual(LibDeflate:DecodeForWoWAddonChannel(encoded_addon)
		, str, "Encoded for addon channel str cant be decoded to origin")

	local encoded_chat = LibDeflate:EncodeForWoWChatChannel(str)
	local encoded_chat_libcompress = _libcompress_chat_codec:Encode(str)
	AssertLongStringEqual(encoded_chat, encoded_chat_libcompress
		, "Encoded chat channel result does not match libcompress")
	AssertLongStringEqual(LibDeflate:DecodeForWoWChatChannel(encoded_chat), str
		, "Encoded for chat channel str cant be decoded to origin")
end

--------------------------------------------------------------
-- Actual Tests Start ----------------------------------------
--------------------------------------------------------------
TestBasicStrings = {}
	function TestBasicStrings:TestEmpty()
		CheckCompressAndDecompressString("", "all")
	end
	function TestBasicStrings:TestAllLiterals1()
		CheckCompressAndDecompressString("ab", "all")
	end
	function TestBasicStrings:TestAllLiterals2()
		CheckCompressAndDecompressString("abcdefgh", "all")
	end
	function TestBasicStrings:TestAllLiterals3()
		local t = {}
		for i=0, 255 do
			t[#t+1] = string.char(i)
		end
		local str = table.concat(t)
		CheckCompressAndDecompressString(str, "all")
	end

	function TestBasicStrings:TestRepeat()
		CheckCompressAndDecompressString("aaaaaaaaaaaaaaaaaa", "all")
	end

	function TestBasicStrings:TestLongRepeat()
		local repeated = {}
		for i=1, 100000 do
			repeated[i] = "c"
		end
		CheckCompressAndDecompressString(table.concat(repeated), "all")
	end

TestMyData = {}
	function TestMyData:TestItemStrings()
		CheckCompressAndDecompressFile("tests/data/itemStrings.txt", "all")
	end

	function TestMyData:TestSmallTest()
		CheckCompressAndDecompressFile("tests/data/smalltest.txt", "all")
	end

	function TestMyData:TestReconnectData()
		CheckCompressAndDecompressFile("tests/data/reconnectData.txt", "all")
	end

TestThirdPartySmall = {}
	function TestThirdPartySmall:TestEmpty()
		CheckCompressAndDecompressFile("tests/data/3rdparty/empty", "all")
	end

	function TestThirdPartySmall:TestX()
		CheckCompressAndDecompressFile("tests/data/3rdparty/x", "all")
	end

	function TestThirdPartySmall:TestXYZZY()
		CheckCompressAndDecompressFile("tests/data/3rdparty/xyzzy", "all")
	end

TestThirdPartyMedium = {}
	function TestThirdPartyMedium:Test10x10y()
		CheckCompressAndDecompressFile("tests/data/3rdparty/10x10y", "all")
	end

	function TestThirdPartyMedium:TestQuickFox()
		CheckCompressAndDecompressFile("tests/data/3rdparty/quickfox", "all")
	end

	function TestThirdPartyMedium:Test64x()
		CheckCompressAndDecompressFile("tests/data/3rdparty/64x", "all")
	end

	function TestThirdPartyMedium:TestUkkonoona()
		CheckCompressAndDecompressFile("tests/data/3rdparty/ukkonooa", "all")
	end

	function TestThirdPartyMedium:TestMonkey()
		CheckCompressAndDecompressFile("tests/data/3rdparty/monkey", "all")
	end

	function TestThirdPartyMedium:TestRandomChunks()
		CheckCompressAndDecompressFile("tests/data/3rdparty/random_chunks"
			, "all")
	end

	function TestThirdPartyMedium:TestGrammerLsp()
		CheckCompressAndDecompressFile("tests/data/3rdparty/grammar.lsp"
			, "all")
	end

	function TestThirdPartyMedium:TestXargs1()
		CheckCompressAndDecompressFile("tests/data/3rdparty/xargs.1", "all")
	end

	function TestThirdPartyMedium:TestRandomOrg10KBin()
		CheckCompressAndDecompressFile("tests/data/3rdparty/random_org_10k.bin"
			, "all")
	end

	function TestThirdPartyMedium:TestCpHtml()
		CheckCompressAndDecompressFile("tests/data/3rdparty/cp.html", "all")
	end

	function TestThirdPartyMedium:TestBadData1Snappy()
		CheckCompressAndDecompressFile("tests/data/3rdparty/baddata1.snappy"
			, "all")
	end

	function TestThirdPartyMedium:TestBadData2Snappy()
		CheckCompressAndDecompressFile("tests/data/3rdparty/baddata2.snappy"
			, "all")
	end

	function TestThirdPartyMedium:TestBadData3Snappy()
		CheckCompressAndDecompressFile("tests/data/3rdparty/baddata3.snappy"
			, "all")
	end

	function TestThirdPartyMedium:TestSum()
		CheckCompressAndDecompressFile("tests/data/3rdparty/sum", "all")
	end

Test_64K = {}
	function Test_64K:Test64KFile()
		CheckCompressAndDecompressFile("tests/data/64k.txt", "all")
	end
	function Test_64K:Test64KFilePlus1()
		CheckCompressAndDecompressFile("tests/data/64kplus1.txt", "all")
	end
	function Test_64K:Test64KFilePlus2()
		CheckCompressAndDecompressFile("tests/data/64kplus2.txt", "all")
	end
	function Test_64K:Test64KFilePlus3()
		CheckCompressAndDecompressFile("tests/data/64kplus3.txt", "all")
	end
	function Test_64K:Test64KFilePlus4()
		CheckCompressAndDecompressFile("tests/data/64kplus4.txt", "all")
	end
	function Test_64K:Test64KFileMinus1()
		CheckCompressAndDecompressFile("tests/data/64kminus1.txt", "all")
	end
	function Test_64K:Test64KRepeated()
		local repeated = {}
		for i=1, 65536 do
			repeated[i] = "c"
		end
		CheckCompressAndDecompressString(table.concat(repeated), "all")
	end
	function Test_64K:Test64KRepeatedPlus1()
		local repeated = {}
		for i=1, 65536+1 do
			repeated[i] = "c"
		end
		CheckCompressAndDecompressString(table.concat(repeated), "all")
	end
	function Test_64K:Test64KRepeatedPlus2()
		local repeated = {}
		for i=1, 65536+2 do
			repeated[i] = "c"
		end
		CheckCompressAndDecompressString(table.concat(repeated), "all")
	end
	function Test_64K:Test64KRepeatedPlus3()
		local repeated = {}
		for i=1, 65536+3 do
			repeated[i] = "c"
		end
		CheckCompressAndDecompressString(table.concat(repeated), "all")
	end
	function Test_64K:Test64KRepeatedPlus4()
		local repeated = {}
		for i=1, 65536+4 do
			repeated[i] = "c"
		end
		CheckCompressAndDecompressString(table.concat(repeated), "all")
	end
	function Test_64K:Test64KRepeatedMinus1()
		local repeated = {}
		for i=1, 65536-1 do
			repeated[i] = "c"
		end
		CheckCompressAndDecompressString(table.concat(repeated), "all")
	end
	function Test_64K:Test64KRepeatedMinus2()
		local repeated = {}
		for i=1, 65536-2 do
			repeated[i] = "c"
		end
		CheckCompressAndDecompressString(table.concat(repeated), "all")
	end

-- > 64K
TestThirdPartyBig = {}
	function TestThirdPartyBig:TestBackward65536()
		CheckCompressAndDecompressFile("tests/data/3rdparty/backward65536"
			, "all")
	end
	function TestThirdPartyBig:TestHTML()
		CheckCompressAndDecompressFile("tests/data/3rdparty/html"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestPaper100kPdf()
		CheckCompressAndDecompressFile("tests/data/3rdparty/paper-100k.pdf"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestGeoProtodata()
		CheckCompressAndDecompressFile("tests/data/3rdparty/geo.protodata"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestFireworksJpeg()
		CheckCompressAndDecompressFile("tests/data/3rdparty/fireworks.jpeg"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestAsyoulik()
		CheckCompressAndDecompressFile("tests/data/3rdparty/asyoulik.txt"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestCompressedRepeated()
		CheckCompressAndDecompressFile(
			"tests/data/3rdparty/compressed_repeated", {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestAlice29()
		CheckCompressAndDecompressFile("tests/data/3rdparty/alice29.txt"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestQuickfox_repeated()
		CheckCompressAndDecompressFile("tests/data/3rdparty/quickfox_repeated"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestKppknGtb()
		CheckCompressAndDecompressFile("tests/data/3rdparty/kppkn.gtb"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestZeros()
		CheckCompressAndDecompressFile("tests/data/3rdparty/zeros"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestMapsdatazrh()
		CheckCompressAndDecompressFile("tests/data/3rdparty/mapsdatazrh"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestHtml_x_4()
		CheckCompressAndDecompressFile("tests/data/3rdparty/html_x_4"
			, {0,1,2,3,4})
	end
	function TestThirdPartyBig:TestLcet10()
		CheckCompressAndDecompressFile("tests/data/3rdparty/lcet10.txt"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestPlrabn12()
		CheckCompressAndDecompressFile("tests/data/3rdparty/plrabn12.txt"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:TestUrls10K()
		CheckCompressAndDecompressFile("tests/data/3rdparty/urls.10K"
			, {0,1,2,3,4,5})
	end
	function TestThirdPartyBig:Testptt5()
		CheckCompressAndDecompressFile("tests/data/3rdparty/ptt5"
			, {0,1,2,3,4})
	end
	function TestThirdPartyBig:TestKennedyXls()
		CheckCompressAndDecompressFile("tests/data/3rdparty/kennedy.xls"
			, {0,1,2,3,4})
	end

TestWoWData = {}
	function TestWoWData:TestWarlockWeakAuras()
		CheckCompressAndDecompressFile("tests/data/warlockWeakAuras.txt"
			, {0,1,2,3,4})
	end
	function TestWoWData:TestTotalRp3Data()
		CheckCompressAndDecompressFile("tests/data/totalrp3.txt"
			, {0,1,2,3,4})
	end

TestDecompress = {}
	-- Test from puff
	function TestDecompress:TestStoreEmpty()
		CheckDecompressIncludingError("\001\000\000\255\255", "")
	end
	function TestDecompress:TestStore1()
		CheckDecompressIncludingError("\001\001\000\254\255\010", "\010")
	end
	function TestDecompress:TestStore2()
		local t = {}
		for i=1, 65535 do
			t[i] = "a"
		end
		local str = table.concat(t)
		CheckDecompressIncludingError("\001\255\255\000\000"..str, str)
	end
	function TestDecompress:TestStore3()
		local t = {}
		for i=1, 65535 do
			t[i] = "a"
		end
		local str = table.concat(t)
		CheckDecompressIncludingError("\000\255\255\000\000"..str
			.."\001\255\255\000\000"..str, str..str)
	end
	function TestDecompress:TestStore4()
		-- 0101 00fe ff31
		CheckDecompressIncludingError("\001\001\000\254\255\049", "1")
	end
	function TestDecompress:TestStore5()
		local size = 0x5555
		local str = GetLimitedRandomString(size)
		CheckDecompressIncludingError("\001\085\085\170\170"..str, str)
	end

	function TestDecompress:TestStoreRandom()
		for _ = 1, 20 do
			local size = math.random(1, 65535)
			local str = GetLimitedRandomString(size)
			CheckDecompressIncludingError("\001"..string.char(size%256)
				..string.char((size-size%256)/256)
				..string.char(255-size%256)
				..string.char(255-(size-size%256)/256)..str, str)
		end
	end
	function TestDecompress:TestFix1()
		CheckDecompressIncludingError("\003\000", "")
	end
	function TestDecompress:TestFix2()
		CheckDecompressIncludingError("\051\004\000", "1")
	end
	function TestDecompress:TestFixThenStore1()
		local t = {}
		for i=1, 65535 do
			t[i] = "a"
		end
		local str = table.concat(t)
		CheckDecompressIncludingError("\050\004\000\255\255\000\000"
			..str.."\001\255\255\000\000"..str, "1"..str..str)
	end
	function TestDecompress:TestIncomplete()
		-- Additonal 1 byte after the end of compression data
		CheckDecompressIncludingError("\001\001\000\254\255\010\000", "\010")
	end
	function TestDecompress:TestStoreSizeTooBig()
		CheckDecompressIncludingError("\001\001\000\254\255", nil)
		CheckDecompressIncludingError("\001\002\000\253\255\001", nil)
	end
	function TestDecompress:TestEmtpy()
		CheckDecompressIncludingError("", nil)
	end
	function TestDecompress:TestOneByte()
		for i=0, 255 do
			CheckDecompressIncludingError(string.char(i), nil)
		end
	end
	function TestDecompress:TestPuffReturn2()
		CheckDecompressIncludingError("\000", nil)
		CheckDecompressIncludingError("\002", nil)
		CheckDecompressIncludingError("\004", nil)
		CheckDecompressIncludingError(HexToString("00 01 00 fe ff"), nil)
		CheckDecompressIncludingError(
			HexToString("04 80 49 92 24 49 92 24 0f b4 ff ff c3 04"), nil)
	end
	function TestDecompress:TestPuffReturn245()
		CheckDecompressIncludingError(HexToString(
			"0c c0 81 00 00 00 00 00 90 ff 6b 04"), nil)
	end
	function TestDecompress:TestPuffReturn246()
		CheckDecompressIncludingError(HexToString("1a 07"), nil)
		CheckDecompressIncludingError(HexToString("02 7e ff ff"), nil)
		CheckDecompressIncludingError(HexToString(
			"04 c0 81 08 00 00 00 00 20 7f eb 0b 00 00"), nil)
	end
	function TestDecompress:TestPuffReturn247()
		CheckDecompressIncludingError(HexToString(
			"04 00 24 e9 ff 6d"), nil)
	end
	function TestDecompress:TestPuffReturn248()
		CheckDecompressIncludingError(HexToString(
			"04 80 49 92 24 49 92 24 0f b4 ff ff c3 84"), nil)
	end
	function TestDecompress:TestPuffReturn249()
		CheckDecompressIncludingError(HexToString(
			"04 80 49 92 24 49 92 24 71 ff ff 93 11 00"), nil)
	end
	function TestDecompress:TestPuffReturn250()
		CheckDecompressIncludingError(HexToString(
			"04 00 24 e9 ff ff"), nil)
	end
	function TestDecompress:TestPuffReturn251()
		CheckDecompressIncludingError(HexToString("04 00 24 49"), nil)
	end
	function TestDecompress:TestPuffReturn252()
		CheckDecompressIncludingError(HexToString("04 00 fe ff"), nil)
	end
	function TestDecompress:TestPuffReturn253()
		CheckDecompressIncludingError(HexToString("fc 00 00"), nil)
	end
	function TestDecompress:TestPuffReturn254()
		CheckDecompressIncludingError(HexToString("00 00 00 00 00"), nil)
	end
	function TestDecompress:TestZlibCoverSupport()
		CheckDecompressIncludingError(HexToString("63 00"), nil)
		CheckDecompressIncludingError(HexToString("63 18 05"), nil)
		CheckDecompressIncludingError(
			HexToString("63 18 68 30 d0 0 0"), ("\000"):rep(257))
		CheckDecompressIncludingError(HexToString("3 00"), "")
		CheckDecompressIncludingError("", nil)
		CheckDecompressIncludingError("", nil, true)
	end
	function TestDecompress:TestZlibCoverWrap()
		CheckZlibDecompressIncludingError(
			HexToString("77 85"), nil) -- Bad zlib header
		CheckZlibDecompressIncludingError(
			HexToString("70 85"), nil) -- Bad zlib header
		CheckZlibDecompressIncludingError(
			HexToString("88 9c"), nil) -- Bad window size
		CheckZlibDecompressIncludingError(
			HexToString("f8 9c"), nil) -- Bad window size
		CheckZlibDecompressIncludingError(
			HexToString("78 90"), nil) -- Bad zlib header check
		CheckZlibDecompressIncludingError(
			HexToString("78 9c 63 00 00 00 01 00 01"), "\000") -- check Adler32
		CheckZlibDecompressIncludingError(
			HexToString("78 9c 63 00 00 00 01 00"), nil) -- Adler32 incomplete
		CheckZlibDecompressIncludingError(
			HexToString("78 9c 63 00 00 00 01 00 02"), nil) -- wrong Adler32
		CheckZlibDecompressIncludingError(
			HexToString("78 9c 63 0"), nil) -- no Adler32
	end
	function TestDecompress:TestZlibCoverInflate()
		CheckDecompressIncludingError(
			HexToString("0 0 0 0 0"), nil) -- invalid store block length
		CheckDecompressIncludingError(
			HexToString("3 0"), "", nil) -- Fixed block
		CheckDecompressIncludingError(
			HexToString("6"), nil) -- Invalid block type
		CheckDecompressIncludingError(
			HexToString("1 1 0 fe ff 0"), "\000") -- Stored block
		CheckDecompressIncludingError(
			HexToString("fc 0 0"), nil) -- Too many length or distance symbols
		CheckDecompressIncludingError(
			HexToString("4 0 fe ff"), nil) -- Invalid code lengths set
		CheckDecompressIncludingError(
			HexToString("4 0 24 49 0"), nil) -- Invalid bit length repeat
		CheckDecompressIncludingError(
			HexToString("4 0 24 e9 ff ff"), nil) -- Invalid bit length repeat
		-- Invalid code: missing end of block
		CheckDecompressIncludingError(
			HexToString("4 0 24 e9 ff 6d"), nil)
		-- Invalid literal/lengths set
		CheckDecompressIncludingError(
			HexToString("4 80 49 92 24 49 92 24 71 ff ff 93 11 0"), nil)
		CheckDecompressIncludingError(
			HexToString("4 80 49 92 24 49 92 24 71 ff ff 93 11 0"), nil)
		-- Invalid distance set
		CheckDecompressIncludingError(
			HexToString("4 80 49 92 24 49 92 24 f b4 ff ff c3 84"), nil)
		-- Invalid literal/length code
		CheckDecompressIncludingError(
			HexToString("4 c0 81 8 0 0 0 0 20 7f eb b 0 0"), nil)
		CheckDecompressIncludingError(
			HexToString("2 7e ff ff"), nil) -- Invalid distance code
		-- Invalid distance too far
		CheckDecompressIncludingError(
			HexToString("c c0 81 0 0 0 0 0 90 ff 6b 4 0"), nil)
		-- incorrect data check
		CheckDecompressIncludingError(
			HexToString("1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 1"), nil)
		-- incorrect length check
		CheckDecompressIncludingError(
			HexToString("1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 1"), nil)
		-- pull 17
		CheckDecompressIncludingError(
			HexToString("5 c0 21 d 0 0 0 80 b0 fe 6d 2f 91 6c"), "")
		-- long code
		CheckDecompressIncludingError(
		HexToString(
		"05 e0 81 91 24 cb b2 2c 49 e2 0f 2e 8b 9a 47 56 9f fb fe ec d2 ff 1f")
		, "")
		-- extra length
		CheckDecompressIncludingError(
			HexToString("ed c0 1 1 0 0 0 40 20 ff 57 1b 42 2c 4f")
			, ("\000"):rep(516))
		-- long distance and extra
		CheckDecompressIncludingError(
		HexToString(
		"ed cf c1 b1 2c 47 10 c4 30 fa 6f 35 1d 1 82 59 3d fb be 2e 2a fc f c")
			, ("\000"):rep(518))
		-- Window end
		CheckDecompressIncludingError(
		HexToString(
		"ed c0 81 0 0 0 0 80 a0 fd a9 17 a9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0")
			, nil)
		-- inflate_fast TYPE return
		CheckDecompressIncludingError(HexToString("2 8 20 80 0 3 0"), "")
		-- Window wrap
		CheckDecompressIncludingError(HexToString("63 18 5 40 c 0")
			, ("\000"):rep(262))
	end
	function TestDecompress:TestZlibCoverFast()
		-- fast length extra bits
		CheckDecompressIncludingError(
		HexToString(
		"e5 e0 81 ad 6d cb b2 2c c9 01 1e 59 63 ae 7d ee fb 4d fd b5 35 41 68")
		, nil)
		-- fast distance extra bits
		CheckDecompressIncludingError(
		HexToString(
		"25 fd 81 b5 6d 59 b6 6a 49 ea af 35 6 34 eb 8c b9 f6 b9 1e ef 67 49"
		, nil))
		 -- Fast invalid distance code
		CheckDecompressIncludingError(HexToString("3 7e 0 0 0 0 0"), nil)
		-- Fast literal/length code
		CheckDecompressIncludingError(HexToString("1b 7 0 0 0 0 0"), nil)
		-- fast 2nd level codes and too far back
		CheckDecompressIncludingError(
		HexToString(
		"d c7 1 ae eb 38 c 4 41 a0 87 72 de df fb 1f b8 36 b1 38 5d ff ff 0")
		, nil)
		-- Very common case
		CheckDecompressIncludingError(
			HexToString("63 18 5 8c 10 8 0 0 0 0")
			, ("\000"):rep(258)..("\000\001"):rep(4))
		-- Continous and wrap aroudn window
		CheckDecompressIncludingError(
			HexToString("63 60 60 18 c9 0 8 18 18 18 26 c0 28 0 29 0 0 0")
			, ("\000"):rep(261)..("\144")..("\000"):rep(6)..("\144\000"))
		-- Copy direct from output
		CheckDecompressIncludingError(
			HexToString("63 0 3 0 0 0 0 0"), ("\000"):rep(6))
	end
	function TestDecompress:TestAdditionalCoverage()
		-- no zlib FLG
		CheckZlibDecompressIncludingError(HexToString("78"), nil)
		-- Stored block no len
		CheckDecompressIncludingError(HexToString("1"), nil)
		-- Stored block no len comp
		CheckDecompressIncludingError(HexToString("1 1 0"), nil)
		-- Stored block not one's complement
		CheckDecompressIncludingError(HexToString("1 1 0 ff ff 0"), nil)
		-- Stored block not one's complement
		CheckDecompressIncludingError(HexToString("1 1 0 fe fe 0"), nil)
		CheckDecompressIncludingError(
			HexToString("1 34 43 cb bc")..("\000"):rep(17204)
			, ("\000"):rep(17204)) -- Stored block
		-- Stored block with 1 less byte
		CheckDecompressIncludingError(
			HexToString("1 34 43 cb bc")..("\000"):rep(17203), nil)
		CheckDecompressIncludingError(
			HexToString("1 34 43 cb bc")..("\000"):rep(17202), nil)
	end

	function TestDecompress:Test2ndReturn()
		for _ = 1, 10 do
			local str = GetLimitedRandomString(math.random(100, 300))
			local compressed = LibDeflate:CompressDeflate(str)
			local extra_len = math.random(1, 10)
			local extra = GetLimitedRandomString(extra_len)
			compressed = compressed..extra
			local decompressed, unprocessed =
				LibDeflate:DecompressDeflate(compressed)
			AssertLongStringEqual(str, decompressed)
			lu.assertEquals(unprocessed, extra_len)
		end
		for _ = 1, 10 do
			local dict = CreateDictionaryWithoutVerify(
				GetLimitedRandomString(math.random(100, 300)))
			local str = GetLimitedRandomString(math.random(100, 300))
			local compressed = LibDeflate:CompressDeflateWithDict(str, dict)
			local extra_len = math.random(1, 10)
			local extra = GetLimitedRandomString(extra_len)
			compressed = compressed..extra
			local decompressed, unprocessed =
				LibDeflate:DecompressDeflateWithDict(compressed, dict)
			AssertLongStringEqual(str, decompressed)
			lu.assertEquals(unprocessed, extra_len)
		end
		for _ = 1, 10 do
			local str = GetLimitedRandomString(math.random(100, 300))
			local compressed = LibDeflate:CompressZlib(str)
			local extra_len = math.random(1, 10)
			local extra = GetLimitedRandomString(extra_len)
			compressed = compressed..extra
			local decompressed, unprocessed =
				LibDeflate:DecompressZlib(compressed)
			AssertLongStringEqual(str, decompressed)
			lu.assertEquals(unprocessed, extra_len)
		end
		for _ = 1, 10 do
			local dict = CreateDictionaryWithoutVerify(
				GetLimitedRandomString(math.random(100, 300)))
			local str = GetLimitedRandomString(math.random(100, 300))
			local compressed = LibDeflate:CompressZlibWithDict(str, dict)
			local extra_len = math.random(1, 10)
			local extra = GetLimitedRandomString(extra_len)
			compressed = compressed..extra
			local decompressed, unprocessed =
				LibDeflate:DecompressZlibWithDict(compressed, dict)
			AssertLongStringEqual(str, decompressed)
			lu.assertEquals(unprocessed, extra_len)
		end
	end

	function TestDecompress:TestDecompressWithDict()
		local dict = CreateDictionaryWithoutVerify("abcdefgh")
		-- local adler32 = LibDeflate:Adler32("abcdefgh")
		-- adler == 0x0e000325
		lu.assertEquals(LibDeflate:DecompressZlib(
			HexToString("78 9c 63 00 00 00 01 00 01")), "\000")
		-- The data needs dictionary, but calling
		-- DecompressZlib instead of DecompressZlibWithDict
		lu.assertEquals(LibDeflate:DecompressZlib(
			HexToString("78 bb 63 00 00 00 01 00 01")), nil)
		lu.assertEquals(LibDeflate:DecompressZlib(
			HexToString("78 bb 25 03 00 0e 63 00 00 00 01 00 01")), nil)
		lu.assertEquals(LibDeflate:DecompressZlibWithDict(
			HexToString("78 bb 0e 00 03 25 63 00 00 00 01 00 01"), dict)
			, "\000")

		-- input ends before dictionary adler32 is read.
		lu.assertEquals(LibDeflate:DecompressZlibWithDict(
			HexToString("78 bb 0e 00 03 "), dict)
			, nil)
		lu.assertEquals(LibDeflate:DecompressZlibWithDict(
			HexToString("78 bb 0e 00 "), dict)
			, nil)
		lu.assertEquals(LibDeflate:DecompressZlibWithDict(
			HexToString("78 bb 0e "), dict)
			, nil)
		lu.assertEquals(LibDeflate:DecompressZlibWithDict(
			HexToString("78 bb "), dict)
			, nil)

		-- adler32 does not match
		lu.assertEquals(LibDeflate:DecompressZlibWithDict(
			HexToString("78 bb 25 03 00 0e 63 00 00 00 01 00 01"), dict)
			, nil)
		lu.assertEquals(LibDeflate:DecompressZlibWithDict(
			HexToString("78 bb 0e 00 03 26 63 00 00 00 01 00 01"), dict)
			, nil)
	end

TestInternals = {}
	-- Test from puff
	function TestInternals:TestLoadString()
		local LoadStringToTable = LibDeflate.internals.LoadStringToTable
		local tmp
		for _=1, 50 do
			local t = {}
			local strlen = math.random(0, 1000)
			local str = GetLimitedRandomString(strlen)
			local uncorruped_data = {}
			for i=1, strlen do
				uncorruped_data[i] = math.random(1, 12345)
				t[i] = uncorruped_data[i]
			end
			local start
			local stop
			if strlen >= 1 then
				start = math.random(1, strlen)
				stop = math.random(1, strlen)
			else
				start = 1
				stop = 0
			end
			if start > stop then
				tmp = start
				start = stop
				stop = tmp
			end
			local offset = math.random(0, strlen)
			LoadStringToTable(str, t, start, stop, offset)
			for i=-1000, 2000 do
				if i < start-offset or i > stop-offset then
					lu.assertEquals(t[i], uncorruped_data[i]
						, "loadStr corrupts unintended location")
				else
					lu.assertEquals(t[i], string_byte(str, i+offset)
					, ("loadStr gives wrong data!, start=%d, stop=%d, i=%d")
						:format(start, stop, i))
				end
			end
		end
	end

	function TestInternals:TestSimpleRandom()
		for _=1, 30 do
			local strlen = math.random(0, 1000)
			local str = GetLimitedRandomString(strlen)
			local level = (math.random() < 0.5) and (math.random(1, 8)) or nil
			local expected = str
			local configs = {level = level}
			local compress = LibDeflate:CompressDeflate(str, configs)
			local _, actual = pcall(function() return LibDeflate
				:DecompressDeflate(compress) end)
			if expected ~= actual then
				local strDumpFile = io.open("fail_random.tmp", "wb")
				if (strDumpFile) then
					strDumpFile:write(str)
					print(("Failed test has been dumped to fail_random.tmp,"
						.. "with level=%s"):
						format(tostring(level)))
					strDumpFile:close()
					if type(actual) == "string" then
						print(("Error msg is:\n"), actual:sub(1, 100))
					end
				end
				lu.assertEquals(false, "My decompress does not match origin.")
			end
		end
	end

	function TestInternals:TestAdler32()
		lu.assertEquals(LibDeflate:Adler32(""), 1)
		lu.assertEquals(LibDeflate:Adler32("1"), 0x00320032)
		lu.assertEquals(LibDeflate:Adler32("12"), 0x00960064)
		lu.assertEquals(LibDeflate:Adler32("123"), 0x012D0097)
		lu.assertEquals(LibDeflate:Adler32("1234"), 0x01F800CB)
		lu.assertEquals(LibDeflate:Adler32("12345"), 0x02F80100)
		lu.assertEquals(LibDeflate:Adler32("123456"), 0x042E0136)
		lu.assertEquals(LibDeflate:Adler32("1234567"), 0x059B016D)
		lu.assertEquals(LibDeflate:Adler32("12345678"), 0x074001A5)
		lu.assertEquals(LibDeflate:Adler32("123456789"), 0x091E01DE)
		lu.assertEquals(LibDeflate:Adler32("1234567890"), 0x0B2C020E)
		lu.assertEquals(LibDeflate:Adler32("1234567890a"), 0x0D9B026F)
		lu.assertEquals(LibDeflate:Adler32("1234567890ab"), 0x106C02D1)
		lu.assertEquals(LibDeflate:Adler32("1234567890abc"), 0x13A00334)
		lu.assertEquals(LibDeflate:Adler32("1234567890abcd"), 0x17380398)
		lu.assertEquals(LibDeflate:Adler32("1234567890abcde"), 0x1B3503FD)
		lu.assertEquals(LibDeflate:Adler32("1234567890abcdef"), 0x1F980463)
		lu.assertEquals(LibDeflate:Adler32("1234567890abcefg"), 0x1F9E0466)
		lu.assertEquals(LibDeflate:Adler32("1234567890abcefgh"), 0x246C04CE)
		lu.assertEquals(LibDeflate:Adler32("1234567890abcefghi"), 0x29A30537)
		lu.assertEquals(LibDeflate:Adler32("1234567890abcefghij"), 0x2F4405A1)
		lu.assertEquals(LibDeflate:Adler32("1234567890abcefghijk"), 0x3550060C)
		lu.assertEquals(LibDeflate:Adler32("1234567890abcefghijkl")
			, 0x3BC80678)
		lu.assertEquals(LibDeflate:Adler32("1234567890abcefghijklm")
			, 0x42AD06E5)
		lu.assertEquals(LibDeflate:Adler32("1234567890abcefghijklmn")
			, 0x4A000753)
		lu.assertEquals(LibDeflate:Adler32(
			"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
			, 0x8C40150C)
		local adler32Test = GetFileData("tests/data/adler32Test.txt")
		lu.assertEquals(LibDeflate:Adler32(adler32Test), 0x5D9BAF5D)
		local adler32Test2 = GetFileData("tests/data/adler32Test2.txt")
		lu.assertEquals(LibDeflate:Adler32(adler32Test2), 0xD6A07E29)
	end

	function TestInternals:TestLibStub()
		-- Start of LibStub
		local LIBSTUB_MAJOR, LIBSTUB_MINOR = "LibStub", 2
		-- NOTE: It is intended that LibStub is global
		LibStub = _G[LIBSTUB_MAJOR]

		if not LibStub or LibStub.minor < LIBSTUB_MINOR then
			LibStub = LibStub or {libs = {}, minors = {} }
			_G[LIBSTUB_MAJOR] = LibStub
			LibStub.minor = LIBSTUB_MINOR
			function LibStub:NewLibrary(major, minor)
				assert(type(major) ==
					"string"
					, "Bad argument #2 to `NewLibrary' (string expected)")
				minor = assert(tonumber(string.match(minor, "%d+"))
				, "Minor version must either be a number or contain a number.")

				local oldminor = self.minors[major]
				if oldminor and oldminor >= minor then return nil end
				self.minors[major], self.libs[major] =
					minor, self.libs[major] or {}
				return self.libs[major], oldminor
			end
			function LibStub:GetLibrary(major, silent)
				if not self.libs[major] and not silent then
					error(("Cannot find a library instance of %q.")
					:format(tostring(major)), 2)
				end
				return self.libs[major], self.minors[major]
			end
			function LibStub:IterateLibraries() return pairs(self.libs) end
			setmetatable(LibStub, { __call = LibStub.GetLibrary })
		end
		-- End of LibStub
		local LibStub = _G.LibStub
		lu.assertNotNil(LibStub, "LibStub not in global?")
		local MAJOR = "LibDeflate"
		CheckCompressAndDecompressString("aaabbbcccddddddcccbbbaaa", "all")
		lu.assertNotNil(package.loaded["LibDeflate"]
			, "LibDeflate is not loaded")
		package.loaded["LibDeflate"] = nil
		-- Not sure if luaconv can recognize code in dofile()
		-- let's just use require
		LibDeflate = require("LibDeflate")
		lu.assertNotNil(package.loaded["LibDeflate"]
			, "LibDeflate is not loaded")
		lu.assertNotNil(LibDeflate, "LibStub does not return LibDeflate")
		lu.assertEquals(LibStub:GetLibrary(MAJOR, true), LibDeflate
			, "Cant find LibDeflate in LibStub.")
		CheckCompressAndDecompressString("aaabbbcccddddddcccbbbaaa", "all")
		------------------------------------------------------
		FullMemoryCollect()
		local memory1 = math.floor(collectgarbage("collect")*1024)
		lu.assertNotNil(package.loaded["LibDeflate"]
			, "LibDeflate is not loaded")
		package.loaded["LibDeflate"] = nil
		-- Not sure if luaconv can recognize code in dofile()
		-- let's just use require
		local LibDeflateTmp = require("LibDeflate")
		lu.assertNotNil(package.loaded["LibDeflate"]
			, "LibDeflate is not loaded")
		lu.assertEquals(LibDeflateTmp, LibDeflate
			, "LibStub unexpectedly recreates the library.")
		lu.assertNotNil(LibDeflate, "LibStub does not return LibDeflate")
		lu.assertEquals(LibStub:GetLibrary(MAJOR, true), LibDeflate
			, "Cant find LibDeflate in LibStub.")
		CheckCompressAndDecompressString("aaabbbcccddddddcccbbbaaa", "all")
		FullMemoryCollect()
		local memory2 = math.floor(collectgarbage("collect")*1024)
		if not _G.jit then
			lu.assertTrue((memory2 - memory1 <= 32)
			, ("Too much Memory leak after LibStub without update: %d")
				:format(memory2-memory1))
		end
		----------------------------------------------------
		LibStub.minors[MAJOR] = -1000
		FullMemoryCollect()
		local memory3 = math.floor(collectgarbage("collect")*1024)
		lu.assertNotNil(package.loaded["LibDeflate"]
			, "LibDeflate is not loaded")
		package.loaded["LibDeflate"] = nil
		-- Not sure if luaconv can recognize code in dofile()
		-- let's just use require
		LibDeflateTmp = require("LibDeflate")
		lu.assertNotNil(package.loaded["LibDeflate"]
			, "LibDeflate is not loaded")
		CheckCompressAndDecompressString("aaabbbcccddddddcccbbbaaa", "all")
		FullMemoryCollect()
		local memory4 = math.floor(collectgarbage("collect")*1024)
		lu.assertEquals(LibDeflateTmp, LibDeflate
			, "LibStub unexpectedly recreates the library.")
		lu.assertTrue(LibStub.minors[MAJOR] > -1000
			, "LibDeflate is not updated.")
		if not _G.jit then
			lu.assertTrue((memory4 - memory3 <= 100)
				, ("Too much Memory leak after LibStub update: %d")
				:format(memory4-memory3))
		end
	end

	function TestInternals:TestByteTo6bitChar()
		local _byte_to_6bit_char = LibDeflate.internals._byte_to_6bit_char
		lu.assertNotNil(_byte_to_6bit_char)
		lu.assertEquals(GetTableSize(_byte_to_6bit_char), 64)
		for i= 0, 25 do
			lu.assertEquals(_byte_to_6bit_char[i],
				string.char(string.byte("a", 1) + i))
		end
		for i = 26, 51 do
			lu.assertEquals(_byte_to_6bit_char[i],
				string.char(string.byte("A", 1) + i - 26))
		end
		for i = 52, 61 do
			lu.assertEquals(_byte_to_6bit_char[i],
				string.char(string.byte("0", 1) + i - 52))
		end
		lu.assertEquals(_byte_to_6bit_char[62], "(")
		lu.assertEquals(_byte_to_6bit_char[63], ")")
	end

	function TestInternals:Test6BitToByte()
		local _6bit_to_byte = LibDeflate.internals._6bit_to_byte
		lu.assertNotNil(_6bit_to_byte)
		lu.assertEquals(GetTableSize(_6bit_to_byte), 64)
		for i = string.byte("a", 1), string.byte("z", 1) do
			lu.assertEquals(_6bit_to_byte[i], i - string.byte("a", 1))
		end
		for i = string.byte("A", 1), string.byte("Z", 1) do
			lu.assertEquals(_6bit_to_byte[i], i - string.byte("A", 1) + 26)
		end
		for i = string.byte("0", 1), string.byte("9", 1) do
			lu.assertEquals(_6bit_to_byte[i], i - string.byte("0", 1) + 52)
		end
		lu.assertEquals(_6bit_to_byte[string.byte("(", 1)], 62)
		lu.assertEquals(_6bit_to_byte[string.byte(")", 1)], 63)
	end

TestPresetDict = {}
	function TestPresetDict:TestExample()
		local dict_str = [[ilvl::::::::110:::1517:3336:3528:3337]]
		local dictionary = CreateAndCheckDictionary(dict_str)
		local fileData = GetFileData("tests/data/itemStrings.txt")
		CheckDictEffectiveness(fileData, dictionary, dict_str)
	end

	function TestPresetDict:TestEmptyString()
		for i=1, 16 do
			local dict_str = GetRandomString(i)
			local dictionary = CreateAndCheckDictionary(dict_str)
			CheckDictEffectiveness("", dictionary, dict_str, true)
		end
	end

	function TestPresetDict:TestCheckDictRandomComplete()
		for _ = 1, 10 do
			local dict_str = GetRandomStringUniqueChars(
				256+math.random(0, 1000))
			CreateAndCheckDictionary(dict_str)
		end
	end

	-- Test if last two bytes in the dictionary are hashed, with dict size 3.
	function TestPresetDict:TestLength3String1()
		for _ = 1, 10 do
			local dict_str = GetRandomStringUniqueChars(3)
			local dictionary = CreateAndCheckDictionary(dict_str)
			local str = dict_str
			local compress_dict =
				CheckDictEffectiveness(str, dictionary, dict_str)
			lu.assertTrue(compress_dict:len() <= 4)
		end
	end

	-- Test if last two bytes in the dictionary is hashed, with dict size 2
	function TestPresetDict:TestLength3String2()
		for _ = 1, 10 do
			local str = GetRandomStringUniqueChars(3)
			local dict_str = str:sub(1, 2)
			str = str:sub(3, 3)..str
			local dictionary = CreateAndCheckDictionary(dict_str)

			local compress_dict =
				CheckDictEffectiveness(str, dictionary, dict_str)
			lu.assertTrue(compress_dict:len() <= 5)
		end
	end

	-- Test if last two bytes in the dictionary is hashed, with dict size 1
	function TestPresetDict:TestLength3String3()
		for _ = 1, 10 do
			local str = GetRandomStringUniqueChars(3)
			local dict_str = str:sub(1, 1)
			str = str:sub(2, 3)..str
			local dictionary = CreateAndCheckDictionary(dict_str)

			local compress_dict =
				CheckDictEffectiveness(str, dictionary, dict_str)
			lu.assertTrue(compress_dict:len() <= 6)
		end
	end

	function TestPresetDict:TestLength257String()
		for _ = 1, 10 do
			local dict_str = GetRandomStringUniqueChars(257)
			local dictionary = CreateAndCheckDictionary(dict_str)
			local str = dict_str
			local compress_dict =
				CheckDictEffectiveness(str, dictionary, dict_str)
			lu.assertTrue(compress_dict:len() <= 5)
		end
	end

	function TestPresetDict:TestLength258String()
		for _ = 1, 10 do
			local dict_str = GetRandomStringUniqueChars(258)
			local dictionary = CreateAndCheckDictionary(dict_str)
			local str = dict_str
			local compress_dict =
				CheckDictEffectiveness(str, dictionary, dict_str)
			lu.assertTrue(compress_dict:len() <= 4)
		end
	end

	function TestPresetDict:TestLength259String()
		for _ = 1, 10 do
			local dict_str = GetRandomStringUniqueChars(259)
			local dictionary = CreateAndCheckDictionary(dict_str)
			local str = dict_str
			local compress_dict =
				CheckDictEffectiveness(str, dictionary, dict_str)
			lu.assertTrue(compress_dict:len() <= 5)
		end
	end

	function TestPresetDict:TestIsEqualAdler32()
		local IsEqualAdler32 = LibDeflate.internals.IsEqualAdler32
		lu.assertTrue(IsEqualAdler32(4072834167, -222133129))
		for _ = 1, 30 do
			local rand = math.random(0, 1000)
			lu.assertTrue(IsEqualAdler32(rand, rand))
			lu.assertTrue(IsEqualAdler32(rand+256*256*256*256, rand))
			lu.assertTrue(IsEqualAdler32(rand, rand+256*256*256*256))
			lu.assertTrue(IsEqualAdler32(rand-256*256*256*256, rand))
			lu.assertTrue(IsEqualAdler32(rand, rand-256*256*256*256))
			lu.assertTrue(IsEqualAdler32(rand+256*256*256*256
				, rand+256*256*256*256))
		end
	end

TestEncode = {}
	function TestEncode:TestBasic()
		CheckEncodeAndDecode("")
		for i=0, 255 do
			CheckEncodeAndDecode(string_char(i))
		end

	end

	function TestEncode:TestRandom()
		for _ = 0, 200 do
			local str = GetRandomStringUniqueChars(math.random(256, 1000))
			CheckEncodeAndDecode(str)
		end
	end

	-- Bug in LibCompress:GetEncodeTable()
	-- version LibCompress Revision 81
	-- Date: 2018-02-25 06:31:34 +0000 (Sun, 25 Feb 2018)
	function TestEncode:TestLibCompressEncodeBug()
		local reservedChars =
		"\132\109\114\143\11\32\153\92\230\66\131\127\87\106\89\142\55\228\56"
		.."\158\151\53\48\13\71\9\37\208\101\42\217\76\19\250\125\214\146\14"
		.."\215\204\249\223\165\45\222\120\161\65\28\144\196\12\43\116\242\179"
		.."\194\1\253\147\121\99\3\107\96\67\27\44\100\148\130\221\138\85\129"
		.."\166\185\246\239\50\218\94\157\90\81\134\80\175\186\79\122\93\190"
		.."\150\154\183\91\152\70\234\169\126\108\251\6\2\22\95\233\180\105"
		.."\119\38\229\171\29\192\219\21\241\74\207\159\117\247\72\237\110"
		.."\78\118"
		local escapedChars = "\145\54"
		for _ = 1, 10 do
			local str = GetRandomStringUniqueChars(1000)
			CheckEncodeAndDecode(str, reservedChars, escapedChars, "")
		end
	end
	function TestEncode:TestRandomComplete1()
		for _ = 0, 30 do
			local tmp = GetRandomStringUniqueChars(256)
			local reserved = tmp:sub(1, 10)
			local escaped = tmp:sub(11, 11)
			local mapped = tmp:sub(12, 12+math.random(0, 9))
			local str = GetRandomStringUniqueChars(math.random(256, 1000))
			CheckEncodeAndDecode(str, reserved, escaped, mapped)
		end
	end

	function TestEncode:TestRandomComplete2()
		for _ = 0, 30 do
			local tmp = GetRandomStringUniqueChars(256)
			local reserved = tmp:sub(1, 10)
			local escaped = tmp:sub(11, 11)
			local str = GetRandomStringUniqueChars(math.random(256, 1000))
			CheckEncodeAndDecode(str, reserved, escaped, "")
		end
	end

	function TestEncode:TestRandomComplete3()
		for _ = 0, 30 do
			local tmp = GetRandomStringUniqueChars(256)
			local reserved = tmp:sub(1, 130) -- Over half chractrs escaped
			local escaped = tmp:sub(131, 132) -- Two escape char needed.
			local mapped = tmp:sub(133, 133+math.random(0, 20))
			local str = GetRandomStringUniqueChars(math.random(256, 1000))
			CheckEncodeAndDecode(str, reserved, escaped, mapped)
		end
	end

	function TestEncode:TestRandomComplete4()
		for _ = 0, 30 do
			local tmp = GetRandomStringUniqueChars(256)
			local reserved = tmp:sub(1, 130) -- Over half chractrs escaped
			local escaped = tmp:sub(131, 132) -- Two escape char needed.
			local str = GetRandomStringUniqueChars(math.random(256, 1000))
			CheckEncodeAndDecode(str, reserved, escaped, "")
		end
	end

	local function CheckEncodeForPrint(str)
		AssertLongStringEqual(LibDeflate:DecodeForPrint(LibDeflate
			:EncodeForPrint(str))
			, str)
		-- test prefixed and trailig control characters or space.
		for _, byte in pairs({0, 1, 9, 10, 11, 12, 13, 31, 32, 127}) do
			local char = string.char(byte)
			AssertLongStringEqual(LibDeflate:DecodeForPrint(LibDeflate
				:EncodeForPrint(str)..char)
				, str)
			AssertLongStringEqual(LibDeflate:DecodeForPrint(LibDeflate
				:EncodeForPrint(str)..char..char)
				, str)
			AssertLongStringEqual(LibDeflate:DecodeForPrint(LibDeflate
				:EncodeForPrint(str)..char..char..char)
				, str)
			AssertLongStringEqual(LibDeflate:DecodeForPrint(char..LibDeflate
				:EncodeForPrint(str))
				, str)
			AssertLongStringEqual(LibDeflate:DecodeForPrint(char..char..
				LibDeflate:EncodeForPrint(str))
				, str)
		end

	end
	function TestEncode:TestEncodeForPrint()
		CheckEncodeForPrint("")
		for _ = 1, 100 do
			CheckEncodeForPrint(GetRandomStringUniqueChars(
				math.random(1, 10)))
		end
		for i = 0, 255 do
			CheckEncodeForPrint(string.char(i))
		end
		for _ = 1, 400 do
			CheckEncodeForPrint(GetRandomStringUniqueChars(
				math.random(100, 1000)))
		end
		local encode_6bit_weakaura =
			GetFileData("tests/data/reference/encode_6bit_weakaura.txt")
		local decode_6bit_weakaura =
			GetFileData("tests/data/reference/decode_6bit_weakaura.txt")
		AssertLongStringEqual(LibDeflate:EncodeForPrint(decode_6bit_weakaura)
			, encode_6bit_weakaura)
	end
	function TestEncode:TestDecodeForPrintErrors()
		for i = 0, 255 do
			if string.char(i):find("[%c ]") then
				lu.assertEquals(LibDeflate:DecodeForPrint(string.char(i)), "")
			else
				lu.assertNil(LibDeflate:DecodeForPrint(string.char(i)))
			end
		end
		for i = 0, 255 do
			if not LibDeflate.internals._6bit_to_byte[i] then
				lu.assertNil(LibDeflate:DecodeForPrint(("1"
					..string.char(i)):rep(100).."1"))
			end
		end
		-- Test multiple string lengths.
		for i = 0, 255 do
			for reps = 1, 16 do
				if not LibDeflate.internals._6bit_to_byte[i] then
					lu.assertNil(LibDeflate:DecodeForPrint("2"..(
						string.char(i)):rep(reps).."3"))
				end
			end
		end
	end

	function TestEncode:TestDecodeError()
		for _ = 0, 100 do
			local tmp = GetRandomStringUniqueChars(256)
			local reserved = tmp:sub(1, 10)
			local escaped = tmp:sub(11, 11)
			local str = GetRandomStringUniqueChars(math.random(256, 1000))
			local t = LibDeflate:CreateCodec(reserved, escaped, "")
			local encode_funcs = {
					{t.Encode, t},
					{LibDeflate.EncodeForWoWAddonChannel, LibDeflate},
					{LibDeflate.EncodeForWoWChatChannel, LibDeflate},
			}
			local decode_funcs = {
					{t.Decode, t},
					{LibDeflate.DecodeForWoWAddonChannel, LibDeflate},
					{LibDeflate.DecodeForWoWChatChannel, LibDeflate},
			}
			local reserved_chars = {
				reserved,
				"\000",
				"sS\000\010\013\124%",
			}
			for j, func in ipairs(encode_funcs) do
				local encoded = func[1](func[2], str)
				reserved = reserved_chars[j]
				local random = math.random(1, #reserved)
				local reserved_char = reserved:sub(random, random)
				random = math.random(1, #encoded)
				encoded = encoded:sub(1, random-1)
					..reserved_char..encoded:sub(random, #encoded)
				lu.assertNil(decode_funcs[j][1](decode_funcs[j][2], encoded))
			end
		end
	end
	function TestEncode:TestFailCreateCodec()
		local t, err
		t, err = LibDeflate:CreateCodec("1", "", "2")
		lu.assertNil(t)
		lu.assertEquals(err, "No escape characters supplied.")
		t, err = LibDeflate:CreateCodec("1", "a", "23")
		lu.assertNil(t)
		lu.assertEquals(err, "The number of reserved characters must be"
			.." at least as many as the number of mapped chars.")
		t, err = LibDeflate:CreateCodec("", "1", "")
		lu.assertNil(t)
		lu.assertEquals(err, "No characters to encode.")
		t, err = LibDeflate:CreateCodec("1", "2", "1")
		lu.assertNil(t)
		lu.assertEquals(err, "There must be no duplicate characters in the"
			.." concatenation of reserved_chars, escape_chars and"
			.." map_chars.")
		t, err = LibDeflate:CreateCodec("2", "1", "1")
		lu.assertNil(t)
		lu.assertEquals(err, "There must be no duplicate characters in the"
			.." concatenation of reserved_chars, escape_chars and"
			.." map_chars.")
		t, err = LibDeflate:CreateCodec("1", "1", "2")
		lu.assertNil(t)
		lu.assertEquals(err, "There must be no duplicate characters in the"
			.." concatenation of reserved_chars, escape_chars and"
			.." map_chars.")
		local r = {}
		for i = 128, 255 do
			r[#r+1] = string.char(i)
		end
		local reserved_chars = "sS\000\010\013\124%"..table_concat(r)
		t, err = LibDeflate:CreateCodec(reserved_chars, "\029"
			, "\015\020")
		lu.assertNil(t)
		lu.assertEquals(err, "Out of escape characters.")
		t, err = LibDeflate:CreateCodec(reserved_chars, "\029\031"
			, "\015\020")
		lu.assertIsTable(t)
		lu.assertNil(err)
	end

TestCompressStrategy = {}
	function TestCompressStrategy:TestHtml_x_4Fixed()
		CheckCompressAndDecompressFile("tests/data/3rdparty/html_x_4"
			, {0,1,3,4}, "fixed")
	end
	function TestCompressStrategy:TestHtml_x_4HuffmanOnly()
		CheckCompressAndDecompressFile("tests/data/3rdparty/html_x_4"
			, {0,1,3,4}, "huffman_only")
	end
	function TestCompressStrategy:TestHtml_x_4Dynamic()
		CheckCompressAndDecompressFile("tests/data/3rdparty/html_x_4"
			, {0,1,2,3,4}, "dynamic")
	end
	function TestCompressStrategy:TestAsyoulikFixed()
		CheckCompressAndDecompressFile("tests/data/3rdparty/asyoulik.txt"
			, {0,1,3,4}, "fixed")
	end
	function TestCompressStrategy:TestAsyoulikHuffmanOnly()
		CheckCompressAndDecompressFile("tests/data/3rdparty/asyoulik.txt"
			, {0,1,3,4}, "huffman_only")
	end
	function TestCompressStrategy:TestAsyoulikDynamic()
		CheckCompressAndDecompressFile("tests/data/3rdparty/asyoulik.txt"
			, {0,1,3,4}, "dynamic")
	end

	-- Some hard coded compresses length here.
	-- Modify if algorithm changes.
	-- (I don't think it will happen in the future though)
	function TestCompressStrategy:TestIsFixedStrategyInEffect()
		local str = ""
		for i=0, 255 do
			str = str..string.char(i)
		end
		for i=255, 0, -1 do
			str = str..string.char(i)
		end

		lu.assertEquals(
			LibDeflate:CompressDeflate(str):len(), 517)
		lu.assertEquals(
			GetFirstBlockType(
				LibDeflate:CompressDeflate(str, {strategy = "fixed"}), false)
			, 1)
		lu.assertEquals(
			LibDeflate:CompressDeflate(str, {strategy = "fixed"}):len()
			, 542)
		lu.assertEquals(
			GetFirstBlockType(
				LibDeflate:CompressZlib(str, {strategy = "fixed"}, true))
			, 1)
		lu.assertEquals(
			LibDeflate:CompressZlib(str, {strategy = "fixed"}):len()
			, 548)
	end
	function TestCompressStrategy:TestIsHuffmanOnlyStrategyInEffect()
		local str = ("a"):rep(1000)
		lu.assertEquals(
			LibDeflate:CompressDeflate(str):len()
			, 10)
		lu.assertEquals(
			LibDeflate:CompressDeflate(str, {strategy = "huffman_only"}):len()
			, 138)
		lu.assertEquals(
			LibDeflate:CompressZlib(str):len()
			,16)
		lu.assertEquals(
			LibDeflate:CompressZlib(str, {strategy = "huffman_only"}):len()
			, 144)
	end
	function TestCompressStrategy:TestIsDynamicStrategyInEffect()
		local str = ""
		for i=0, 255 do
			str = str..string.char(i)
		end
		for i=255, 0, -1 do
			str = str..string.char(i)
		end

		lu.assertEquals(
			LibDeflate:CompressDeflate(str):len(), 517)
		lu.assertEquals(
			GetFirstBlockType(
				LibDeflate:CompressDeflate(str, {strategy = "dynamic"}), false)
			, 2)
		lu.assertEquals(
			LibDeflate:CompressDeflate(str, {strategy = "dynamic"}):len()
			, 536)
		lu.assertEquals(
			GetFirstBlockType(
				LibDeflate:CompressZlib(str, {strategy = "dynamic"}, true))
			, 2)
		lu.assertEquals(
			LibDeflate:CompressZlib(str, {strategy = "dynamic"}):len()
			, 542)
	end

TestErrors = {}
	local function TestCorruptedDictionary(msg_prefix, func, dict)
		-- Test corrupted dictionary
		local backup = DeepCopy(dict)
		for i = 1, 100 do
			if i == 1 then
				dict = nil
			elseif i == 2 then
				dict.string_table = 1
			elseif i == 3 then
				dict.string_table = nil
			elseif i == 4 then
				dict.strlen = {}
			elseif i == 5 then
				dict.strlen = 32769
			elseif i == 6 then
				dict.string_table[#dict.string_table+1] = 97
			elseif i == 7 then
				dict.hash_tables = 1
			elseif i == 8 then
				dict.hash_tables = nil
			elseif i == 9 then
				dict.adler32 = nil
			else
				break
			end
			if i == 1 then
				lu.assertErrorMsgContains(
					msg_prefix
					.."'dictionary' - table expected got 'nil'."
					, function() return func(dict) end)
			else
				lu.assertErrorMsgContains(
					msg_prefix
					.."'dictionary' - corrupted dictionary."
					, function() return func(dict) end)
			end
			dict = backup
			backup = DeepCopy(dict)
			func(dict)
		end
	end

	-- arguments to "func": str, dictionary, configs
	local function TestInvalidCompressDecompressArgs(msg_prefix, func
		, check_dictionary, check_configs)
		lu.assertErrorMsgContains(
			msg_prefix
			.."'str' - string expected got 'nil'."
			, function() return func() end)
		lu.assertErrorMsgContains(
			msg_prefix
			.."'str' - string expected got 'table'."
			, function() return func({}) end)
		local str = GetRandomString(0, 5)
		local dict = CreateDictionaryWithoutVerify(
			GetRandomString(math.random(1, 32768)))
		if check_dictionary then
			TestCorruptedDictionary(msg_prefix,
				function(dict2) return func(str, dict2, {}) end, dict)
		else
			func(str, nil, {})
		end
		if check_configs then
			func(str, dict, nil)
			func(str, dict, {})
			lu.assertErrorMsgContains(
				(
				msg_prefix
				.."'configs' - nil or table expected got '%s'.")
				:format(type(1))
				, function() return func(str, dict, 1) end)
			for i = 0, 9 do
				func(str, dict, {level = i})
			end
			local strategies = {"fixed", "huffman_only", "dynamic"}
			for _, strategy in ipairs(strategies) do
				func(str, dict, {strategy = strategy})
				func(str, dict, {level = math.random(0, 9) -- NOTE: here
					, strategy = strategy})
			end
			lu.assertErrorMsgContains(
				msg_prefix
				.."'configs' - unsupported table key in the configs:"
				.." 'not_a_key'."
				, function() return func(str, dict, {not_a_key=1}) end)
			lu.assertErrorMsgContains(
				msg_prefix
				.."'configs' - unsupported 'level': 10."
				, function() return func(str, dict, {level=10}) end)
			lu.assertErrorMsgContains(
				msg_prefix
				.."'configs' - unsupported 'strategy': 'dne'."
				, function() return func(str, dict, {strategy="dne"}) end)
		else
			func(str, dict, 1)
		end
	end

	function TestErrors:TestAdler32()
		lu.assertErrorMsgContains("Usage: LibDeflate:Adler32(str): 'str'"
			.." - string expected got 'nil'."
			, function() LibDeflate:Adler32() end)
		lu.assertErrorMsgContains("Usage: LibDeflate:Adler32(str): 'str'"
			.." - string expected got 'table'."
			, function() LibDeflate:Adler32({}) end)
		LibDeflate:Adler32("") -- No error
	end
	function TestErrors:TestCreateDictionary()
		LibDeflate:CreateDictionary("1", 1, 0x00320032)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
			.." 'str' - string expected got 'nil'."
			, function() LibDeflate:CreateDictionary(nil, 1, 0x00320032) end)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
			.." 'str' - string expected got 'table'."
			, function() LibDeflate:CreateDictionary({}, 1, 0x00320032) end)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
			.." 'strlen' - number expected got 'nil'."
			, function() LibDeflate:CreateDictionary("1", nil, 0x00320032) end)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
			.." 'adler32' - number expected got 'nil'."
			, function() LibDeflate:CreateDictionary("1", 1, nil) end)
		lu.assertEquals(LibDeflate:Adler32(""), 1)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
			.." 'str' - Empty string is not allowed."
			, function() LibDeflate:CreateDictionary("", 0, 1) end)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
			.." 'str' - string longer than 32768 bytes is not allowed."
			 .." Got 32769 bytes."
			, function() LibDeflate:CreateDictionary(("\000"):rep(32769)
					, 32769, LibDeflate:Adler32(("\000"):rep(32769))) end)
				-- ^ Dont calculate Adler32 in run-time in real problem plz.
		LibDeflate:CreateDictionary(("\000"):rep(32768)
					, 32768, LibDeflate:Adler32(("\000"):rep(32768)))
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
			.." 'strlen' does not match the actual length of 'str'."
			.." 'strlen': 32767, '#str': 32768 ."
			.." Please check if 'str' is modified unintentionally."
			, function() LibDeflate:CreateDictionary(("\000"):rep(32768)
						, 32767, LibDeflate:Adler32(("\000"):rep(32768))) end)
		-- ^ Dont calculate Adler32 in run-time in real problem plz.
		lu.assertErrorMsgContains(
			("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
				.." 'adler32' does not match the actual adler32 of 'str'."
				.." 'adler32': %u, 'Adler32(str)': %u ."
				.." Please check if 'str' is modified unintentionally.")
				:format(LibDeflate:Adler32(("\000"):rep(32768))+1
					, LibDeflate:Adler32(("\000"):rep(32768)))
			, function() LibDeflate:CreateDictionary(("\000"):rep(32768)
					, 32768, LibDeflate:Adler32(("\000"):rep(32768))+1) end)
	end
	function TestErrors:TestCompressDeflate()
		TestInvalidCompressDecompressArgs(
			"Usage: LibDeflate:CompressDeflate(str, configs): "
			, function(str, _, configs)
				return LibDeflate:CompressDeflate(str, configs) end
			, false, true)
	end
	function TestErrors:TestCompressDeflateWithDict()
		TestInvalidCompressDecompressArgs(
			"Usage: LibDeflate:CompressDeflateWithDict"
			.."(str, dictionary, configs): "
			, function(str, dictionary, configs)
				return LibDeflate:
					CompressDeflateWithDict(str, dictionary, configs) end
			, true, true)
	end
	function TestErrors:TestCompressZlib()
		TestInvalidCompressDecompressArgs(
			"Usage: LibDeflate:CompressZlib(str, configs): "
			, function(str, _, configs)
				return LibDeflate:CompressZlib(str, configs) end
			, false, true)
	end
	function TestErrors:TestCompressZlibWithDict()
		TestInvalidCompressDecompressArgs(
			"Usage: LibDeflate:CompressZlibWithDict"
			.."(str, dictionary, configs): "
			, function(str, dictionary, configs)
				return LibDeflate:
					CompressZlibWithDict(str, dictionary, configs) end
			, true, true)
	end
	function TestErrors:TestDecompressDeflate()
		TestInvalidCompressDecompressArgs(
			"Usage: LibDeflate:DecompressDeflate(str): "
			, function(str, _, _)
				return LibDeflate:DecompressDeflate(str) end
			, false, false)
	end
	function TestErrors:TestDecompressZlib()
		TestInvalidCompressDecompressArgs(
			"Usage: LibDeflate:DecompressZlib(str): "
			, function(str, _, _)
				return LibDeflate:DecompressZlib(str) end
			, false, false)
	end
	function TestErrors:TestDecompressDeflateWithDict()
		TestInvalidCompressDecompressArgs(
			"Usage: LibDeflate:DecompressDeflateWithDict(str, dictionary): "
			, function(str, dict, _)
				return LibDeflate:DecompressDeflateWithDict(str, dict) end
			, true, false)
	end
	function TestErrors:TestDecompressZlibWithDict()
		TestInvalidCompressDecompressArgs(
			"Usage: LibDeflate:DecompressZlibWithDict(str, dictionary): "
			, function(str, dict, _)
				return LibDeflate:DecompressZlibWithDict(str, dict) end
			, true, false)
	end
	function TestErrors:TestCreateCodec()
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:CreateCodec(reserved_chars,"
			.." escape_chars, map_chars):"
			.." All arguments must be string."
			, function()
				LibDeflate:CreateCodec(nil, "", "")
			end)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:CreateCodec(reserved_chars,"
			.." escape_chars, map_chars):"
			.." All arguments must be string."
			, function()
				LibDeflate:CreateCodec("", nil, "")
			end)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:CreateCodec(reserved_chars,"
			.." escape_chars, map_chars):"
			.." All arguments must be string."
			, function()
				LibDeflate:CreateCodec("", "", nil)
			end)
		local t, err = LibDeflate:CreateCodec("1", "2", "")
		lu.assertNil(err)
	end
	function TestErrors:TestEncodeDecode()
		local codec = LibDeflate:CreateCodec("\000", "\001", "")
		lu.assertErrorMsgContains(
			"Usage: codec:Encode(str):"
			.." 'str' - string expected got 'nil'."
			, function() codec:Encode() end)
		lu.assertErrorMsgContains(
			"Usage: codec:Decode(str):"
			.." 'str' - string expected got 'nil'."
			, function() codec:Decode() end)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:EncodeForWoWAddonChannel(str):"
			.." 'str' - string expected got 'nil'."
			, function() LibDeflate:EncodeForWoWAddonChannel() end)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:DecodeForWoWAddonChannel(str):"
			.." 'str' - string expected got 'nil'."
			, function() LibDeflate:DecodeForWoWAddonChannel() end)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:EncodeForWoWChatChannel(str):"
			.." 'str' - string expected got 'nil'."
			, function() LibDeflate:EncodeForWoWChatChannel() end)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:DecodeForWoWChatChannel(str):"
			.." 'str' - string expected got 'nil'."
			, function() LibDeflate:DecodeForWoWChatChannel() end)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:EncodeForPrint(str):"
			.." 'str' - string expected got 'nil'."
			, function() LibDeflate:EncodeForPrint() end)
		lu.assertErrorMsgContains(
			"Usage: LibDeflate:DecodeForPrint(str):"
			.." 'str' - string expected got 'nil'."
			, function() LibDeflate:DecodeForPrint() end)
	end



local lua_program = "lua"
local function RunCommandline(args, stdin)
	local input_filename = "tests/test.stdin"
	if stdin then
		WriteToFile(input_filename, stdin)
	else
		WriteToFile(input_filename, "")
	end
	local stdout_filename = "tests/test.stderr"
	local stderr_filename = "tests/test.stdout"
	local libdeflate_file = "./LibDeflate.lua"
	if os.getenv("OS") and os.getenv("OS"):find("Windows") then
		libdeflate_file = "LibDeflate.lua"
	end
	local status, _, ret = os.execute(lua_program.." "..libdeflate_file.." "
		..args.." >"..input_filename
		.. "> "..stdout_filename.." 2> "..stderr_filename)

	local returned_status
	if type(status) == "number" then -- lua 5.1
		returned_status = status
	else -- Lua 5.2/5.3
		returned_status = ret
		if not status and ret == 0 then
			returned_status = -1
			-- Lua bug on Windows when the returned value is -1, ret is 0
		end
	end

	local stdout = GetFileData(stdout_filename)
	local stderr = GetFileData(stderr_filename)
	return returned_status, stdout, stderr
end

TestCommandLine = {}
	function TestCommandLine:TestHelp()
		local returned_status, stdout, stderr = RunCommandline("-h")
		lu.assertEquals(returned_status, 0)

		local str = LibDeflate._COPYRIGHT
			.."\nUsage: lua LibDeflate.lua [OPTION] [INPUT] [OUTPUT]\n"
			.."  -0    store only. no compression.\n"
			.."  -1    fastest compression.\n"
			.."  -9    slowest and best compression.\n"
			.."  -d    do decompression instead of compression.\n"
			.."  --dict <filename> specify the file that contains"
			.." the entire preset dictionary.\n"
			.."  -h    give this help.\n"
			.."  --strategy <fixed/huffman_only/dynamic>"
			.." specify a special compression strategy.\n"
			.."  -v    print the version and copyright info.\n"
			.."  --zlib  use zlib format instead of raw deflate.\n"

		if stdout:find(str, 1, true) then
			lu.assertStrContains(stdout, str)
		else
			str = str:gsub("\n", "\r\n")
			lu.assertStrContains(stdout, str)
		end
		lu.assertEquals(stderr, "")
	end

	function TestCommandLine:TestCopyright()
		local returned_status, stdout, stderr = RunCommandline("-v")
		lu.assertEquals(returned_status, 0)

		local str = LibDeflate._COPYRIGHT

		if stdout:find(str, 1, true) then
			lu.assertStrContains(stdout, str)
		else
			str = str:gsub("\n", "\r\n")
			lu.assertStrContains(stdout, str)
		end
		lu.assertEquals(stderr, "")
	end

	function TestCommandLine:TestErrors()
		local returned_status, stdout, stderr

		returned_status, stdout, stderr =
			RunCommandline("-invalid")
		lu.assertNotEquals(returned_status, 0)
		lu.assertEquals(stdout, "")
		lu.assertStrContains(stderr, ("LibDeflate: Invalid argument: %s")
				:format("-invalid"))

		returned_status, stdout, stderr =
			RunCommandline("tests/data/reference/item_strings.txt --dict")
		lu.assertNotEquals(returned_status, 0)
		lu.assertEquals(stdout, "")
		lu.assertStrContains(stderr, "You must speicify the dict filename")

		returned_status, stdout, stderr =
			RunCommandline("tests/data/reference/item_strings.txt --dict DNE")
		lu.assertNotEquals(returned_status, 0)
		lu.assertEquals(stdout, "")
		lu.assertStrContains(stderr,
			("LibDeflate: Cannot read the dictionary file '%s':")
			:format("DNE"))

		returned_status, stdout, stderr =
			RunCommandline("DNE DNE")
		lu.assertNotEquals(returned_status, 0)
		lu.assertEquals(stdout, "")
		lu.assertStrContains(stderr, "LibDeflate: Cannot read the file 'DNE':")

		returned_status, stdout, stderr =
			RunCommandline("tests/data/reference/item_strings.txt ..")
		lu.assertNotEquals(returned_status, 0)
		lu.assertEquals(stdout, "")
		lu.assertStrContains(stderr, "LibDeflate: Cannot write the file '..':")

		returned_status, stdout, stderr =
			RunCommandline("tests/data/reference/item_strings.txt")
		lu.assertNotEquals(returned_status, 0)
		lu.assertEquals(stdout, "")
		lu.assertStrContains(stderr, "LibDeflate:"
			.." You must specify both input and output files.")

		returned_status, stdout, stderr =
			RunCommandline("-d tests/data/reference/item_strings.txt"
						.." tests/test_commandline.tmp")
		lu.assertNotEquals(returned_status, 0)
		lu.assertEquals(stdout, "")
		lu.assertStrContains(stderr, "LibDeflate: Decompress fails.")
	end

	function TestCommandLine:TestCompressAndDecompress()
		local funcs = {"CompressDeflate", "CompressDeflateWithDict"
					, "CompressZlib", "CompressZlibWithDict"
					, "DecompressDeflate", "DecompressDeflateWithDict"
					, "DecompressZlib", "DecompressZlibWithDict"}
		local args = {"", "--dict tests/dictionary32768.txt"
					, "--zlib", "--zlib --dict tests/dictionary32768.txt"
					, "-d", "-d --dict tests/dictionary32768.txt"
					, "-d --zlib", "-d --zlib --dict tests/dictionary32768.txt"}
		local inputs = {"tests/data/reference/item_strings.txt"
						,"tests/data/reference/item_strings.txt"
						, "tests/data/reference/item_strings.txt"
						, "tests/data/reference/item_strings.txt"
						, "tests/data/reference/item_strings_deflate.txt"
					, "tests/data/reference/item_strings_deflate_with_dict.txt"
				, "tests/data/reference/item_strings_zlib.txt"
				, "tests/data/reference/item_strings_zlib_with_dict.txt"}
		local addition_args = {
			"-0 "
			, "-1 --strategy huffman_only"
			, "-5 --strategy dynamic"
			, "-9 --strategy fixed"
			, ""
		}
		local addition_configs = {
			{level = 0}
			, {level = 1, strategy = "huffman_only"}
			, {level = 5, strategy = "dynamic"}
			, {level = 9, strategy = "fixed"}
			, nil
		}
		for k, func_name in ipairs(funcs) do
			local configs
			local addition_arg
			for i = 1, #addition_args do
				configs = addition_configs[i]
				addition_arg = addition_args[i]
				if not configs then
					print(("Testing TestCommandline: %s")
						:format(func_name))
				else
					print(
					("Testing TestCommandline: %s level: %s strategy: %s")
						:format(func_name, tostring(configs.level)
						, tostring(configs.strategy)))
				end
				local returned_status, stdout, stderr =
					RunCommandline(args[k].." "..addition_arg
							.." "..inputs[k]
							.." tests/test_commandline.tmp")
				lu.assertEquals(stdout, "")
				lu.assertStrContains(stderr, ("Successfully writes %d bytes")
					:format(GetFileData("tests/test_commandline.tmp"):len()))
				lu.assertEquals(returned_status, 0)
				local result
				if func_name:find("Dict") then
					result = LibDeflate[func_name](LibDeflate, GetFileData(
						inputs[k]), dictionary32768, configs)
				else
					result = LibDeflate[func_name](LibDeflate, GetFileData(
						inputs[k]), configs)
				end
				lu.assertNotNil(result)
				lu.assertEquals(GetFileData("tests/test_commandline.tmp")
					, result)
			end
		end
	end

TestCompressRatio = {}
	-- May need to modify number if algorithm changes.
	function TestCompressRatio:TestSmallTest()
		-- avoid github auto CRLF problem by removing \n in the file.
		local fileData = GetFileData("tests/data/smalltest_no_newline.txt")
		lu.assertEquals(fileData:len(), 28453)
		lu.assertTrue(LibDeflate:CompressDeflate(fileData, {level=0}):len()
			<= 28458)
		lu.assertTrue(LibDeflate:CompressDeflate(fileData, {level=1}):len()
			<= 7467)
		lu.assertTrue(LibDeflate:CompressDeflate(fileData, {level=2}):len()
			<= 7011)
		lu.assertTrue(LibDeflate:CompressDeflate(fileData, {level=3}):len()
			<= 6740)
		lu.assertTrue(LibDeflate:CompressDeflate(fileData, {level=4}):len()
			<= 6401)
		lu.assertTrue(LibDeflate:CompressDeflate(fileData, {level=5}):len()
			<= 5992)
		lu.assertTrue(LibDeflate:CompressDeflate(fileData, {level=6}):len()
			<= 5884)
		lu.assertTrue(LibDeflate:CompressDeflate(fileData, {level=7}):len()
			<= 5829)
		lu.assertTrue(LibDeflate:CompressDeflate(fileData, {level=8}):len()
			<= 5820)
		lu.assertTrue(LibDeflate:CompressDeflate(fileData, {level=9}):len()
			<= 5820)
	end

TestExported = {}
	function TestExported:TestExported()
		local exported = {
			EncodeForWoWChatChannel = "function",
			_COPYRIGHT = "string",
			DecodeForWoWAddonChannel = "function",
			CompressDeflate  = "function",
			DecompressDeflate = "function",
			CompressDeflateWithDict = "function",
			DecompressZlibWithDict = "function",
			CreateCodec = "function",
			DecodeForWoWChatChannel = "function",
			internals = "table",
			_VERSION = "string",
			_MAJOR = "string",
			_MINOR = "number",
			Adler32 = "function",
			CreateDictionary = "function",
			CompressZlibWithDict = "function",
			EncodeForPrint = "function",
			CompressZlib = "function",
			DecodeForPrint = "function",
			DecompressDeflateWithDict = "function",
			EncodeForWoWAddonChannel = "function",
			DecompressZlib = "function",
		}
		for k, v in pairs(exported) do
			lu.assertEquals(v, type(LibDeflate[k]))
		end
		for k, v in pairs(LibDeflate) do
			lu.assertEquals(type(v), exported[k])
		end
	end
--------------------------------------------------------------
-- Coverage Tests --------------------------------------------
--------------------------------------------------------------
local function AddToCoverageTest(suite, test)
	assert(suite)
	assert(type(suite[test]) == "function")
	CodeCoverage[test] = function(_, ...)
		return suite[test](_G[suite], ...) end
end
local function AddAllToCoverageTest(suite)
	for k, _ in pairs(suite) do
		AddToCoverageTest(suite, k)
	end
end

-- Run "luajit -lluacov tests/Test.lua CodeCoverage" for test coverage test.
CodeCoverage = {}
	AddAllToCoverageTest(TestBasicStrings)
	AddAllToCoverageTest(TestDecompress)
	AddAllToCoverageTest(TestInternals)
	AddAllToCoverageTest(TestPresetDict)
	AddAllToCoverageTest(TestEncode)
	AddAllToCoverageTest(TestErrors)
	AddToCoverageTest(TestMyData, "TestSmallTest")
	AddToCoverageTest(TestThirdPartyBig, "Testptt5")
	AddToCoverageTest(TestThirdPartyBig, "TestGeoProtodata")
	AddToCoverageTest(TestCompressStrategy, "TestIsFixedStrategyInEffect")
	AddToCoverageTest(TestCompressStrategy, "TestIsDynamicStrategyInEffect")
	AddToCoverageTest(TestCompressStrategy, "TestIsHuffmanOnlyStrategyInEffect")

-- Run "lua tests/Test.lua CommandLineCodeCoverage "
-- for test coverage test and CommandLineCodeCoverage
-- DONT run with "luajit -lluaconv"
CommandLineCodeCoverage = {}
	for k, v in pairs(TestCommandLine) do
		CommandLineCodeCoverage[k] = function(_, ...)
			lua_program = "lua -lluacov"
			return TestCommandLine[k](TestCommandLine, ...)
		end
	end

-- Check if decompress will produce any lua error for random string.
-- Expectation is that no Lua error.
-- This test is not run in CI.
DecompressLuaErrorTest = {}
	function DecompressLuaErrorTest:Test()
		math.randomseed(os.time())
		for _=1, 10000 do
			local len = math.random(0, 10000)
			local str = GetRandomString(len)
			local dict = CreateDictionaryWithoutVerify(
				GetRandomString(math.random(1, 32768)))
			local r1, r2
			r1, r2 = LibDeflate:DecompressDeflate(str)
			-- Check the type of return value
			assert((type(r1) == "string" or type(r1) == "nil") and r2 % 1 == 0)
			r1, r2 = LibDeflate:DecompressZlib(str)
			assert((type(r1) == "string" or type(r1) == "nil") and r2 % 1 == 0)
			r1, r2 = LibDeflate:DecompressDeflateWithDict(str, dict)
			assert((type(r1) == "string" or type(r1) == "nil") and r2 % 1 == 0)
			r1, r2 = LibDeflate:DecompressZlibWithDict(str, dict)
			assert((type(r1) == "string" or type(r1) == "nil") and r2 % 1 == 0)
			print("Decompressed one random string without Lua error.")
			print(StringForPrint(StringToHex(str)))
		end
	end

-- Tests for some huge test data.
-- The test data is not in the repository.
-- Run the batch script in tests\dev_scripts\download_huge_data.bat
-- to download.
-- This test is not run in CI.
HugeTests = {}
	function HugeTests:TestCanterburyBible()
		CheckCompressAndDecompressFile("tests/huge_data/bible.txt", "all")
	end
	function HugeTests:TestCanterburyEColi()
		CheckCompressAndDecompressFile("tests/huge_data/E.coli", "all")
	end
	function HugeTests:TestCanterburyWorld129()
		CheckCompressAndDecompressFile("tests/huge_data/world192.txt", "all")
	end
	do
		local silesia_files = {"dickens", "mozilla", "mr", "nci", "ooffice"
				, "osdb", "reymont", "samba", "sao", "webster", "xml", "x-ray"}
		for _, f in pairs(silesia_files) do
			HugeTests["TestSilesia"..f:sub(1, 1):upper()..f:sub(2)] = function()
				CheckCompressAndDecompressFile("tests/huge_data/"..f
				, {0, 1, 2, 3, 4})
			end
		end
	end

for k, v in pairs(_G) do
	if type(k) == "string" and (k:find("^Test") or k:find("^test")) then
		assert(type(v) == "table", "Globals start with Test or test"
			.." must be table: "..k)
		for kk, vv in pairs(v) do
			assert(type(kk) == "string"
				and kk:find("^Test"), "All members in test table"
				.." s key must start with Test: "..tostring(kk))
			assert(type(vv) == "function", "All members in test table"
				.." must be function")
		end
	end
end

--
-- Performance Evaluation, compared with LibCompress
--
local function CheckCompressAndDecompressLibCompress(
	string_or_filename, is_file)

	FullMemoryCollect()
	local LibCompress = require("LibCompress")

	local origin
	if is_file then
		origin = GetFileData(string_or_filename)
	else
		origin = string_or_filename
	end

	FullMemoryCollect()
	local total_memory_before = math.floor(collectgarbage("count")*1024)

	do
		print(
			(">>>>> %s: %s size: %d B (LibCompress)")
			:format(is_file and "File" or "String",
				string_or_filename:sub(1, 40),  origin:len()
			))
		local compress_to_run = {
			{"Compress", origin},
			{"CompressLZW", origin},
			{"CompressHuffman", origin},
		}

		for j, compress_running in ipairs(compress_to_run) do
		-- Compress by raw deflate
			local compress_func_name = compress_running[1]
			local compress_memory_leaked, compress_memory_used
				, compress_time, compress_data =
				MemCheckAndBenchmarkFunc(LibCompress
					, unpack(compress_running))

			local decompress_to_run = {
				{"Decompress", compress_data},
				{"Decompress", compress_data},
				{"Decompress", compress_data},
			}
			lu.assertEquals(#decompress_to_run, #compress_to_run)

			-- Try decompress by LibDeflate
			local decompress_memory_leaked, decompress_memory_used,
				decompress_time, decompress_data =
				MemCheckAndBenchmarkFunc(LibCompress
					, unpack(decompress_to_run[j]))
			AssertLongStringEqual(decompress_data, origin
				, compress_func_name
				.." LibCompress decompress result not match origin string.")

			print(
				("%s:   Size : %d B,Time: %.3f ms, "
					.."Speed: %.0f KB/s, Memory: %d B,"
					.." Mem/input: %.2f, (memleak?: %d B)\n")
					:format(compress_func_name
					, compress_data:len(), compress_time
					, compress_data:len()/compress_time
					, compress_memory_used
					, compress_memory_used/origin:len()
					, compress_memory_leaked
				),
				("%s:   cRatio: %.2f,Time: %.3f ms"
					..", Speed: %.0f KB/s, Memory: %d B,"
					.." Mem/input: %.2f, (memleak?: %d B)"):format(
					decompress_to_run[j][1]
					, origin:len()/compress_data:len(), decompress_time
					, decompress_data:len()/decompress_time
					, decompress_memory_used
					, decompress_memory_used/origin:len()
					, decompress_memory_leaked
				)
			)
			print("")
		end
	end

	FullMemoryCollect()
	local total_memory_after = math.floor(collectgarbage("count")*1024)

	local total_memory_difference = total_memory_before - total_memory_after

	if total_memory_difference > 0 then
		local ignore_leak = " (Ignore when the test is for LibCompress)"
		print(
			(">>>>> %s: %s size: %d B\n")
				:format(is_file and "File" or "String"
				, string_or_filename:sub(1, 40), origin:len()),
			("Actual Memory Leak in the test: %d"..ignore_leak.."\n")
				:format(total_memory_difference),
			"\n")
	end
end

local function EvaluatePerformance(filename)
	local interpreter = _G._VERSION
	if _G.jit then
		interpreter = interpreter.."(LuaJIT)"
	end
	print(interpreter)
	print("^^^^^^^^^^^^")
	CheckCompressAndDecompressLibCompress(filename, true)
	CheckCompressAndDecompressFile(filename, "all")
end

PerformanceEvaluation = {}
	function PerformanceEvaluation:TestEvaluateWarlockWeakAuras()
		EvaluatePerformance("tests/data/warlockWeakAuras.txt")
	end
	function PerformanceEvaluation:TestEvaluateTotalRp3Data()
		EvaluatePerformance("tests/data/totalrp3.txt")
	end

local runner = lu.LuaUnit.new()
local exitCode = runner:runSuite()
print("========================================================")
print("LibDeflate", "Version:", LibDeflate._VERSION, "\n")
print("Exported keys:")
for k, v in pairs(LibDeflate) do
	assert(type(k) == "string")
	print(k, type(v))
end
print("--------------------------------------------------------")
if exitCode == 0 then
	print("TEST OK")
else
	print("TEST FAILED")
end

os.exit(exitCode)

================
File: Libs/vanilla/Libs.xml
================
<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\FrameXML\UI.xsd">
	<Include file="CallbackHandler-1.0\CallbackHandler-1.0.xml"/>
	<Include file="AceCore-3.0\AceCore-3.0.xml"/>
	<Include file="AceTimer-3.0\AceTimer-3.0.xml"/>
	<!--<Include file="LibDeflate\lib.xml"/>-->
</Ui>

================
File: Libs/vanilla/LibStub/LibStub.lua
================
print("|cffff0000[DEBUG] STO CARICANDO LibStub.lua ORA!|r")
-- LibStub is a simple versioning stub meant for use in Libraries.  http://www.wowace.com/wiki/LibStub for more info
-- LibStub is hereby placed in the Public Domain Credits: Kaelten, Cladhaire, ckknight, Mikk, Ammo, Nevcairiel, joshborke
local LIBSTUB_MAJOR, LIBSTUB_MINOR = "LibStub", 2 -- NEVER MAKE THIS AN SVN REVISION! IT NEEDS TO BE USABLE IN ALL REPOS!
local _G = getfenv()
local strfind, strfmt = string.find, string.format
local LibStub = _G[ LIBSTUB_MAJOR ]

if not LibStub or LibStub.minor < LIBSTUB_MINOR then
  LibStub = LibStub or { libs = {}, minors = {} }
  _G[ LIBSTUB_MAJOR ] = LibStub
  LibStub.minor = LIBSTUB_MINOR

  function LibStub:NewLibrary( major, minor )
    assert( type( major ) == "string", "Bad argument #2 to `NewLibrary' (string expected)" )
    local _, _, num = strfind( minor, "(%d+)" )
    minor = assert( tonumber( num ), "Minor version must either be a number or contain a number." )

    local oldminor = self.minors[ major ]
    if oldminor and oldminor >= minor then return nil end
    self.minors[ major ], self.libs[ major ] = minor, self.libs[ major ] or {}
    return self.libs[ major ], oldminor
  end

  function LibStub:GetLibrary( major, silent )
    if not self.libs[ major ] and not silent then
      error( strfmt( "Cannot find a library instance of %q.", tostring( major ) ), 2 )
    end
    return self.libs[ major ], self.minors[ major ]
  end

  function LibStub:IterateLibraries() return pairs( self.libs ) end

  setmetatable( LibStub, { __call = LibStub.GetLibrary } )
end

================
File: phrases.lua
================
-- phrases.lua
-- I dati delle frasi sono definiti direttamente come una tabella Lua nativa.
RaidCaller = RaidCaller or {}

RaidCaller.PhraseData = {
  ["Onyxia's Lair"] = {
    ["Onyxia"] = {
      ["Phrases"] = {
        "PHASE 1! Tank, position her facing the back wall. NOW!",
        "DPS and Healers, get to her sides! Do NOT stand in front or behind!",
        "WATCH THE TAIL! Don't get knocked into the whelps!",
        "PHASE 2! She's airborne! Spread out and prepare for Deep Breath!",
        "WATCH HER DIRECTION! Move to the safe zones NOW!",
        "Melee, focus on whelps! Ranged, burn the boss!",
        "PHASE 3! She's landing! Back to positions on the sides!",
        "FEAR INCOMING! Get your Tremor Totems down! Warriors, Berserker Rage!",
        "WATCH YOUR FEET! Get out of the fire cracks on the floor!"
      }
    }
  },
  ["Ruins of Ahn'Qiraj"] = {
    ["Kurinaxx"] = { ["Phrases"] = { "Tank, keep him faced away from the raid!", "Sand Traps are spawning! MOVE AWAY NOW! The explosion is huge!", "Off-tank, prepare to taunt! Main tank, let your debuff drop.", "ENRAGE at 30%! All DPS, burn him down!" } },
    ["General Rajaxx"] = { ["Phrases"] = { "Healers, keep our friendly NPCs alive! They are key!", "Tanks, backs to a wall! Prepare for the knockback!", "Waves incoming! CC any loose adds! Sheep, fear, root them!" } },
    ["Moam"] = { ["Phrases"] = { "MANA BURNERS! Drain his mana NOW! Stop the Arcane Eruption!", "He's turning to stone! Prepare for Mana Fiends!", "Warlocks, banish two fiends! DPS, focus fire the third one down!" } },
    ["Buru the Gorger"] = { ["Phrases"] = { "DPS, get all eggs to 10% health but DO NOT KILL them yet.", "Kiter, you're targeted! Lead Buru over a low-health egg!", "DPS, the egg is in position! KILL THE EGG NOW!", "ADD SPAWNED! Switch and kill the add immediately!", "ENRAGE at 20%! It's a burn phase! All cooldowns, GO!" } },
    ["Ayamiss the Hunter"] = { ["Phrases"] = { "PHASE 1 - AIR PHASE! Melee, your job is the larva! Kill it before it reaches the player!", "Ranged DPS with Nature Resist, you are soaking the Poison Stinger!", "ADD WAVES! They have low health, AOE them down fast!", "PHASE 2 - GROUND! She's landing! Tanks, pick her up! Face her away!" } },
    ["Ossirian the Unscarred"] = { ["Phrases"] = { "This is all about coordination! Stay focused!", "Puller, drag him to the first crystal! ACTIVATE!", "He's vulnerable! DPS, focus on the correct magic school!", "He cannot be taunted! Watch your threat! Tanks, use potions for the stun!" } }
  },
  ["Temple of Ahn'Qiraj"] = {
    ["The Prophet Skeram"] = { ["Phrases"] = { "Tank him in the center! Don't let him cast Earth Shock!", "INTERRUPT the Arcane Explosion!", "MIND CONTROL! Someone is big! Mages, Polymorph them NOW!", "HE'S SPLITTING! Groups, get to your assigned positions!", "Tanks, pick up the copies! DPS, burn the fakes down FAST!" } },
    ["The Bug Trio"] = { ["Phrases"] = { "Focus target is set! All DPS on the marked bug!", "DISPEL! Toxic Volley is out! Healers, cleanse the poison!", "Princess Yauj is fearing! Backup tank, be ready to taunt!", "INTERRUPT Yauj's heal!" } },
    ["Battleguard Sartura"] = { ["Phrases"] = { "EVERYONE SPREAD OUT! Don't get cleaved by Whirlwind!", "Tanks, pick up the adds and face them away! KILL ADDS FIRST!", "FIXATE! Sartura is loose! Taunt rotation, keep her still!", "They stopped spinning! STUN them now!" } },
    ["Fankriss the Unyielding"] = { ["Phrases"] = { "Tank swap! Mortal Wound stacks are high!", "PLAYER ENTANGLED! Healers, focus heals on them!", "WORMS ARE UP! All DPS, switch to worms NOW! Stun and kill them before they enrage!" } },
    ["Viscidus"] = { ["Phrases"] = { "PHASE 1: FREEZE! Hit him with Frost damage! Wands, oils, everything!", "HE'S FROZEN! PHASE 2: SHATTER! Melee, get in there and hit him NOW!", "HE'S SHATTERED! PHASE 3: DPS! Kill the globs before they reform!", "Engineers, prepare Sapper Charges for when they group up!" } },
    ["Princess Huhuran"] = { ["Phrases"] = { "Melee, you are soaking poison! Make sure your Nature Resist gear is on!", "Ranged and Healers, stay spread out to avoid Noxious Poison spread!", "DISPELLERS, only dispel Wyvern Sting on TANKS!", "FRENZY! Designated ranged, TRANQ SHOT NOW!", "ENRAGE at 30%! This is a pure DPS race! BURN HER!" } },
    ["The Twin Emperors"] = { ["Phrases"] = { "Keep them separated! They heal if they're too close!", "Melee on the magic-immune twin! Casters on the melee-immune twin!", "Warlock tanks, maintain threat on Vek'lor! Spam Searing Pain!", "TELEPORT INCOMING! Melee, start moving to the other side NOW!", "Threat is reset! Tanks, pick up your new targets quickly!" } },
    ["Ouro"] = { ["Phrases"] = { "Tank swap on Sand Blast! Second tank, get ready!", "HE'S BURROWING! Spread out and dodge the Quake!", "SCARABS ARE UP! Group them up and AOE them down!", "ENRAGE at 20%! He's faster and stronger! Stay focused and burn!" } },
    ["C'Thun"] = { ["Phrases"] = { "PULLING! Get to your assigned group positions NOW!", "SPREAD OUT! Do NOT chain the Eye Beam!", "DARK GLARE! He's turning! Rotate with the beam! Stay alive!", "Claw Tentacles are up! Tanks, grab them! DPS, burn them!", "Eaten players, you are in the stomach! Kill the tentacles inside to weaken the boss!", "VULNERABLE! The eye is weak! All DPS, use cooldowns and BURN HIM NOW!" } }
  },
  ["Zul'Gurub"] = {
    ["High Priestess Jeklik"] = { ["Phrases"] = { "Interrupt her heal! Ranged, stay back to avoid silence!", "BATS INCOMING! AOE them down! Designated ranged, bait the charge!" } },
    ["High Priest Venoxis"] = { ["Phrases"] = { "Melee, stay max range! Do not chain the lightning!", "SNAKE FORM! He's dropping poison clouds! Tank, start kiting him around the room!" } },
    ["High Priestess Mar'li"] = { ["Phrases"] = { "SPIDER ADDS are top priority! Kill them FAST!", "SPIDER FORM! Melee are rooted! Off-tank, grab her when she charges ranged!" } },
    ["Bloodlord Mandokir"] = { ["Phrases"] = { "WATCHING YOU! If he's gazing at you, DO NOT MOVE OR ACT!", "CHARGE! He wiped aggro! Off-tank, taunt him NOW!", "Do not die! Every death makes him stronger!" } },
    ["Edge of Madness Bosses"] = { ["Phrases"] = { "OHGAN: Spread out! Avoid lightning clouds!", "HAZZA'RAH: Mana users, drain his mana! Kill the illusions fast!", "RENATAKI: Vanished! Use AOE to break his stealth!" } },
    ["High Priest Thekal"] = { ["Phrases"] = { "PHASE 1: Kill tiger adds first! Tanks, keep the bosses separated!", "Get all three bosses to 10%... NOW! Group them up and AOE them down!", "PHASE 2: TIGER FORM! Tank swap on Force Punch!" } },
    ["Gahz'ranka"] = { ["Phrases"] = { "Everyone in the water!", "Tank him underwater to nullify his main mechanic. Easy kill!" } },
    ["High Priestess Arlokk"] = { ["Phrases"] = { "Two tanks needed for gouge swaps.", "Marked player, kite the panthers away!", "SHE VANISHED! All DPS, kill the panther adds NOW!", "Backs to the wall! She's about to reappear and burst someone down!" } },
    ["Jindo the Hexer"] = { ["Phrases"] = { "TOTEMS are top priority! Kill Brainwash and Healing Totems first!", "Player teleported to the pit! Get out ASAP!", "Druid tank is best here! Warriors, prepare for hex swaps.", "CURSED PLAYERS! You can see the ghosts! Kill the Shades of Jindo! DO NOT DECURE!" } },
    ["Hakkar the Soulflayer"] = { ["Phrases"] = { "BLOOD SIPHON SOON! Designated puller, bring in a Son of Hakkar!", "Kill the add NOW! Everyone stack in the poison cloud!", "Corrupted Blood is out! If you have it, move away from the raid!", "ENRAGE at 5%! Push him now! Victory is close!" } }
  }
}

================
File: RaidCaller.code-workspace
================
{
	"folders": [
		{
			"path": "."
		}
	],
	"settings": {}
}

================
File: Libs/vanilla/Ace3/AceGUI-3.0/AceGUI-3.0.lua
================
--- **AceGUI-3.0** provides access to numerous widgets which can be used to create GUIs.
-- AceGUI is used by AceConfigDialog to create the option GUIs, but you can use it by itself
-- to create any custom GUI. There are more extensive examples in the test suite in the Ace3
-- stand-alone distribution.
--
-- **Note**: When using AceGUI-3.0 directly, please do not modify the frames of the widgets directly,
-- as any "unknown" change to the widgets will cause addons that get your widget out of the widget pool
-- to misbehave. If you think some part of a widget should be modifiable, please open a ticket, and we"ll
-- implement a proper API to modify it.
-- @usage
-- local AceGUI = LibStub("AceGUI-3.0")
-- -- Create a container frame
-- local f = AceGUI:Create("Frame")
-- f:SetCallback("OnClose",function(widget) AceGUI:Release(widget) end)
-- f:SetTitle("AceGUI-3.0 Example")
-- f:SetStatusText("Status Bar")
-- f:SetLayout("Flow")
-- -- Create a button
-- local btn = AceGUI:Create("Button")
-- btn:SetWidth(170)
-- btn:SetText("Button !")
-- btn:SetCallback("OnClick", function() print("Click!") end)
-- -- Add the button to the container
-- f:AddChild(btn)
-- @class file
-- @name AceGUI-3.0
-- @release $Id: AceGUI-3.0.lua 1102 2013-10-25 14:15:23Z nevcairiel $
local ACEGUI_MAJOR, ACEGUI_MINOR = "AceGUI-3.0", 34
local AceGUI, oldminor = LibStub:NewLibrary(ACEGUI_MAJOR, ACEGUI_MINOR)

if not AceGUI then return end -- No upgrade needed

local AceCore = LibStub("AceCore-3.0")
local hooksecurefunc = AceCore.hooksecurefunc
local safecall = AceCore.safecall

-- Lua APIs
local tconcat, tremove, tinsert, tgetn, tsetn = table.concat, table.remove, table.insert, table.getn, table.setn
local pairs, next, type = pairs, next, type
local error, assert, loadstring = error, assert, loadstring
local setmetatable, rawget, rawset = setmetatable, rawget, rawset
local math_max = math.max
local strupper, strfmt = string.upper, string.format

-- WoW APIs
local UIParent = UIParent

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: geterrorhandler, LibStub

--local con = LibStub("AceConsole-3.0",true)

AceGUI.WidgetRegistry = AceGUI.WidgetRegistry or {}
AceGUI.LayoutRegistry = AceGUI.LayoutRegistry or {}
AceGUI.WidgetBase = AceGUI.WidgetBase or {}
AceGUI.WidgetContainerBase = AceGUI.WidgetContainerBase or {}
AceGUI.WidgetVersions = AceGUI.WidgetVersions or {}
AceGUI.HookedFunctions = AceGUI.HookedFunctions or {}

-- local upvalues
local WidgetRegistry = AceGUI.WidgetRegistry
local LayoutRegistry = AceGUI.LayoutRegistry
local WidgetVersions = AceGUI.WidgetVersions
local HookedFunctions = AceGUI.HookedFunctions

-- Recycling functions
local newWidget, delWidget
do
	AceGUI.objPools = AceGUI.objPools or {}
	local objPools = AceGUI.objPools
	--Returns a new instance, if none are available either returns a new table or calls the given contructor
	function newWidget(type)
		if not WidgetRegistry[type] then
			error("Attempt to instantiate unknown widget type", 2)
		end

		if not objPools[type] then
			objPools[type] = {}
		end

		local newObj = next(objPools[type])
		if not newObj then
			newObj = WidgetRegistry[type]()
			newObj.AceGUIWidgetVersion = WidgetVersions[type]
		else
			objPools[type][newObj] = nil
			-- if the widget is older then the latest, don't even try to reuse it
			-- just forget about it, and grab a new one.
			if not newObj.AceGUIWidgetVersion or newObj.AceGUIWidgetVersion < WidgetVersions[type] then
				return newWidget(type)
			end
		end
		return newObj
	end
	-- Releases an instance to the Pool
	function delWidget(obj,type)
		if not objPools[type] then
			objPools[type] = {}
		end
		if objPools[type][obj] then
			error("Attempt to Release Widget that is already released", 2)
		end
		objPools[type][obj] = true
	end
end

-- Ace3v: when a container contains many children, we can only use the variable arguments
local function _fixlevels(parent, ...)
	local lv = parent:GetFrameLevel() + 1
	for i = 1, tgetn(arg) do
		local child = arg[i]
		child:SetFrameLevel(lv)
		_fixlevels(child, child:GetChildren())
	end
end

local function fixlevels(parent)
	return _fixlevels(parent, parent:GetChildren())
end
AceGUI.fixlevels = fixlevels

-- Ace3v: attention! this function is recursive
local function _fixstrata(strata, parent, ...)
	parent:SetFrameStrata(strata)
	for i = 1, tgetn(arg) do
		local child = arg[i]
		_fixstrata(strata, child, child:GetChildren())
	end
end

local function fixstrata(strata, parent)
	return _fixstrata(strata, parent, parent:GetChildren())
end
AceGUI.fixstrata = fixstrata


-------------------
-- API Functions --
-------------------

-- Gets a widget Object

--- Create a new Widget of the given type.
-- This function will instantiate a new widget (or use one from the widget pool), and call the
-- OnAcquire function on it, before returning.
-- @param type The type of the widget.
-- @return The newly created widget.
function AceGUI:Create(type)
	if WidgetRegistry[type] then
		local widget = newWidget(type)

		if widget.OnAcquire then
			widget:OnAcquire()
		else
			error(strfmt("Widget type %s doesn't supply an OnAcquire Function", type))
		end

		-- Set the default Layout ("List")
		safecall(widget.SetLayout, 2, widget, "List")
		safecall(widget.ResumeLayout, 1, widget)
		return widget
	end
end

--- Releases a widget Object.
-- This function calls OnRelease on the widget and places it back in the widget pool.
-- Any data on the widget is being erased, and the widget will be hidden.\\
-- If this widget is a Container-Widget, all of its Child-Widgets will be releases as well.
-- @param widget The widget to release
function AceGUI:Release(widget)
	safecall(widget.PauseLayout, 1, widget)
	widget:Fire("OnRelease")
	safecall(widget.ReleaseChildren, 1, widget)

	if widget.OnRelease then
		widget:OnRelease()
--	else
--		error(strfmt("Widget type %s doesn't supply an OnRelease Function", widget.type))
	end
	for k in pairs(widget.userdata) do
		widget.userdata[k] = nil
	end
	for k in pairs(widget.events) do
		widget.events[k] = nil
	end
	widget.width = nil
	widget.relWidth = nil
	widget.height = nil
	widget.relHeight = nil
	widget.noAutoHeight = nil
	widget.frame:ClearAllPoints()
	widget.frame:Hide()
	widget.frame:SetParent(UIParent)
	widget.frame.width = nil
	widget.frame.height = nil
	if widget.content then
		widget.content.width = nil
		widget.content.height = nil
	end
	delWidget(widget, widget.type)
end

-----------
-- Focus --
-----------


--- Called when a widget has taken focus.
-- e.g. Dropdowns opening, Editboxes gaining kb focus
-- @param widget The widget that should be focused
function AceGUI:SetFocus(widget)
	if self.FocusedWidget and self.FocusedWidget ~= widget then
		safecall(self.FocusedWidget.ClearFocus, 1, self.FocusedWidget)
	end
	self.FocusedWidget = widget
end


--- Called when something has happened that could cause widgets with focus to drop it
-- e.g. titlebar of a frame being clicked
function AceGUI:ClearFocus()
	if self.FocusedWidget then
		safecall(self.FocusedWidget.ClearFocus, 1, self.FocusedWidget)
		self.FocusedWidget = nil
	end
end

-------------
-- Widgets --
-------------
--[[
	Widgets must provide the following functions
		OnAcquire() - Called when the object is acquired, should set everything to a default hidden state

	And the following members
		frame - the frame or derivitive object that will be treated as the widget for size and anchoring purposes
		type - the type of the object, same as the name given to :RegisterWidget()

	Widgets contain a table called userdata, this is a safe place to store data associated with the wigdet
	It will be cleared automatically when a widget is released
	Placing values directly into a widget object should be avoided

	If the Widget can act as a container for other Widgets the following
		content - frame or derivitive that children will be anchored to

	The Widget can supply the following Optional Members
		:OnRelease() - Called when the object is Released, should remove any additional anchors and clear any data
		:OnWidthSet(width) - Called when the width of the widget is changed
		:OnHeightSet(height) - Called when the height of the widget is changed
			Widgets should not use the OnSizeChanged events of thier frame or content members, use these methods instead
			AceGUI already sets a handler to the event
		:LayoutFinished(width, height) - called after a layout has finished, the width and height will be the width and height of the
			area used for controls. These can be nil if the layout used the existing size to layout the controls.

]]

--------------------------
-- Widget Base Template --
--------------------------
do
	local WidgetBase = AceGUI.WidgetBase

	WidgetBase.SetParent = function(self, parent)
		local frame = self.frame
		frame:SetParent(nil)
		frame:SetParent(parent.content)
		self.parent = parent
		fixlevels(frame)
	end

	WidgetBase.SetCallback = function(self, name, func)
		if type(func) == "function" then
			self.events[name] = func
		end
	end

	WidgetBase.Fire = function(self,name,argc,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
		argc = argc or 0
		local func = self.events[name]
		if func then
			local success, ret = safecall(func,argc+3,self,name,argc,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
			if success then
				return ret
			end
		end
	end

	WidgetBase.SetWidth = function(self, width)
		self.frame:SetWidth(width)
		self.frame.width = width
		if self.OnWidthSet then
			self:OnWidthSet(width)
		end
	end

	WidgetBase.SetRelativeWidth = function(self, width)
		if width <= 0 or width > 1 then
			error(":SetRelativeWidth(width): Invalid relative width.", 2)
		end
		self.relWidth = width
		self.width = "relative"
	end

	WidgetBase.SetHeight = function(self, height)
		self.frame:SetHeight(height)
		self.frame.height = height
		if self.OnHeightSet then
			self:OnHeightSet(height)
		end
	end

	--[[ WidgetBase.SetRelativeHeight = function(self, height)
		if height <= 0 or height > 1 then
			error(":SetRelativeHeight(height): Invalid relative height.", 2)
		end
		self.relHeight = height
		self.height = "relative"
	end ]]

	WidgetBase.IsVisible = function(self)
		return self.frame:IsVisible()
	end

	WidgetBase.IsShown= function(self)
		return self.frame:IsShown()
	end

	WidgetBase.Release = function(self)
		AceGUI:Release(self)
	end

	WidgetBase.SetPoint = function(self,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
		return self.frame:SetPoint(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	end

	WidgetBase.ClearAllPoints = function(self)
		return self.frame:ClearAllPoints()
	end

	WidgetBase.GetNumPoints = function(self)
		return self.frame:GetNumPoints()
	end

	WidgetBase.GetPoint = function(self,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
		return self.frame:GetPoint(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	end

	WidgetBase.GetUserDataTable = function(self)
		return self.userdata
	end

	WidgetBase.SetUserData = function(self, key, value)
		self.userdata[key] = value
	end

	WidgetBase.GetUserData = function(self, key)
		return self.userdata[key]
	end

	WidgetBase.IsFullHeight = function(self)
		return self.height == "fill"
	end

	WidgetBase.SetFullHeight = function(self, isFull)
		if isFull then
			self.height = "fill"
		else
			self.height = nil
		end
	end

	WidgetBase.IsFullWidth = function(self)
		return self.width == "fill"
	end

	WidgetBase.SetFullWidth = function(self, isFull)
		if isFull then
			self.width = "fill"
		else
			self.width = nil
		end
	end

--	local function LayoutOnUpdate(this)
--		this:SetScript("OnUpdate",nil)
--		this.obj:PerformLayout()
--	end

	local WidgetContainerBase = AceGUI.WidgetContainerBase

	WidgetContainerBase.PauseLayout = function(self)
		self.LayoutPaused = true
	end

	WidgetContainerBase.ResumeLayout = function(self)
		self.LayoutPaused = nil
	end

	WidgetContainerBase.PerformLayout = function(self)
		if self.LayoutPaused then
			return
		end
		safecall(self.LayoutFunc, 2, self.content, self.children)
	end

	--call this function to layout, makes sure layed out objects get a frame to get sizes etc
	WidgetContainerBase.DoLayout = function(self)
		self:PerformLayout()
--		if not self.parent then
--			self.frame:SetScript("OnUpdate", LayoutOnUpdate)
--		end
	end

	WidgetContainerBase.AddChild = function(self, child, beforeWidget)
		if beforeWidget then
			local siblingIndex = 1
			for _, widget in pairs(self.children) do
				if widget == beforeWidget then
					break
				end
				siblingIndex = siblingIndex + 1
			end
			tinsert(self.children, siblingIndex, child)
		else
			tinsert(self.children, child)
		end
		child:SetParent(self)
		child.frame:Show()
		self:DoLayout()
	end

	do
	local args = {nil,nil,nil,nil,nil,nil,nil,nil,nil,nil}
	WidgetContainerBase.AddChildren = function(self,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
		args[1] = a1
		args[2] = a2
		args[3] = a3
		args[4] = a4
		args[5] = a5
		args[6] = a6
		args[7] = a7
		args[8] = a8
		args[9] = a9
		args[10] = a10
		for i = 1,10 do
			local child = args[i]
			arg[i] = nil

			if not child then break end
			tinsert(self.children, child)
			child:SetParent(self)
			child.frame:Show()
		end
		self:DoLayout()
	end
	end -- WidgetContainerBase.AddChildren

	WidgetContainerBase.ReleaseChildren = function(self)
		local children = self.children
		for i = 1,tgetn(children) do
			AceGUI:Release(tremove(children))
		end
	end

	WidgetContainerBase.SetParent = function(self, parent)
		WidgetBase.SetParent(self, parent)

		local lv = self.frame:GetFrameLevel()
		self.content:SetFrameLevel(lv+1)
		local children = self.children
		for i = 1,tgetn(children) do
			local child = children[i]
			child:SetParent(self)
		end
	end

	WidgetContainerBase.SetLayout = function(self, Layout)
		self.LayoutFunc = AceGUI:GetLayout(Layout)
	end

	WidgetContainerBase.SetAutoAdjustHeight = function(self, adjust)
		if adjust then
			self.noAutoHeight = nil
		else
			self.noAutoHeight = true
		end
	end

	local function FrameResize()
		local self = this.obj
		if this:GetWidth() and this:GetHeight() then
			if self.OnWidthSet then
				self:OnWidthSet(this:GetWidth())
			end
			if self.OnHeightSet then
				self:OnHeightSet(this:GetHeight())
			end
		end
	end

	local function ContentResize()
		if this:GetWidth() and this:GetHeight() then
			this.width = this:GetWidth()
			this.height = this:GetHeight()
			this.obj:DoLayout()
		end
	end

	setmetatable(WidgetContainerBase, {__index=WidgetBase})

	--One of these function should be called on each Widget Instance as part of its creation process

	--- Register a widget-class as a container for newly created widgets.
	-- @param widget The widget class
	function AceGUI:RegisterAsContainer(widget)
		widget.children = {}
		widget.userdata = {}
		widget.events = {}
		widget.base = WidgetContainerBase
		widget.content.obj = widget
		widget.frame.obj = widget
		widget.content:SetScript("OnSizeChanged", ContentResize)
		widget.frame:SetScript("OnSizeChanged", FrameResize)
		setmetatable(widget, {__index = WidgetContainerBase})
		widget:SetLayout("List")
		return widget
	end

	--- Register a widget-class as a widget.
	-- @param widget The widget class
	function AceGUI:RegisterAsWidget(widget)
		widget.userdata = {}
		widget.events = {}
		widget.base = WidgetBase
		widget.frame.obj = widget
		widget.frame:SetScript("OnSizeChanged", FrameResize)
		setmetatable(widget, {__index = WidgetBase})
		return widget
	end
end




------------------
-- Widget API   --
------------------

--- Registers a widget Constructor, this function returns a new instance of the Widget
-- @param Name The name of the widget
-- @param Constructor The widget constructor function
-- @param Version The version of the widget
function AceGUI:RegisterWidgetType(Name, Constructor, Version)
	assert(type(Constructor) == "function")
	assert(type(Version) == "number")

	local oldVersion = WidgetVersions[Name]
	if oldVersion and oldVersion >= Version then return end

	WidgetVersions[Name] = Version
	WidgetRegistry[Name] = Constructor
end

--- Registers a Layout Function
-- @param Name The name of the layout
-- @param LayoutFunc Reference to the layout function
function AceGUI:RegisterLayout(Name, LayoutFunc)
	assert(type(LayoutFunc) == "function")
	if type(Name) == "string" then
		Name = string.upper(Name)
	end
	LayoutRegistry[Name] = LayoutFunc
end

--- Get a Layout Function from the registry
-- @param Name The name of the layout
function AceGUI:GetLayout(Name)
	if type(Name) == "string" then
		Name = strupper(Name)
	end
	return LayoutRegistry[Name]
end

AceGUI.counts = AceGUI.counts or {}

--- A type-based counter to count the number of widgets created.
-- This is used by widgets that require a named frame, e.g. when a Blizzard
-- Template requires it.
-- @param type The widget type
function AceGUI:GetNextWidgetNum(type)
	if not self.counts[type] then
		self.counts[type] = 0
	end
	self.counts[type] = self.counts[type] + 1
	return self.counts[type]
end

--- Return the number of created widgets for this type.
-- In contrast to GetNextWidgetNum, the number is not incremented.
-- @param type The widget type
function AceGUI:GetWidgetCount(type)
	return self.counts[type] or 0
end

--- Return the version of the currently registered widget type.
-- @param type The widget type
function AceGUI:GetWidgetVersion(type)
	return WidgetVersions[type]
end

-------------
-- Layouts --
-------------

--[[
	A Layout is a func that takes 2 parameters
		content - the frame that widgets will be placed inside
		children - a table containing the widgets to layout
]]

-- Very simple Layout, Children are stacked on top of each other down the left side
AceGUI:RegisterLayout("List",
	function(content, children)
		local height = 0
		local width = content.width or content:GetWidth() or 0
		for i = 1, tgetn(children) do
			local child = children[i]

			local frame = child.frame
			frame:ClearAllPoints()
			frame:Show()
			if i == 1 then
				frame:SetPoint("TOPLEFT", content)
			else
				frame:SetPoint("TOPLEFT", children[i-1].frame, "BOTTOMLEFT")
			end

			if child.width == "fill" then
				child:SetWidth(width)
				frame:SetPoint("RIGHT", content)

				if child.DoLayout then
					child:DoLayout()
				end
			elseif child.width == "relative" then
				child:SetWidth(width * child.relWidth)

				if child.DoLayout then
					child:DoLayout()
				end
			end

			height = height + (frame.height or frame:GetHeight() or 0)
		end
		safecall(content.obj.LayoutFinished, 3, content.obj, nil, height)
	end)

-- A single control fills the whole content area
AceGUI:RegisterLayout("Fill",
	function(content, children)
		if children[1] then
			children[1]:SetWidth(content:GetWidth() or 0)
			children[1]:SetHeight(content:GetHeight() or 0)
			children[1].frame:SetAllPoints(content)
			children[1].frame:Show()
			safecall(content.obj.LayoutFinished, 3, content.obj, nil, children[1].frame:GetHeight())
		end
	end)

-- Ace3v: currently only a1 used
local layoutrecursionblock = nil
local function safelayoutcall(object, func, a1)
	layoutrecursionblock = true
	object[func](object, a1)
	layoutrecursionblock = nil
end

AceGUI:RegisterLayout("Flow",
	function(content, children)
		if layoutrecursionblock then return end
		--used height so far
		local height = 0
		--width used in the current row
		local usedwidth = 0
		--height of the current row
		local rowheight = 0
		local rowoffset = 0
		local lastrowoffset

		local width = content.width or content:GetWidth() or 0

		--control at the start of the row
		local rowstart
		local rowstartoffset
		local lastrowstart
		local isfullheight

		local frameoffset
		local lastframeoffset
		local oversize
		for i = 1, tgetn(children) do
			local child = children[i]
			oversize = nil
			local frame = child.frame
			local frameheight = frame.height or frame:GetHeight() or 0
			local framewidth = frame.width or frame:GetWidth() or 0
			lastframeoffset = frameoffset
			-- HACK: Why did we set a frameoffset of (frameheight / 2) ?
			-- That was moving all widgets half the widgets size down, is that intended?
			-- Actually, it seems to be neccessary for many cases, we'll leave it in for now.
			-- If widgets seem to anchor weirdly with this, provide a valid alignoffset for them.
			-- TODO: Investigate moar!
			frameoffset = child.alignoffset or (frameheight / 2)

			if child.width == "relative" then
				framewidth = width * child.relWidth
			end

			frame:Show()
			frame:ClearAllPoints()
			if i == 1 then
				-- anchor the first control to the top left
				frame:SetPoint("TOPLEFT", content)
				rowheight = frameheight
				rowoffset = frameoffset
				rowstart = frame
				rowstartoffset = frameoffset
				usedwidth = framewidth
				if usedwidth > width then
					oversize = true
				end
			else
				-- if there isn't available width for the control start a new row
				-- if a control is "fill" it will be on a row of its own full width
				if usedwidth == 0 or ((framewidth) + usedwidth > width) or child.width == "fill" then
					if isfullheight then
						-- a previous row has already filled the entire height, there's nothing we can usefully do anymore
						-- (maybe error/warn about this?)
						break
					end
					--anchor the previous row, we will now know its height and offset
					rowstart:SetPoint("TOPLEFT", content, "TOPLEFT", 0, -(height + (rowoffset - rowstartoffset) + 3))
					height = height + rowheight + 3
					--save this as the rowstart so we can anchor it after the row is complete and we have the max height and offset of controls in it
					rowstart = frame
					rowstartoffset = frameoffset
					rowheight = frameheight
					rowoffset = frameoffset
					usedwidth = framewidth
					if usedwidth > width then
						oversize = true
					end
				-- put the control on the current row, adding it to the width and checking if the height needs to be increased
				else
					--handles cases where the new height is higher than either control because of the offsets
					--math.max(rowheight-rowoffset+frameoffset, frameheight-frameoffset+rowoffset)

					--offset is always the larger of the two offsets
					rowoffset = math_max(rowoffset, frameoffset)
					rowheight = math_max(rowheight, rowoffset + (frameheight / 2))

					frame:SetPoint("TOPLEFT", children[i-1].frame, "TOPRIGHT", 0, frameoffset - lastframeoffset)
					usedwidth = framewidth + usedwidth
				end
			end

			if child.width == "fill" then
				safelayoutcall(child, "SetWidth", width)
				frame:SetPoint("RIGHT", content)

				usedwidth = 0
				rowstart = frame
				rowstartoffset = frameoffset

				if child.DoLayout then
					child:DoLayout()
				end
				rowheight = frame.height or frame:GetHeight() or 0
				rowoffset = child.alignoffset or (rowheight / 2)
				rowstartoffset = rowoffset
			elseif child.width == "relative" then
				safelayoutcall(child, "SetWidth", width * child.relWidth)

				if child.DoLayout then
					child:DoLayout()
				end
			elseif oversize then
				if width > 1 then
					frame:SetPoint("RIGHT", content)
				end
			end

			if child.height == "fill" then
				frame:SetPoint("BOTTOM", content)
				isfullheight = true
			end
		end

		--anchor the last row, if its full height needs a special case since  its height has just been changed by the anchor
		if isfullheight then
			rowstart:SetPoint("TOPLEFT", content, "TOPLEFT", 0, -height)
		elseif rowstart then
			rowstart:SetPoint("TOPLEFT", content, "TOPLEFT", 0, -(height + (rowoffset - rowstartoffset) + 3))
		end

		height = height + rowheight + 3
		safecall(content.obj.LayoutFinished, 3, content.obj, nil, height)
	end)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-ScrollFrame.lua
================
--[[-----------------------------------------------------------------------------
ScrollFrame Container
Plain container that scrolls its content and doesn't grow in height.
-------------------------------------------------------------------------------]]
local Type, Version = "ScrollFrame", 24
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local fixlevels = AceGUI.fixlevels

-- Lua APIs
local pairs, assert, type = pairs, assert, type
local min, max, floor, abs = math.min, math.max, math.floor, math.abs
local format = string.format

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function FixScrollOnUpdate()
	this:SetScript("OnUpdate", nil)
	this.obj:FixScroll()
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function ScrollFrame_OnMouseWheel()
	this.obj:MoveScroll(arg1)
end

local function ScrollFrame_OnSizeChanged()
	this:SetScript("OnUpdate", FixScrollOnUpdate)
end

local function ScrollBar_OnScrollValueChanged()
	this.obj:SetScroll(arg1)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetScroll(0)
		self.scrollframe:SetScript("OnUpdate", FixScrollOnUpdate)
	end,

	["OnRelease"] = function(self)
		self.status = nil
		for k in pairs(self.localstatus) do
			self.localstatus[k] = nil
		end
		self.scrollframe:SetPoint("BOTTOMRIGHT",0,0)
		self.scrollbar:Hide()
		self.scrollBarShown = nil
		self.content.height, self.content.width = nil, nil
	end,

	["SetScroll"] = function(self, value)
		local status = self.status or self.localstatus
		local viewheight = self.scrollframe:GetHeight()
		local height = self.content:GetHeight()
		local offset

		if viewheight > height then
			offset = 0
		else
			offset = floor((height - viewheight) / 1000.0 * value)
		end
		self.content:ClearAllPoints()
		self.content:SetPoint("TOPLEFT", 0, offset)
		self.content:SetPoint("TOPRIGHT", 0, offset)
		status.offset = offset
		status.scrollvalue = value
	end,

	["MoveScroll"] = function(self, value)
		local status = self.status or self.localstatus
		local height, viewheight = self.scrollframe:GetHeight(), self.content:GetHeight()

		if self.scrollBarShown then
			local diff = height - viewheight
			local delta = 1
			if value < 0 then
				delta = -1
			end
			self.scrollbar:SetValue(min(max(status.scrollvalue + delta*(1000/(diff/45)),0), 1000))
		end
	end,

	["FixScroll"] = function(self)

		if self.updateLock then return end
		self.updateLock = true
		local status = self.status or self.localstatus
		local scrollframe, content, scrollbar = self.scrollframe, self.content, self.scrollbar
		local viewheight, height  = self.scrollframe:GetHeight(), self.content:GetHeight()
		local offset = status.offset or 0
		local curvalue = scrollbar:GetValue()
		-- Give us a margin of error of 2 pixels to stop some conditions that i would blame on floating point inaccuracys
		-- No-one is going to miss 2 pixels at the bottom of the frame, anyhow!

		if height < viewheight + 2 then
			if self.scrollBarShown then
				self.scrollBarShown = nil
				scrollbar:Hide()
				scrollbar:SetValue(0)
				scrollframe:SetPoint("BOTTOMRIGHT",0,0)
				self:DoLayout()
			end
			offset = 0
		else
			if not self.scrollBarShown then
				self.scrollBarShown = true
				scrollbar:Show()
				scrollframe:SetPoint("BOTTOMRIGHT", -20, 0)
				self:DoLayout()
			end
			local value = (offset / (height - viewheight) * 1000)
			if value > 1000 then
				value = 1000
				offset = height - viewheight
			end
			scrollbar:SetValue(value)
			self:SetScroll(value)
		end
		status.offset = offset
		scrollframe:SetScrollChild(content)
		content:ClearAllPoints()
		content:SetPoint("TOPLEFT", 0, offset)
		content:SetPoint("TOPRIGHT", 0, offset)
		self.updateLock = nil
	end,

	["LayoutFinished"] = function(self, width, height)
		self.content:SetHeight(height or 0 + 20)
		self.scrollframe:SetScript("OnUpdate", FixScrollOnUpdate)
	end,

	["SetStatusTable"] = function(self, status)
		assert(type(status) == "table")
		self.status = status
		if not status.scrollvalue then
			status.scrollvalue = 0
		end
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		content.width = width
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		content.height = height
	end
}
--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	local num = AceGUI:GetNextWidgetNum(Type)

	local scrollframe = CreateFrame("ScrollFrame", nil, frame)
	scrollframe:SetPoint("TOPLEFT",0,0)
	scrollframe:SetPoint("BOTTOMRIGHT",0,0)
	scrollframe:EnableMouseWheel(true)
	scrollframe:SetScript("OnMouseWheel", ScrollFrame_OnMouseWheel)
	scrollframe:SetScript("OnSizeChanged", ScrollFrame_OnSizeChanged)

	local scrollbar = CreateFrame("Slider", format("AceConfigDialogScrollFrame%dScrollBar", num), scrollframe, "UIPanelScrollBarTemplate")
	scrollbar:SetPoint("TOPLEFT", scrollframe, "TOPRIGHT", 4, -16)
	scrollbar:SetPoint("BOTTOMLEFT", scrollframe, "BOTTOMRIGHT", 4, 16)
	scrollbar:SetMinMaxValues(0, 1000)
	scrollbar:SetValueStep(1)
	scrollbar:SetValue(0)
	scrollbar:SetWidth(16)
	scrollbar:Hide()
	-- set the script as the last step, so it doesn't fire yet
	scrollbar:SetScript("OnValueChanged", ScrollBar_OnScrollValueChanged)

	local scrollbg = scrollbar:CreateTexture(nil, "BACKGROUND")
	scrollbg:SetAllPoints(scrollbar)
	scrollbg:SetTexture(0, 0, 0, 0.4)

	--Container Support
	local content = CreateFrame("Frame", nil, scrollframe)
	content:SetPoint("TOPLEFT",0,0)
	content:SetPoint("TOPRIGHT",0,0)
	content:SetHeight(400)
	scrollframe:SetScrollChild(content)

	local widget = {
		localstatus = { scrollvalue = 0 },
		scrollframe = scrollframe,
		scrollbar   = scrollbar,
		content     = content,
		frame       = frame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	scrollframe.obj, scrollbar.obj = widget, widget

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-TreeGroup.lua
================
--[[-----------------------------------------------------------------------------
TreeGroup Container
Container that uses a tree control to switch between groups.
-------------------------------------------------------------------------------]]
local Type, Version = "TreeGroup", 41
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local AceCore = LibStub("AceCore-3.0")
local strsplit = AceCore.strsplit
local _G = AceCore._G

-- Lua APIs
local next, pairs, ipairs, assert, type = next, pairs, ipairs, assert, type
local math_min, math_max, floor = math.min, math.max, floor
local tgetn, tremove, unpack, tconcat = table.getn, table.remove, unpack, table.concat
local strfmt = string.format

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: GameTooltip, FONT_COLOR_CODE_CLOSE

-- Recycling functions
local new, del
do
	local pool = setmetatable({},{__mode='k'})
	function new()
		local t = next(pool)
		if t then
			pool[t] = nil
			return t
		else
			return {}
		end
	end
	function del(t)
		for k in pairs(t) do
			t[k] = nil
		end
		pool[t] = true
	end
end

local DEFAULT_TREE_WIDTH = 175
local DEFAULT_TREE_SIZABLE = true

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function GetButtonUniqueValue(line)
	local parent = line.parent
	if parent and parent.value then
		return GetButtonUniqueValue(parent).."\001"..line.value
	else
		return line.value
	end
end

local function UpdateButton(button, treeline, selected, canExpand, isExpanded)
	local self = button.obj
	local toggle = button.toggle
	local frame = self.frame
	local text = treeline.text or ""
	local icon = treeline.icon
	local iconCoords = treeline.iconCoords
	local level = treeline.level
	local value = treeline.value
	local uniquevalue = treeline.uniquevalue
	local disabled = treeline.disabled

	button.treeline = treeline
	button.value = value
	button.uniquevalue = uniquevalue
	if selected then
		button:LockHighlight()
		button.selected = true
	else
		button:UnlockHighlight()
		button.selected = false
	end
	local normalTexture = button:GetNormalTexture()
	local line = button.line
	button.level = level

	if ( level == 1 ) then
		button.text:SetFontObject("GameFontNormal")
		button:SetHighlightFontObject("GameFontHighlight")
		button.text:SetPoint("LEFT", (icon and 16 or 0) + 8, 2)
	else
		button.text:SetFontObject("GameFontHighlightSmall")
		button:SetHighlightFontObject("GameFontHighlightSmall")
		button.text:SetPoint("LEFT", (icon and 16 or 0) + 8 * level, 2)
	end

	if disabled then
		button:EnableMouse(false)
		button.text:SetText("|cff808080"..text..FONT_COLOR_CODE_CLOSE)
	else
		button.text:SetText(text)
		button:EnableMouse(true)
	end

	if icon then
		button.icon:SetTexture(icon)
		button.icon:SetPoint("LEFT", 8 * level, (level == 1) and 0 or 1)
	else
		button.icon:SetTexture(nil)
	end

	if iconCoords then
		button.icon:SetTexCoord(unpack(iconCoords))
	else
		button.icon:SetTexCoord(0, 1, 0, 1)
	end

	if canExpand then
		if not isExpanded then
			toggle:SetNormalTexture("Interface\\Buttons\\UI-PlusButton-UP")
			toggle:SetPushedTexture("Interface\\Buttons\\UI-PlusButton-DOWN")
		else
			toggle:SetNormalTexture("Interface\\Buttons\\UI-MinusButton-UP")
			toggle:SetPushedTexture("Interface\\Buttons\\UI-MinusButton-DOWN")
		end
		toggle:Show()
	else
		toggle:Hide()
	end
end

local function ShouldDisplayLevel(tree)
	local result = false
	for k, v in ipairs(tree) do
		if v.children == nil and v.visible ~= false then
			result = true
		elseif v.children then
			result = result or ShouldDisplayLevel(v.children)
		end
		if result then return result end
	end
	return false
end

local function addLine(self, v, tree, level, parent)
	local line = new()
	line.value = v.value
	line.text = v.text
	line.icon = v.icon
	line.iconCoords = v.iconCoords
	line.disabled = v.disabled
	line.tree = tree
	line.level = level
	line.parent = parent
	line.visible = v.visible
	line.uniquevalue = GetButtonUniqueValue(line)
	if v.children then
		line.hasChildren = true
	else
		line.hasChildren = nil
	end
	tinsert(self.lines, line)
	return line
end

--fire an update after one frame to catch the treeframes height
local function FirstFrameUpdate()
	local self = this.obj
	this:SetScript("OnUpdate", nil)
	self:RefreshTree()
end

local BuildUniqueValue
do
local args = {nil,nil,nil,nil,nil,nil,nil,nil,nil,nil}
function BuildUniqueValue(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	args[1] = a1
	args[2] = a2
	args[3] = a3
	args[4] = a4
	args[5] = a5
	args[6] = a6
	args[7] = a7
	args[8] = a8
	args[9] = a9
	args[10] = a10
	return tconcat(args, "\001", 1, tgetn(args))
end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Expand_OnClick()
	local button = this.button
	local self = button.obj
	local status = (self.status or self.localstatus).groups
	status[button.uniquevalue] = not status[button.uniquevalue]
	self:RefreshTree()
end

local function Button_OnClick()
	local self = this.obj
	self:Fire("OnClick", 2, this.uniquevalue, this.selected)
	if not this.selected then
		self:SetSelected(this.uniquevalue)
		this.selected = true
		this:LockHighlight()
		self:RefreshTree()
	end
	AceGUI:ClearFocus()
end

local function Button_OnDoubleClick()
	local self = this.obj
	local status = self.status or self.localstatus
	local status = (self.status or self.localstatus).groups
	status[this.uniquevalue] = not status[this.uniquevalue]
	self:RefreshTree()
end

local function Button_OnEnter()
	local self = this.obj
	self:Fire("OnButtonEnter", 2, this.uniquevalue, this)

	if self.enabletooltips then
		GameTooltip:SetOwner(this, "ANCHOR_NONE")
		GameTooltip:SetPoint("LEFT",this,"RIGHT")
		GameTooltip:SetText(this.text:GetText() or "", 1, .82, 0, true)

		GameTooltip:Show()
	end
end

local function Button_OnLeave()
	local self = this.obj
	self:Fire("OnButtonLeave", 2, this.uniquevalue, this)

	if self.enabletooltips then
		GameTooltip:Hide()
	end
end

local function OnScrollValueChanged()
	if this.obj.noupdate then return end
	local self = this.obj
	local status = self.status or self.localstatus
	status.scrollvalue = floor(arg1 + 0.5)
	self:RefreshTree()
	AceGUI:ClearFocus()
end

local function Tree_OnSizeChanged()
	this.obj:RefreshTree()
end

local function Tree_OnMouseWheel()
	local self = this.obj
	if self.showscroll then
		local scrollbar = self.scrollbar
		local min, max = scrollbar:GetMinMaxValues()
		local value = scrollbar:GetValue()
		local newvalue = math_min(max,math_max(min,value - arg1))
		if value ~= newvalue then
			scrollbar:SetValue(newvalue)
		end
	end
end

local function Dragger_OnLeave()
	this:SetBackdropColor(1, 1, 1, 0)
end

local function Dragger_OnEnter()
	this:SetBackdropColor(1, 1, 1, 0.8)
end

local function Dragger_OnMouseDown()
	local treeframe = this:GetParent()
	treeframe:StartSizing("RIGHT")
end

local function Dragger_OnMouseUp()
	local treeframe = this:GetParent()
	local self = treeframe.obj
	local this = treeframe:GetParent()
	treeframe:StopMovingOrSizing()
	--treeframe:SetScript("OnUpdate", nil)
	treeframe:SetUserPlaced(false)
	--Without this :GetHeight will get stuck on the current height, causing the tree contents to not resize
	treeframe:SetHeight(0)
	treeframe:SetPoint("TOPLEFT", this, "TOPLEFT",0,0)
	treeframe:SetPoint("BOTTOMLEFT", this, "BOTTOMLEFT",0,0)

	local status = self.status or self.localstatus
	status.treewidth = treeframe:GetWidth()

	treeframe.obj:Fire("OnTreeResize", 1, treeframe:GetWidth())
	-- recalculate the content width
	treeframe.obj:OnWidthSet(status.fullwidth)
	-- update the layout of the content
	treeframe.obj:DoLayout()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods
do
local select_args = {nil,nil,nil,nil,nil,nil,nil,nil,nil,nil}
methods = {
	["OnAcquire"] = function(self)
		self:SetTreeWidth(DEFAULT_TREE_WIDTH, DEFAULT_TREE_SIZABLE)
		self:EnableButtonTooltips(true)
		self.frame:SetScript("OnUpdate", FirstFrameUpdate)
	end,

	["OnRelease"] = function(self)
		self.status = nil
		for k, v in pairs(self.localstatus) do
			if k == "groups" then
				for k2 in pairs(v) do
					v[k2] = nil
				end
			else
				self.localstatus[k] = nil
			end
		end
		self.localstatus.scrollvalue = 0
		self.localstatus.treewidth = DEFAULT_TREE_WIDTH
		self.localstatus.treesizable = DEFAULT_TREE_SIZABLE
	end,

	["EnableButtonTooltips"] = function(self, enable)
		self.enabletooltips = enable
	end,

	["CreateButton"] = function(self)
		local num = AceGUI:GetNextWidgetNum("TreeGroupButton")

		local button = CreateFrame("Button", strfmt("AceGUI30TreeButton%d", num), self.treeframe)
		button.obj = self
		button:SetWidth(175)
		button:SetHeight(18)

		local toggle = CreateFrame("Button", nil, button)
		toggle.obj = button
		button.toggle = toggle
		toggle:SetWidth(14)
		toggle:SetHeight(14)
		toggle:ClearAllPoints()
		toggle:SetPoint("TOPRIGHT", button, "TOPRIGHT", -6, -1)
		toggle:SetScript("OnClick", Button_OnClick)
		toggle:SetNormalTexture("Interface\\Buttons\\UI-MinusButton-UP")
		toggle:SetPushedTexture("Interface\\Buttons\\UI-MinusButton-DOWN")
		toggle:SetHighlightTexture("Interface\\Buttons\\UI-PlusButton-Hilight", "ADD")

		local text = button:CreateFontString()
		button.text = text
		text:SetFontObject(GameFontNormal)
		button:SetHighlightFontObject(GameFontHighlight)
		text:SetPoint("RIGHT", toggle, "LEFT", -2, 0);
		text:SetJustifyH("LEFT")

		local highlight = button:CreateTexture(nil, "HIGHLIGHT");
		button.highlight = highlight
		highlight:SetTexture("Interface\\QuestFrame\\UI-QuestLogTitleHighlight")
		highlight:SetBlendMode("ADD")
		highlight:SetVertexColor(.196, .388, .8);
		highlight:ClearAllPoints()
		highlight:SetPoint("TOPLEFT",0,1)
		highlight:SetPoint("BOTTOMRIGHT",0,1)

		local icon = button:CreateTexture(nil, "OVERLAY")
		icon:SetWidth(14)
		icon:SetHeight(14)
		button.icon = icon

		button:SetScript("OnClick",Button_OnClick)
		button:SetScript("OnDoubleClick", Button_OnDoubleClick)
		button:SetScript("OnEnter",Button_OnEnter)
		button:SetScript("OnLeave",Button_OnLeave)

		button.toggle.button = button
		button.toggle:SetScript("OnClick",Expand_OnClick)

		button.text:SetHeight(14) -- Prevents text wrapping

		return button
	end,

	["SetStatusTable"] = function(self, status)
		assert(type(status) == "table")
		self.status = status
		if not status.groups then
			status.groups = {}
		end
		if not status.scrollvalue then
			status.scrollvalue = 0
		end
		if not status.treewidth then
			status.treewidth = DEFAULT_TREE_WIDTH
		end
		if status.treesizable == nil then
			status.treesizable = DEFAULT_TREE_SIZABLE
		end
		self:SetTreeWidth(status.treewidth,status.treesizable)
		self:RefreshTree()
	end,

	--sets the tree to be displayed
	["SetTree"] = function(self, tree, filter)
		self.filter = filter
		if tree then
			assert(type(tree) == "table")
		end
		self.tree = tree
		self:RefreshTree()
	end,

	["BuildLevel"] = function(self, tree, level, parent)
		local groups = (self.status or self.localstatus).groups
		local hasChildren = self.hasChildren

		for i, v in ipairs(tree) do
			if v.children then
				if not self.filter or ShouldDisplayLevel(v.children) then
					local line = addLine(self, v, tree, level, parent)
					if groups[line.uniquevalue] then
						self:BuildLevel(v.children, level+1, line)
					end
				end
			elseif v.visible ~= false or not self.filter then
				addLine(self, v, tree, level, parent)
			end
		end
	end,

	["RefreshTree"] = function(self,scrollToSelection)
		local buttons = self.buttons
		local lines = self.lines

		for i, v in ipairs(buttons) do
			v:Hide()
		end
		while lines[1] do
			local t = tremove(lines)
			for k in pairs(t) do
				t[k] = nil
			end
			del(t)
		end

		if not self.tree then return end
		--Build the list of visible entries from the tree and status tables
		local status = self.status or self.localstatus
		local groupstatus = status.groups
		local tree = self.tree

		local treeframe = self.treeframe

		status.scrollToSelection = status.scrollToSelection or scrollToSelection	-- needs to be cached in case the control hasn't been drawn yet (code bails out below)

		self:BuildLevel(tree, 1)

		local numlines = tgetn(lines)

		local maxlines = (floor(((self.treeframe:GetHeight()or 0) - 20 ) / 18))
		if maxlines <= 0 then return end

		local first, last

		scrollToSelection = status.scrollToSelection
		status.scrollToSelection = nil

		if numlines <= maxlines then
			--the whole tree fits in the frame
			status.scrollvalue = 0
			self:ShowScroll(false)
			first, last = 1, numlines
		else
			self:ShowScroll(true)
			--scrolling will be needed
			self.noupdate = true
			self.scrollbar:SetMinMaxValues(0, numlines - maxlines)
			--check if we are scrolled down too far
			if numlines - status.scrollvalue < maxlines then
				status.scrollvalue = numlines - maxlines
			end
			self.noupdate = nil
			first, last = status.scrollvalue+1, status.scrollvalue + maxlines
			--show selection?
			if scrollToSelection and status.selected then
				local show
				for i,line in ipairs(lines) do	-- find the line number
					if line.uniquevalue==status.selected then
						show=i
					end
				end
				if not show then
					-- selection was deleted or something?
				elseif show>=first and show<=last then
					-- all good
				else
					-- scrolling needed!
					if show<first then
						status.scrollvalue = show-1
					else
						status.scrollvalue = show-maxlines
					end
					first, last = status.scrollvalue+1, status.scrollvalue + maxlines
				end
			end
			if self.scrollbar:GetValue() ~= status.scrollvalue then
				self.scrollbar:SetValue(status.scrollvalue)
			end
		end

		local buttonnum = 1
		for i = first, last do
			local line = lines[i]
			local button = buttons[buttonnum]
			if not button then
				button = self:CreateButton()

				buttons[buttonnum] = button
				button:SetParent(treeframe)
				button:SetFrameLevel(treeframe:GetFrameLevel()+1)
				button:ClearAllPoints()
				if buttonnum == 1 then
					if self.showscroll then
						button:SetPoint("TOPRIGHT", -22, -10)
						button:SetPoint("TOPLEFT", 0, -10)
					else
						button:SetPoint("TOPRIGHT", 0, -10)
						button:SetPoint("TOPLEFT", 0, -10)
					end
				else
					button:SetPoint("TOPRIGHT", buttons[buttonnum-1], "BOTTOMRIGHT",0,0)
					button:SetPoint("TOPLEFT", buttons[buttonnum-1], "BOTTOMLEFT",0,0)
				end
			end

			UpdateButton(button, line, status.selected == line.uniquevalue, line.hasChildren, groupstatus[line.uniquevalue] )
			button:Show()
			buttonnum = buttonnum + 1
		end

	end,

	["SetSelected"] = function(self, value)
		local status = self.status or self.localstatus
		if status.selected ~= value then
			status.selected = value
			self:Fire("OnGroupSelected", 1, value)
		end
	end,

	["Select"] = function(self, uniquevalue, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
		self.filter = false
		local status = self.status or self.localstatus
		local groups = status.groups
		select_args[1] = a1
		select_args[2] = a2
		select_args[3] = a3
		select_args[4] = a4
		select_args[5] = a5
		select_args[6] = a6
		select_args[7] = a7
		select_args[8] = a8
		select_args[9] = a9
		select_args[10] = a10
		for i = 1, tgetn(select_args) do
			groups[tconcat(select_args, "\001", 1, i)] = true
		end
		status.selected = uniquevalue
		self:RefreshTree(true)
		self:Fire("OnGroupSelected", 1, uniquevalue)
	end,

	["SelectByPath"] = function(self, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
		self:Select(BuildUniqueValue(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10), a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
	end,

	["SelectByValue"] = function(self, uniquevalue)
		self:Select(uniquevalue, strsplit("\001", uniquevalue))
	end,

	["ShowScroll"] = function(self, show)
		self.showscroll = show
		if show then
			self.scrollbar:Show()
			if self.buttons[1] then
				self.buttons[1]:SetPoint("TOPRIGHT", self.treeframe,"TOPRIGHT",-22,-10)
			end
		else
			self.scrollbar:Hide()
			if self.buttons[1] then
				self.buttons[1]:SetPoint("TOPRIGHT", self.treeframe,"TOPRIGHT",0,-10)
			end
		end
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local treeframe = self.treeframe
		local status = self.status or self.localstatus
		status.fullwidth = width

		local contentwidth = width - status.treewidth - 20
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth

		local maxtreewidth = math_min(400, width - 50)

		if maxtreewidth > 100 and status.treewidth > maxtreewidth then
			self:SetTreeWidth(maxtreewidth, status.treesizable)
		end
		treeframe:SetMaxResize(maxtreewidth, 1600)
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - 20
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end,

	["SetTreeWidth"] = function(self, treewidth, resizable)
		if not resizable then
			if type(treewidth) == 'number' then
				resizable = false
			elseif type(treewidth) == 'boolean' then
				resizable = treewidth
				treewidth = DEFAULT_TREE_WIDTH
			else
				resizable = false
				treewidth = DEFAULT_TREE_WIDTH
			end
		end
		self.treeframe:SetWidth(treewidth)
		self.dragger:EnableMouse(resizable)

		local status = self.status or self.localstatus
		status.treewidth = treewidth
		status.treesizable = resizable

		-- recalculate the content width
		if status.fullwidth then
			self:OnWidthSet(status.fullwidth)
		end
	end,

	["GetTreeWidth"] = function(self)
		local status = self.status or self.localstatus
		return status.treewidth or DEFAULT_TREE_WIDTH
	end,

	["LayoutFinished"] = function(self, width, height)
		if self.noAutoHeight then return end
		self:SetHeight((height or 0) + 20)
	end
}
end -- method

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local PaneBackdrop  = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 5, bottom = 3 }
}

local DraggerBackdrop  = {
	bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
	edgeFile = nil,
	tile = true, tileSize = 16, edgeSize = 0,
	insets = { left = 3, right = 3, top = 7, bottom = 7 }
}

local function Constructor()
	local num = AceGUI:GetNextWidgetNum(Type)
	local frame = CreateFrame("Frame", nil, UIParent)

	local treeframe = CreateFrame("Frame", nil, frame)
	treeframe:SetPoint("TOPLEFT", 0, 0)
	treeframe:SetPoint("BOTTOMLEFT", 0, 0)
	treeframe:SetWidth(DEFAULT_TREE_WIDTH)
	treeframe:EnableMouseWheel(true)
	treeframe:SetBackdrop(PaneBackdrop)
	treeframe:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
	treeframe:SetBackdropBorderColor(0.4, 0.4, 0.4)
	treeframe:SetResizable(true)
	treeframe:SetMinResize(100, 1)
	treeframe:SetMaxResize(400, 1600)
	treeframe:SetScript("OnUpdate", FirstFrameUpdate)
	treeframe:SetScript("OnSizeChanged", Tree_OnSizeChanged)
	treeframe:SetScript("OnMouseWheel", Tree_OnMouseWheel)

	local dragger = CreateFrame("Frame", nil, treeframe)
	dragger:SetWidth(8)
	dragger:SetPoint("TOP", treeframe, "TOPRIGHT")
	dragger:SetPoint("BOTTOM", treeframe, "BOTTOMRIGHT")
	dragger:SetBackdrop(DraggerBackdrop)
	dragger:SetBackdropColor(1, 1, 1, 0)
	dragger:SetScript("OnEnter", Dragger_OnEnter)
	dragger:SetScript("OnLeave", Dragger_OnLeave)
	dragger:SetScript("OnMouseDown", Dragger_OnMouseDown)
	dragger:SetScript("OnMouseUp", Dragger_OnMouseUp)

	local scrollbar = CreateFrame("Slider", strfmt("AceConfigDialogTreeGroup%dScrollBar", num), treeframe, "UIPanelScrollBarTemplate")
	scrollbar:SetScript("OnValueChanged", nil)
	scrollbar:SetPoint("TOPRIGHT", -10, -26)
	scrollbar:SetPoint("BOTTOMRIGHT", -10, 26)
	scrollbar:SetMinMaxValues(0,0)
	scrollbar:SetValueStep(1)
	scrollbar:SetValue(0)
	scrollbar:SetWidth(16)
	scrollbar:SetScript("OnValueChanged", OnScrollValueChanged)

	local scrollbg = scrollbar:CreateTexture(nil, "BACKGROUND")
	scrollbg:SetAllPoints(scrollbar)
	scrollbg:SetTexture(0,0,0,0.4)

	local border = CreateFrame("Frame",nil,frame)
	border:SetPoint("TOPLEFT", treeframe, "TOPRIGHT")
	border:SetPoint("BOTTOMRIGHT", 0, 0)
	border:SetBackdrop(PaneBackdrop)
	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
	border:SetBackdropBorderColor(0.4, 0.4, 0.4)

	--Container Support
	local content = CreateFrame("Frame", nil, border)
	content:SetPoint("TOPLEFT", 10, -10)
	content:SetPoint("BOTTOMRIGHT", -10, 10)

	local widget = {
		frame        = frame,
		lines        = {},
		levels       = {},
		buttons      = {},
		hasChildren  = {},
		localstatus  = { groups = {}, scrollvalue = 0 },
		filter       = false,
		treeframe    = treeframe,
		dragger      = dragger,
		scrollbar    = scrollbar,
		border       = border,
		content      = content,
		type         = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	treeframe.obj, dragger.obj, scrollbar.obj = widget, widget, widget

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

================
File: Libs/vanilla/Ace3/AceGUI-3.0/widgets/AceGUIContainer-Window.lua
================
local AceGUI = LibStub("AceGUI-3.0")

-- Lua APIs
local pairs, assert, type = pairs, assert, type

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame, UIParent = CreateFrame, UIParent

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: GameFontNormal

----------------
-- Main Frame --
----------------
--[[
	Events :
		OnClose

]]
do
	local Type = "Window"
	local Version = 4

	local function frameOnClose()
		this.obj:Fire("OnClose")
	end
	
	local function closeOnClick()
		PlaySound("gsTitleOptionExit")
		this.obj:Hide()
	end
	
	local function frameOnMouseDown()
		AceGUI:ClearFocus()
	end
	
	local function titleOnMouseDown()
		this:GetParent():StartMoving()
		AceGUI:ClearFocus()
	end
	
	local function frameOnMouseUp()
		local frame = this:GetParent()
		frame:StopMovingOrSizing()
		local self = frame.obj
		local status = self.status or self.localstatus
		status.width = frame:GetWidth()
		status.height = frame:GetHeight()
		status.top = frame:GetTop()
		status.left = frame:GetLeft()
	end
	
	local function sizerseOnMouseDown()
		this:GetParent():StartSizing("BOTTOMRIGHT")
		AceGUI:ClearFocus()
	end
	
	local function sizersOnMouseDown()
		this:GetParent():StartSizing("BOTTOM")
		AceGUI:ClearFocus()
	end
	
	local function sizereOnMouseDown()
		this:GetParent():StartSizing("RIGHT")
		AceGUI:ClearFocus()
	end
	
	local function sizerOnMouseUp()
		this:GetParent():StopMovingOrSizing()
	end

	local function SetTitle(self,title)
		self.titletext:SetText(title)
	end
	
	local function SetStatusText(self,text)
		-- self.statustext:SetText(text)
	end
	
	local function Hide(self)
		self.frame:Hide()
	end
	
	local function Show(self)
		self.frame:Show()
	end
	
	local function OnAcquire(self)
		self.frame:SetParent(UIParent)
		self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
		self:ApplyStatus()
		self:EnableResize(true)
		self:Show()
	end
	
	local function OnRelease(self)
		self.status = nil
		for k in pairs(self.localstatus) do
			self.localstatus[k] = nil
		end
	end
	
	-- called to set an external table to store status in
	local function SetStatusTable(self, status)
		assert(type(status) == "table")
		self.status = status
		self:ApplyStatus()
	end
	
	local function ApplyStatus(self)
		local status = self.status or self.localstatus
		local frame = self.frame
		self:SetWidth(status.width or 700)
		self:SetHeight(status.height or 500)
		if status.top and status.left then
			frame:SetPoint("TOP",UIParent,"BOTTOM",0,status.top)
			frame:SetPoint("LEFT",UIParent,"LEFT",status.left,0)
		else
			frame:SetPoint("CENTER",UIParent,"CENTER")
		end
	end
	
	local function OnWidthSet(self, width)
		local content = self.content
		local contentwidth = width - 34
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth
	end
	
	
	local function OnHeightSet(self, height)
		local content = self.content
		local contentheight = height - 57
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end
	
	local function EnableResize(self, state)
		local func = state and "Show" or "Hide"
		self.sizer_se[func](self.sizer_se)
		self.sizer_s[func](self.sizer_s)
		self.sizer_e[func](self.sizer_e)
	end
	
	local function Constructor()
		local frame = CreateFrame("Frame",nil,UIParent)
		local self = {}
		self.type = "Window"
		
		self.Hide = Hide
		self.Show = Show
		self.SetTitle =  SetTitle
		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.SetStatusText = SetStatusText
		self.SetStatusTable = SetStatusTable
		self.ApplyStatus = ApplyStatus
		self.OnWidthSet = OnWidthSet
		self.OnHeightSet = OnHeightSet
		self.EnableResize = EnableResize
		
		self.localstatus = {}
		
		self.frame = frame
		frame.obj = self
		frame:SetWidth(700)
		frame:SetHeight(500)
		frame:SetPoint("CENTER",UIParent,"CENTER",0,0)
		frame:EnableMouse()
		frame:SetMovable(true)
		frame:SetResizable(true)
		frame:SetFrameStrata("FULLSCREEN_DIALOG")
		frame:SetScript("OnMouseDown", frameOnMouseDown)
		
		frame:SetScript("OnHide",frameOnClose)
		frame:SetMinResize(240,240)
		frame:SetToplevel(true)

		local titlebg = frame:CreateTexture(nil, "BACKGROUND")
		titlebg:SetTexture([[Interface\PaperDollInfoFrame\UI-GearManager-Title-Background]])
		titlebg:SetPoint("TOPLEFT", 9, -6)
		titlebg:SetPoint("BOTTOMRIGHT", frame, "TOPRIGHT", -28, -24)
		
		local dialogbg = frame:CreateTexture(nil, "BACKGROUND")
		dialogbg:SetTexture([[Interface\Tooltips\UI-Tooltip-Background]])
		dialogbg:SetPoint("TOPLEFT", 8, -24)
		dialogbg:SetPoint("BOTTOMRIGHT", -6, 8)
		dialogbg:SetVertexColor(0, 0, 0, .75)
		
		local topleft = frame:CreateTexture(nil, "BORDER")
		topleft:SetTexture([[Interface\PaperDollInfoFrame\UI-GearManager-Border]])
		topleft:SetWidth(64)
		topleft:SetHeight(64)
		topleft:SetPoint("TOPLEFT")
		topleft:SetTexCoord(0.501953125, 0.625, 0, 1)
		
		local topright = frame:CreateTexture(nil, "BORDER")
		topright:SetTexture([[Interface\PaperDollInfoFrame\UI-GearManager-Border]])
		topright:SetWidth(64)
		topright:SetHeight(64)
		topright:SetPoint("TOPRIGHT")
		topright:SetTexCoord(0.625, 0.75, 0, 1)
		
		local top = frame:CreateTexture(nil, "BORDER")
		top:SetTexture([[Interface\PaperDollInfoFrame\UI-GearManager-Border]])
		top:SetHeight(64)
		top:SetPoint("TOPLEFT", topleft, "TOPRIGHT")
		top:SetPoint("TOPRIGHT", topright, "TOPLEFT")
		top:SetTexCoord(0.25, 0.369140625, 0, 1)
		
		local bottomleft = frame:CreateTexture(nil, "BORDER")
		bottomleft:SetTexture([[Interface\PaperDollInfoFrame\UI-GearManager-Border]])
		bottomleft:SetWidth(64)
		bottomleft:SetHeight(64)
		bottomleft:SetPoint("BOTTOMLEFT")
		bottomleft:SetTexCoord(0.751953125, 0.875, 0, 1)
		
		local bottomright = frame:CreateTexture(nil, "BORDER")
		bottomright:SetTexture([[Interface\PaperDollInfoFrame\UI-GearManager-Border]])
		bottomright:SetWidth(64)
		bottomright:SetHeight(64)
		bottomright:SetPoint("BOTTOMRIGHT")
		bottomright:SetTexCoord(0.875, 1, 0, 1)
		
		local bottom = frame:CreateTexture(nil, "BORDER")
		bottom:SetTexture([[Interface\PaperDollInfoFrame\UI-GearManager-Border]])
		bottom:SetHeight(64)
		bottom:SetPoint("BOTTOMLEFT", bottomleft, "BOTTOMRIGHT")
		bottom:SetPoint("BOTTOMRIGHT", bottomright, "BOTTOMLEFT")
		bottom:SetTexCoord(0.376953125, 0.498046875, 0, 1)
		
		local left = frame:CreateTexture(nil, "BORDER")
		left:SetTexture([[Interface\PaperDollInfoFrame\UI-GearManager-Border]])
		left:SetWidth(64)
		left:SetPoint("TOPLEFT", topleft, "BOTTOMLEFT")
		left:SetPoint("BOTTOMLEFT", bottomleft, "TOPLEFT")
		left:SetTexCoord(0.001953125, 0.125, 0, 1)
		
		local right = frame:CreateTexture(nil, "BORDER")
		right:SetTexture([[Interface\PaperDollInfoFrame\UI-GearManager-Border]])
		right:SetWidth(64)
		right:SetPoint("TOPRIGHT", topright, "BOTTOMRIGHT")
		right:SetPoint("BOTTOMRIGHT", bottomright, "TOPRIGHT")
		right:SetTexCoord(0.1171875, 0.2421875, 0, 1)
		
		local close = CreateFrame("Button", nil, frame, "UIPanelCloseButton")
		close:SetPoint("TOPRIGHT", 2, 1)
		close:SetScript("OnClick", closeOnClick)
		self.closebutton = close
		close.obj = self
		
		local titletext = frame:CreateFontString(nil, "ARTWORK")
		titletext:SetFontObject(GameFontNormal)
		titletext:SetPoint("TOPLEFT", 12, -8)
		titletext:SetPoint("TOPRIGHT", -32, -8)
		self.titletext = titletext
		
		local title = CreateFrame("Button", nil, frame)
		title:SetPoint("TOPLEFT", titlebg)
		title:SetPoint("BOTTOMRIGHT", titlebg)
		title:EnableMouse()
		title:SetScript("OnMouseDown",titleOnMouseDown)
		title:SetScript("OnMouseUp", frameOnMouseUp)
		self.title = title
		
		local sizer_se = CreateFrame("Frame",nil,frame)
		sizer_se:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",0,0)
		sizer_se:SetWidth(25)
		sizer_se:SetHeight(25)
		sizer_se:EnableMouse()
		sizer_se:SetScript("OnMouseDown",sizerseOnMouseDown)
		sizer_se:SetScript("OnMouseUp", sizerOnMouseUp)
		self.sizer_se = sizer_se

		local line1 = sizer_se:CreateTexture(nil, "BACKGROUND")
		self.line1 = line1
		line1:SetWidth(14)
		line1:SetHeight(14)
		line1:SetPoint("BOTTOMRIGHT", -8, 8)
		line1:SetTexture("Interface\\Tooltips\\UI-Tooltip-Border")
		local x = 0.1 * 14/17
		line1:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)

		local line2 = sizer_se:CreateTexture(nil, "BACKGROUND")
		self.line2 = line2
		line2:SetWidth(8)
		line2:SetHeight(8)
		line2:SetPoint("BOTTOMRIGHT", -8, 8)
		line2:SetTexture("Interface\\Tooltips\\UI-Tooltip-Border")
		local x = 0.1 * 8/17
		line2:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)

		local sizer_s = CreateFrame("Frame",nil,frame)
		sizer_s:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",-25,0)
		sizer_s:SetPoint("BOTTOMLEFT",frame,"BOTTOMLEFT",0,0)
		sizer_s:SetHeight(25)
		sizer_s:EnableMouse()
		sizer_s:SetScript("OnMouseDown",sizersOnMouseDown)
		sizer_s:SetScript("OnMouseUp", sizerOnMouseUp)
		self.sizer_s = sizer_s
		
		local sizer_e = CreateFrame("Frame",nil,frame)
		sizer_e:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",0,25)
		sizer_e:SetPoint("TOPRIGHT",frame,"TOPRIGHT",0,0)
		sizer_e:SetWidth(25)
		sizer_e:EnableMouse()
		sizer_e:SetScript("OnMouseDown",sizereOnMouseDown)
		sizer_e:SetScript("OnMouseUp", sizerOnMouseUp)
		self.sizer_e = sizer_e
	
		--Container Support
		local content = CreateFrame("Frame",nil,frame)
		self.content = content
		content.obj = self
		content:SetPoint("TOPLEFT",frame,"TOPLEFT",12,-32)
		content:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",-12,13)
		
		AceGUI:RegisterAsContainer(self)
		return self	
	end
	
	AceGUI:RegisterWidgetType(Type,Constructor,Version)
end

================
File: Libs/vanilla/LibDBIcon-1.0/LibDBIcon-1.0.lua
================
print("|cff00ff00[DEBUG] STO CARICANDO LibDBIcon-1.0.lua ORA!|r")
-----------------------------------------------------------------------
-- LibDBIcon-1.0
--
-- Allows addons to easily create a lightweight minimap icon as an alternative to heavier LDB displays.
--

local DBICON10 = "LibDBIcon-1.0"
local DBICON10_MINOR = 44 -- Bump on changes
if not LibStub then error(DBICON10 .. " requires LibStub.") end
local ldb = LibStub("LibDataBroker-1.1", true)
if not ldb then error(DBICON10 .. " requires LibDataBroker-1.1.") end
local lib = LibStub:NewLibrary(DBICON10, DBICON10_MINOR)
if not lib then return end

LibStub("AceHook-3.0"):Embed(lib)
lib.objects = lib.objects or {}
lib.callbackRegistered = lib.callbackRegistered or nil
lib.callbacks = lib.callbacks or LibStub("CallbackHandler-1.0"):New(lib)
lib.notCreated = lib.notCreated or {}
lib.radius = lib.radius or 5
lib.tooltip = lib.tooltip or CreateFrame("GameTooltip", "LibDBIconTooltip", UIParent, "GameTooltipTemplate")
local next, Minimap = next, Minimap
local tgetn = table.getn
local isDraggingButton = false

function lib:IconCallback(event, name, key, value)
	if lib.objects[name] then
		if key == "icon" then
			lib.objects[name].icon:SetTexture(value)
		elseif key == "iconCoords" then
			lib.objects[name].icon:UpdateCoord()
		elseif key == "iconR" then
			local _, g, b = lib.objects[name].icon:GetVertexColor()
			lib.objects[name].icon:SetVertexColor(value, g, b)
		elseif key == "iconG" then
			local r, _, b = lib.objects[name].icon:GetVertexColor()
			lib.objects[name].icon:SetVertexColor(r, value, b)
		elseif key == "iconB" then
			local r, g = lib.objects[name].icon:GetVertexColor()
			lib.objects[name].icon:SetVertexColor(r, g, value)
		end
	end
end
if not lib.callbackRegistered then
	ldb.RegisterCallback(lib, "LibDataBroker_AttributeChanged__icon", "IconCallback")
	ldb.RegisterCallback(lib, "LibDataBroker_AttributeChanged__iconCoords", "IconCallback")
	ldb.RegisterCallback(lib, "LibDataBroker_AttributeChanged__iconR", "IconCallback")
	ldb.RegisterCallback(lib, "LibDataBroker_AttributeChanged__iconG", "IconCallback")
	ldb.RegisterCallback(lib, "LibDataBroker_AttributeChanged__iconB", "IconCallback")
	lib.callbackRegistered = true
end

local function getAnchors(frame)
	local x, y = frame:GetCenter()
	if not x or not y then return "CENTER" end
	local hhalf = (x > UIParent:GetWidth()*2/3) and "RIGHT" or (x < UIParent:GetWidth()/3) and "LEFT" or ""
	local vhalf = (y > UIParent:GetHeight()/2) and "TOP" or "BOTTOM"
	return vhalf..hhalf, frame, (vhalf == "TOP" and "BOTTOM" or "TOP")..hhalf
end

local function onEnter()
	if isDraggingButton then return end

	for _, button in next, lib.objects do
		if button.showOnMouseover then
			--button.fadeOut:Stop()
			button:SetAlpha(1)
		end
	end

	local obj = this.dataObject
	if obj.OnTooltipShow then
		lib.tooltip:SetOwner(this, "ANCHOR_NONE")
		lib.tooltip:SetPoint(getAnchors(this))
		obj.OnTooltipShow(lib.tooltip)
		lib.tooltip:Show()
	elseif obj.OnEnter then
		obj.OnEnter()
	end
end

local function onLeave()
	lib.tooltip:Hide()

	if not isDraggingButton then
		for _, button in next, lib.objects do
			if button.showOnMouseover then
				--button.fadeOut:Play()
			end
		end
	end

	local obj = this.dataObject
	if obj.OnLeave then
		obj.OnLeave()
	end
end

--------------------------------------------------------------------------------

local onDragStart, updatePosition

do
	local minimapShapes = {
		["ROUND"] = {true, true, true, true},
		["SQUARE"] = {false, false, false, false},
		["CORNER-TOPLEFT"] = {false, false, false, true},
		["CORNER-TOPRIGHT"] = {false, false, true, false},
		["CORNER-BOTTOMLEFT"] = {false, true, false, false},
		["CORNER-BOTTOMRIGHT"] = {true, false, false, false},
		["SIDE-LEFT"] = {false, true, false, true},
		["SIDE-RIGHT"] = {true, false, true, false},
		["SIDE-TOP"] = {false, false, true, true},
		["SIDE-BOTTOM"] = {true, true, false, false},
		["TRICORNER-TOPLEFT"] = {false, true, true, true},
		["TRICORNER-TOPRIGHT"] = {true, false, true, true},
		["TRICORNER-BOTTOMLEFT"] = {true, true, false, true},
		["TRICORNER-BOTTOMRIGHT"] = {true, true, true, false},
	}

	local rad, cos, sin, sqrt, max, min = math.rad, math.cos, math.sin, math.sqrt, math.max, math.min
	function updatePosition(button, position)
		local angle = rad(position or 225)
		local x, y, q = cos(angle), sin(angle), 1
		if x < 0 then q = q + 1 end
		if y > 0 then q = q + 2 end
		local minimapShape = GetMinimapShape and GetMinimapShape() or "ROUND"
		local quadTable = minimapShapes[minimapShape]
		local w = (Minimap:GetWidth() / 2) + lib.radius
		local h = (Minimap:GetHeight() / 2) + lib.radius
		if quadTable[q] then
			x, y = x*w, y*h
		else
			local diagRadiusW = sqrt(2*(w)^2)-10
			local diagRadiusH = sqrt(2*(h)^2)-10
			x = max(-w, min(x*diagRadiusW, w))
			y = max(-h, min(y*diagRadiusH, h))
		end
		button:SetPoint("CENTER", Minimap, "CENTER", x, y)
	end
end

local function onClick( )
	if this.dataObject.OnClick then
		this.dataObject.OnClick( this, arg1)
	end
end

local function onMouseDown()
	this.isMouseDown = true
	this.icon:UpdateCoord()
end

local function onMouseUp()
	this.isMouseDown = false
	this.icon:UpdateCoord()
end

local fmod = function(x, y)
    return x - math.floor(x / y) * y
end

do
	local deg, atan2 = math.deg, math.atan2
	local function onUpdate()
		local mx, my = Minimap:GetCenter()
		local px, py = GetCursorPosition()
		local scale = Minimap:GetEffectiveScale()
		px, py = px / scale, py / scale
		local pos = 225
		if this.db then
			pos = fmod(deg(atan2(py - my, px - mx)) , 360)
			this.db.minimapPos = pos
		else
			pos = fmod(deg(atan2(py - my, px - mx)) , 360)
			this.minimapPos = pos
		end
		updatePosition(this, pos)
	end

	function onDragStart()
		this:LockHighlight()
		this.isMouseDown = true
		this.icon:UpdateCoord()
		this:SetScript("OnUpdate", onUpdate)
		isDraggingButton = true
		lib.tooltip:Hide()
		for _, button in next, lib.objects do
			if button.showOnMouseover then
				--button.fadeOut:Stop()
				button:SetAlpha(1)
			end
		end
	end
end

local function onDragStop()
	this:SetScript("OnUpdate", nil)
	this.isMouseDown = false
	this.icon:UpdateCoord()
	this:UnlockHighlight()
	isDraggingButton = false
	for _, button in next, lib.objects do
		if button.showOnMouseover then
			--button.fadeOut:Play()
		end
	end
end

local defaultCoords = {0, 1, 0, 1}
local function updateCoord(self)
	local coords = self:GetParent().dataObject.iconCoords or defaultCoords
	local deltaX, deltaY = 0, 0
	if not self:GetParent().isMouseDown then
		deltaX = (coords[2] - coords[1]) * 0.05
		deltaY = (coords[4] - coords[3]) * 0.05
	end
	self:SetTexCoord(coords[1] + deltaX, coords[2] - deltaX, coords[3] + deltaY, coords[4] - deltaY)
end

local function createButton(name, object, db)
	local button = CreateFrame("Button", "LibDBIcon10_"..name, Minimap)
	button.dataObject = object
	button.db = db
	button:SetFrameStrata("MEDIUM")
	button:SetWidth(31)
	button:SetHeight(31)
	button:SetFrameLevel(8)
	button:SetFrameStrata("HIGH")
	button:SetFrameLevel(7)
	button:EnableMouse(true)
	--button:EnableMouseWheel(true)
	button:SetMovable(true)
	button:RegisterForClicks("LeftButtonUp","RightButtonUp")
	button:RegisterForDrag("LeftButton")
	button:SetHighlightTexture("Interface\\Minimap\\UI-Minimap-ZoomButton-Highlight")
	local overlay = button:CreateTexture(nil, "OVERLAY")
	overlay:SetWidth(53)
	overlay:SetHeight(53)
	overlay:SetTexture("Interface\\Minimap\\MiniMap-TrackingBorder")
	overlay:SetPoint("TOPLEFT",0,0)
	local background = button:CreateTexture(nil, "BACKGROUND")
	background:SetWidth(20)
	background:SetHeight(20)
	background:SetTexture("Interface\\Minimap\\UI-Minimap-Background")
	background:SetPoint("TOPLEFT", 7, -5)
	local icon = button:CreateTexture(nil, "ARTWORK")
	icon:SetWidth(17)
	icon:SetHeight(17)
	icon:SetTexture(object.icon)
	icon:SetPoint("TOPLEFT", 7, -6)
	button.icon = icon
	icon.parent = button
	button.isMouseDown = false

	local r, g, b = icon:GetVertexColor()
	icon:SetVertexColor(object.iconR or r, object.iconG or g, object.iconB or b)

	icon.UpdateCoord = updateCoord
	icon:UpdateCoord()

	button:SetScript("OnEnter", onEnter)
	button:SetScript("OnLeave", onLeave)
	button:SetScript("OnClick",  onClick)
	if not db or not db.lock then
		button:SetScript("OnDragStart", onDragStart)
		button:SetScript("OnDragStop", onDragStop)
	end
	button:SetScript("OnMouseDown", onMouseDown)
	button:SetScript("OnMouseUp", onMouseUp)
--[[
	button.fadeOut = button:CreateAnimationGroup()
	local animOut = button.fadeOut:CreateAnimation("Alpha")
	animOut:SetOrder(1)
	animOut:SetDuration(0.2)
	animOut:SetFromAlpha(1)
	animOut:SetToAlpha(0)
	animOut:SetStartDelay(1)
	button.fadeOut:SetToFinalAlpha(true)
]]
	lib.objects[name] = button

	if lib.loggedIn then
		updatePosition(button, db and db.minimapPos)
		if not db or not db.hide then
			button:Show()
		else
			button:Hide()
		end
	end
	lib.callbacks:Fire("LibDBIcon_IconCreated", button, name) -- Fire 'Icon Created' callback
end

-- We could use a metatable.__index on lib.objects, but then we'd create
-- the icons when checking things like :IsRegistered, which is not necessary.
local function check(name)
	if lib.notCreated[name] then
		createButton(name, lib.notCreated[name][1], lib.notCreated[name][2])
		lib.notCreated[name] = nil
	end
end

-- Wait a bit with the initial positioning to let any GetMinimapShape addons
-- load up.
if not lib.loggedIn then
	local f = CreateFrame("Frame")
	f:SetScript("OnEvent", function()
		for _, button in next, lib.objects do
			updatePosition(button, button.db and button.db.minimapPos)
			if not button.db or not button.db.hide then
				button:Show()
			else
				button:Hide()
			end
		end
		lib.loggedIn = true
		this:SetScript("OnEvent", nil)
	end)
	f:RegisterEvent("PLAYER_LOGIN")
end

local function getDatabase(name)
	return lib.notCreated[name] and lib.notCreated[name][2] or lib.objects[name].db
end

function lib:Register(name, object, db)
	if not object.icon then error("Can't register LDB objects without icons set!") end
	if lib.objects[name] or lib.notCreated[name] then error(DBICON10.. ": Object '".. name .."' is already registered.") end
	if not db or not db.hide then
		createButton(name, object, db)
	else
		lib.notCreated[name] = {object, db}
	end
end

function lib:Lock(name)
	if not lib:IsRegistered(name) then return end
	if lib.objects[name] then
		lib.objects[name]:SetScript("OnDragStart", nil)
		lib.objects[name]:SetScript("OnDragStop", nil)
	end
	local db = getDatabase(name)
	if db then
		db.lock = true
	end
end

function lib:Unlock(name)
	if not lib:IsRegistered(name) then return end
	if lib.objects[name] then
		lib.objects[name]:SetScript("OnDragStart", onDragStart)
		lib.objects[name]:SetScript("OnDragStop", onDragStop)
	end
	local db = getDatabase(name)
	if db then
		db.lock = nil
	end
end

function lib:Hide(name)
	if not lib.objects[name] then return end
	lib.objects[name]:Hide()
end

function lib:Show(name)
	check(name)
	local button = lib.objects[name]
	if button then
		button:Show()
		updatePosition(button, button.db and button.db.minimapPos or button.minimapPos)
	end
end

function lib:IsRegistered(name)
	return (lib.objects[name] or lib.notCreated[name]) and true or false
end

function lib:Refresh(name, db)
	check(name)
	local button = lib.objects[name]
	if db then
		button.db = db
	end
	updatePosition(button, button.db and button.db.minimapPos or button.minimapPos)
	if not button.db or not button.db.hide then
		button:Show()
	else
		button:Hide()
	end
	if not button.db or not button.db.lock then
		button:SetScript("OnDragStart", onDragStart)
		button:SetScript("OnDragStop", onDragStop)
	else
		button:SetScript("OnDragStart", nil)
		button:SetScript("OnDragStop", nil)
	end
end

function lib:GetMinimapButton(name)
	return lib.objects[name]
end

do
	local function OnMinimapEnter()
		if isDraggingButton then return end
		for _, button in next, lib.objects do
			if button.showOnMouseover then
			--	button.fadeOut:Stop()
				button:SetAlpha(1)
			end
		end
	end
	local function OnMinimapLeave()
		if isDraggingButton then return end
		for _, button in next, lib.objects do
			if button.showOnMouseover then
			--	button.fadeOut:Play()
			end
		end
	end
	lib:HookScript(Minimap, "OnEnter", OnMinimapEnter)
	lib:HookScript(Minimap, "OnLeave", OnMinimapLeave)

	function lib:ShowOnEnter(name, value)
		local button = lib.objects[name]
		if button then
			if value then
				button.showOnMouseover = true
			--	button.fadeOut:Stop()
				button:SetAlpha(0)
			else
				button.showOnMouseover = false
			--	button.fadeOut:Stop()
				button:SetAlpha(1)
			end
		end
	end
end

function lib:GetButtonList()
	local t = {}
	for name in next, lib.objects do
		tinsert(t, name)
	end
	return t
end

function lib:SetButtonRadius(radius)
	if type(radius) == "number" then
		lib.radius = radius
		for _, button in next, lib.objects do
			updatePosition(button, button.db and button.db.minimapPos or button.minimapPos)
		end
	end
end

function lib:SetButtonToPosition(button, position)
	updatePosition(lib.objects[button] or button, position)
end

-- Upgrade!
for name, button in next, lib.objects do
	local db = getDatabase(name)
	if not db or not db.lock then
		button:SetScript("OnDragStart", onDragStart)
		button:SetScript("OnDragStop", onDragStop)
	end
	button:SetScript("OnEnter", onEnter)
	button:SetScript("OnLeave", onLeave)
	button:SetScript("OnClick", onClick)
	button:SetScript("OnMouseDown", onMouseDown)
	button:SetScript("OnMouseUp", onMouseUp)
--[[
	if not button.fadeOut then -- Upgrade to 39
		button.fadeOut = button:CreateAnimationGroup()
		local animOut = button.fadeOut:CreateAnimation("Alpha")
		animOut:SetOrder(1)
		animOut:SetDuration(0.2)
		animOut:SetFromAlpha(1)
		animOut:SetToAlpha(0)
		animOut:SetStartDelay(1)
		button.fadeOut:SetToFinalAlpha(true)
	end
	]]
end
lib:SetButtonRadius(lib.radius) -- Upgrade to 40

================
File: RaidCaller.toc
================
## Interface: 11200
## Title: RaidCaller
## Author: Tuo Nome
## Version: 5.0 (Full Library Set)
## Notes: Assistente per le chiamate in raid, con set di librerie completo.

## SavedVariables: RaidCallerDB
## OptionalDeps: Ace3, BigWigs

# ===================================================================
# FONDAMENTA (L'ordine e' critico)
# ===================================================================
Libs\vanilla\LibStub\LibStub.lua
Libs\vanilla\CallbackHandler-1.0\CallbackHandler-1.0.xml
Libs\vanilla\LibDataBroker-1.1\LibDataBroker-1.1.lua


# ===================================================================
# LIBRERIE PRINCIPALI (Caricate nell'ordine delle dipendenze)
# ===================================================================
Libs\vanilla\Ace3\AceCore-3.0\AceCore-3.0.xml
Libs\vanilla\Ace3\AceHook-3.0\AceHook-3.0.xml
Libs\vanilla\Ace3\AceAddon-3.0\AceAddon-3.0.xml
Libs\vanilla\Ace3\AceEvent-3.0\AceEvent-3.0.xml
Libs\vanilla\Ace3\AceConsole-3.0\AceConsole-3.0.xml
Libs\vanilla\Ace3\AceDB-3.0\AceDB-3.0.xml
Libs\vanilla\Ace3\AceGUI-3.0\AceGUI-3.0.xml
Libs\vanilla\LibDBIcon-1.0\LibDBIcon-1.0.lua

# ===================================================================
# DATI E MODULI DELL'ADDON
# ===================================================================
phrases.lua
Config.lua
BossDetector.lua
UI.lua

# ===================================================================
# FILE PRINCIPALE (Stabile)
# ===================================================================
RaidCaller.lua

================
File: RaidCaller.lua
================
-- RaidCaller.lua
-- Main addon object. Rewritten with a stable, two-phase initialization lifecycle.

RaidCaller = RaidCaller or {}

local addonName = "RaidCaller"
local RC = LibStub("AceAddon-3.0"):NewAddon(addonName, "AceConsole-3.0", "AceEvent-3.0")
RaidCaller.addon = RC


-- PHASE 1: Initialize non-UI, non-event systems. This runs very early.
function RC:OnInitialize()
    self:Print("RaidCaller Initializing (Phase 1: Core Systems)...")
    
    -- Setup Database
    local defaults = { profile = { isAutomatic = false, manualRaid = nil, manualBoss = nil, minimap = { hide = false } } }
    self.db = LibStub("AceDB-3.0"):New("RaidCallerDB", defaults, true)

    -- Create non-UI modules
    self.Config = RaidCaller.ConfigModule:new(self.db)
    self.BossDetector = RaidCaller.BossDetectorModule:new(self)

    -- Load phrase data
    self.phrases = RaidCaller.PhraseData or {}
    RaidCaller.PhraseData = nil
    
    self:Print("Core Systems Initialized.")
end

-- PHASE 2: Initialize UI and connect to the game world. This runs when the addon is enabled.
function RC:OnEnable()
    self:Print("RaidCaller Enabling (Phase 2: UI and Events)...")

    -- Create the UI module HERE. It's safer as it may create frames.
    self.UI = RaidCaller.UIModule:new(self, self.Config)
    if not self.UI then
        self:Print("|cffff0000CRITICAL ERROR: UI Module failed to create. Addon will be non-interactive.|r")
        return
    end

    -- Setup slash commands HERE, now that we know the UI object exists.
    self:RegisterChatCommand("rc", "ChatCommand")
    self:RegisterChatCommand("raidcaller", "ChatCommand")

    -- Setup the minimap icon
    self:SetupMinimapIcon()
    
    -- Register for game events
    self:RegisterEvent("PLAYER_ENTERING_WORLD")
    self:RegisterEvent("ZONE_CHANGED_NEW_AREA")
    
    -- Hook other addons if needed
    if self.Config and self.Config:IsAutomaticMode() and IsAddOnLoaded("BigWigs") then
        self:HookBigWigs()
    end

    self:Print("RaidCaller Fully Enabled and Ready.")
end

function RC:HookBigWigs()
    if not self.BossDetector then return end
    self:RegisterMessage("BigWigs_EncounterStart", "OnEncounterStart")
    self:RegisterMessage("BigWigs_EncounterEnd", "OnEncounterEnd")
    self:Print("BigWigs integration enabled for Automatic Mode.")
end

function RC:UnhookBigWigs()
    self:UnregisterMessage("BigWigs_EncounterStart")
    self:UnregisterMessage("BigWigs_EncounterEnd")
    self:Print("BigWigs integration disabled.")
end

function RC:ChatCommand(input)
    if not self.UI then return end -- Safety check
    if type(input) ~= "string" then return end

    if input == "" then
        self.UI:Toggle()
        return
    end
    
    local ok, command, arg = pcall(string.match, input, "^(%S+)%s*(.-)$")
    if not ok or not command then return end

    command = string.lower(command)

    if command == "say" and tonumber(arg) then
        self:SayPhrase(tonumber(arg))
    elseif command == "toggle" then
        self.UI:Toggle()
    else
        self:Print("Usage: /rc [toggle|say <#>]")
    end
end

function RC:SetupMinimapIcon()
    local LDB = LibStub("LibDBIcon-1.0", true)
    if not LDB then
        self:Print("|cffff8800Warning: LibDBIcon-1.0 library not found. Minimap icon disabled.|r")
        return
    end
    
    local uiObject = self.UI
    if not uiObject then
        self:Print("|cffff0000Error: UI object not found when setting up minimap icon.|r")
        return
    end

    LDB:Register("RaidCaller", {
        icon = "Interface\\Icons\\Spell_Holy_WordFortitude",
        tooltip = "RaidCaller",
        onclick = function(_, button)
            if button == "LeftButton" then
                uiObject:Toggle()
            end
        end
    }, self.db.profile.minimap)
end

function RC:PLAYER_ENTERING_WORLD() if self.BossDetector then self.BossDetector:UpdateZone() end end
function RC:ZONE_CHANGED_NEW_AREA() if self.BossDetector then self.BossDetector:UpdateZone() end end
function RC:OnEncounterStart(_, _, _, _, bossName) if self.BossDetector then self.BossDetector:SetBoss(bossName) end end
function RC:OnEncounterEnd() if self.BossDetector then self.BossDetector:SetBoss(nil) end end

function RC:GetCurrentPhrases()
    if not self.BossDetector then return nil end
    local currentRaid, currentBoss = self.BossDetector:GetCurrentRaidAndBoss()
    if currentRaid and currentBoss and self.phrases[currentRaid] and self.phrases[currentRaid][currentBoss] then
        return self.phrases[currentRaid][currentBoss].Phrases
    end
    return nil
end

function RC:SayPhrase(index)
    local phrases = self:GetCurrentPhrases()
    if not phrases or not phrases[index] then
        self:Print("No phrase found. Please select a raid and boss in manual mode.")
        return
    end

    if UnitIsGroupLeader("player") or UnitIsGroupAssistant("player") then
        SendChatMessage(phrases[index], "RAID")
    else
        self:Print("You must be a raid leader or assistant to make calls.")
    end
end

================
File: UI.lua
================
-- UI.lua
-- Creates and manages the user interface for RaidCaller

RaidCaller = RaidCaller or {}

local UIModule = {}
RaidCaller.UIModule = UIModule

local AceGUI = LibStub("AceGUI-3.0")
local MAX_BUTTONS = 15

-- Helper function to safely create widgets and report errors
local function CreateWidget(widgetType)
    local widget = AceGUI:Create(widgetType)
    if not widget then
        print(string.format("|cffff0000RaidCaller Error: AceGUI failed to create a '%s'. Your AceGUI-3.0 library is likely incomplete or corrupted.|r", widgetType))
    end
    return widget
end

function UIModule:new(addon, config)
    local ui = {}
    ui.addon = addon
    ui.config = config
    ui.mainFrame = nil
    ui.widgets = {}
    -- Store the sorted lists to translate indexes back to names
    ui.sortedRaidNames = {} 
    ui.sortedBossNames = {}
    
    -- This function is now fully compatible with the Lua 5.0 interpreter.
    function ui:DebugPrint(...)
        if self.addon and self.addon.debug then
            local output = "|cff33ff99DEBUG:|r"
            -- In Lua 5.0, varargs are accessed via the special 'arg' table.
            -- 'arg.n' holds the number of arguments.
            for i = 1, (arg and arg.n or 0) do
                output = output .. " " .. tostring(arg[i])
            end
            self.addon:Print(output)
        end
    end

    function ui:Create()
        self.mainFrame = CreateWidget("Frame")
        if not self.mainFrame then return end -- Critical failure, cannot continue

        self.mainFrame:SetTitle("RaidCaller v5.2")
        self.mainFrame:SetLayout("Flow")
        self.mainFrame:SetPoint("CENTER")
        self.mainFrame:SetWidth(400)
        self.mainFrame:SetHeight(500)
        self.mainFrame:Hide()

        local controlsGroup = CreateWidget("SimpleGroup")
        if controlsGroup then
            controlsGroup:SetLayout("Flow")
            controlsGroup:SetFullWidth(true)
            self.mainFrame:AddChild(controlsGroup)

            -- Create automatic mode checkbox
            self.widgets.autoModeCheckbox = CreateWidget("CheckBox")
            if self.widgets.autoModeCheckbox then
                self.widgets.autoModeCheckbox:SetLabel("Automatic Mode (requires BigWigs)")
                self.widgets.autoModeCheckbox:SetValue(self.config:IsAutomaticMode())
                self.widgets.autoModeCheckbox:SetCallback("OnValueChanged", function()
                    local currentState = self.config:IsAutomaticMode()
                    local newState = not currentState
                    self.config:SetAutomaticMode(newState)
                    if newState then self.addon:HookBigWigs() else self.addon:UnhookBigWigs() end
                    self:Update()
                end)
                controlsGroup:AddChild(self.widgets.autoModeCheckbox)
            end

            -- Create raid dropdown with direct item selection
            self.widgets.raidDropdown = CreateWidget("Dropdown")
            if self.widgets.raidDropdown then
                self.widgets.raidDropdown:SetLabel("Select Raid")
                
                self.raidPulloutOnClick = self.widgets.raidDropdown.pullout and self.widgets.raidDropdown.pullout.OnClick
                
                if self.widgets.raidDropdown.pullout then
                    self.widgets.raidDropdown.pullout.OnClick = function(button)
                        local itemIndex = button.userdata and button.userdata.value
                        self:DebugPrint("Raid pullout clicked, item index:", itemIndex)
                        
                        if self.raidPulloutOnClick then
                            self.raidPulloutOnClick(unpack(arg))
                        end
                        
                        if itemIndex and itemIndex > 0 and self.sortedRaidNames[itemIndex] then
                            local selectedRaidName = self.sortedRaidNames[itemIndex]
                            self.addon:Print("Selected raid: " .. selectedRaidName)
                            self.config:SetManualRaid(selectedRaidName)
                            self.config:SetManualBoss(nil)
                            self:Update()
                        end
                    end
                end
                
                self.widgets.raidDropdown:SetCallback("OnValueChanged", function(_, _, value)
                    self:DebugPrint("Raid dropdown OnValueChanged:", value)
                    
                    if value and value > 0 and self.sortedRaidNames[value] then
                        local selectedRaidName = self.sortedRaidNames[value]
                        self.addon:Print("Selected raid: " .. selectedRaidName)
                        self.config:SetManualRaid(selectedRaidName)
                        self.config:SetManualBoss(nil)
                        self:Update()
                    end
                end)
                
                controlsGroup:AddChild(self.widgets.raidDropdown)
            end

            -- Create boss dropdown with direct item selection
            self.widgets.bossDropdown = CreateWidget("Dropdown")
            if self.widgets.bossDropdown then
                self.widgets.bossDropdown:SetLabel("Select Boss")
                
                self.bossPulloutOnClick = self.widgets.bossDropdown.pullout and self.widgets.bossDropdown.pullout.OnClick
                
                if self.widgets.bossDropdown.pullout then
                    self.widgets.bossDropdown.pullout.OnClick = function(button)
                        local itemIndex = button.userdata and button.userdata.value
                        self:DebugPrint("Boss pullout clicked, item index:", itemIndex)
                        
                        if self.bossPulloutOnClick then
                            self.bossPulloutOnClick(unpack(arg))
                        end
                        
                        if itemIndex and itemIndex > 0 and self.sortedBossNames[itemIndex] then
                            local selectedBossName = self.sortedBossNames[itemIndex]
                            self.addon:Print("Selected boss: " .. selectedBossName)
                            self.config:SetManualBoss(selectedBossName)
                            self:Update()
                        end
                    end
                end
                
                self.widgets.bossDropdown:SetCallback("OnValueChanged", function(_, _, value)
                    self:DebugPrint("Boss dropdown OnValueChanged:", value)
                    
                    if value and value > 0 and self.sortedBossNames[value] then
                        local selectedBossName = self.sortedBossNames[value]
                        self.addon:Print("Selected boss: " .. selectedBossName)
                        self.config:SetManualBoss(selectedBossName)
                        self:Update()
                    end
                end)
                
                controlsGroup:AddChild(self.widgets.bossDropdown)
            end
        end

        local spacer = CreateWidget("Label")
        if spacer then
            spacer:SetText("----------------------------------------")
            spacer:SetFullWidth(true)
            self.mainFrame:AddChild(spacer)
        end

        local phraseGroup = CreateWidget("ScrollFrame")
        if phraseGroup then
            phraseGroup:SetLayout("Flow")
            phraseGroup:SetFullWidth(true)
            phraseGroup:SetHeight(300)
            self.mainFrame:AddChild(phraseGroup)
            
            self.widgets.phraseGroup = phraseGroup
            self.widgets.phraseButtons = {}
        end
        
        return self.mainFrame
    end

    function ui:SetDropdownByName(dropdown, sortedList, name)
        if not dropdown or not sortedList or not name then return end
        
        for i, itemName in ipairs(sortedList) do
            if itemName == name then
                dropdown:SetValue(i)
                return i
            end
        end
        
        dropdown:SetValue(nil)
        return nil
    end

    function ui:Update()
        if not self.mainFrame then return end
        
        local isAutomatic = self.config:IsAutomaticMode()
        if self.widgets.autoModeCheckbox then self.widgets.autoModeCheckbox:SetValue(isAutomatic) end
        if self.widgets.raidDropdown then self.widgets.raidDropdown:SetDisabled(isAutomatic) end
        if self.widgets.bossDropdown then self.widgets.bossDropdown:SetDisabled(isAutomatic) end

        if self.widgets.raidDropdown then
            wipe(self.sortedRaidNames)
            for raidName in pairs(self.addon.phrases) do 
                table.insert(self.sortedRaidNames, raidName) 
            end
            table.sort(self.sortedRaidNames)
            
            local raidList = {}
            for i, raidName in ipairs(self.sortedRaidNames) do
                raidList[i] = raidName
            end
            
            self.widgets.raidDropdown:SetList(raidList)
            self:SetDropdownByName(self.widgets.raidDropdown, self.sortedRaidNames, self.config:GetManualRaid())
        end

        if self.widgets.bossDropdown then
            wipe(self.sortedBossNames)
            
            local currentRaid = nil
            if isAutomatic then
                currentRaid = self.addon.BossDetectorModule:GetCurrentRaid()
            else
                currentRaid = self.config:GetManualRaid()
            end
            
            if currentRaid and self.addon.phrases[currentRaid] then
                for bossName in pairs(self.addon.phrases[currentRaid]) do
                    table.insert(self.sortedBossNames, bossName)
                end
                table.sort(self.sortedBossNames)
                
                local bossList = {}
                for i, bossName in ipairs(self.sortedBossNames) do
                    bossList[i] = bossName
                end
                
                self.widgets.bossDropdown:SetList(bossList)
                self:SetDropdownByName(self.widgets.bossDropdown, self.sortedBossNames, self.config:GetManualBoss())
            else
                self.widgets.bossDropdown:SetList({})
                self.widgets.bossDropdown:SetValue(nil)
            end
        end
        
        if self.widgets.phraseGroup and self.widgets.phraseButtons then
            for _, button in ipairs(self.widgets.phraseButtons) do
                button:Hide()
            end
            wipe(self.widgets.phraseButtons)
            self.widgets.phraseGroup:ReleaseChildren()
            
            local phrases = self.addon:GetCurrentPhrases()
            
            if phrases then
                for i, phrase in ipairs(phrases) do
                    if i <= MAX_BUTTONS then
                        local btn = CreateWidget("Button")
                        if btn then
                            btn:SetText(i .. ". " .. phrase)
                            btn:SetFullWidth(true)
                            btn.phraseIndex = i
                            btn:SetCallback("OnClick", function(widget)
                                self.addon:SayPhrase(widget.phraseIndex)
                            end)
                            self.widgets.phraseGroup:AddChild(btn)
                            table.insert(self.widgets.phraseButtons, btn)
                        end
                    end
                end
            end
        end
    end

    function ui:Toggle()
        if not self.mainFrame then self:Create() end
        if not self.mainFrame then return end
        
        if self.mainFrame.frame:IsShown() then
            self.mainFrame:Hide()
        else
            self:Update()
            self.mainFrame:Show()
        end
    end

    return ui
end




================================================================
End of Codebase
================================================================
